import type { JSONSchema } from '@composedb/types';
import type { SetRequired } from 'type-fest';
import type { AnySchema, ScalarSchema } from '../types.js';
import type { AbstractCompositeDefinition, AbstractModelDefinition, EnumFieldDefinition, ListFieldDefinition, ObjectDefinition, ObjectReferenceFieldDefinition, ParsedModelDefinition, ScalarFieldDefinition, SchemaDefinition } from './types.js';
type CompileObject = SetRequired<JSONSchema.Object, 'properties'>;
type JSONSchemaReference = {
    $ref: string;
};
type ReferencedSchema = ScalarSchema | JSONSchema.Object;
type SchemaWithRefs<T extends AnySchema = AnySchema> = {
    schema: T;
    refs: Array<string>;
};
export declare function createReference(name: string): JSONSchemaReference;
export declare function extractReference(ref: JSONSchemaReference): string;
export declare class SchemaCompiler {
    #private;
    constructor(source: SchemaDefinition);
    _getReference(name: string): SchemaWithRefs<ReferencedSchema>;
    _extractDefinitions(name: string): Record<string, ReferencedSchema>;
    compile(): AbstractCompositeDefinition;
    _compileEmbedObject(name: string, definition: ObjectDefinition): SchemaWithRefs<CompileObject>;
    _compileList(objectName: string, fieldName: string, definition: ListFieldDefinition): SchemaWithRefs;
    _compileObjectReference(objectName: string, fieldName: string, definition: ObjectReferenceFieldDefinition): SchemaWithRefs;
    _compileEnum(objectName: string, fieldName: string, definition: EnumFieldDefinition): SchemaWithRefs;
    _compileScalar(definition: ScalarFieldDefinition): SchemaWithRefs;
    _compileModel(name: string, modelDefinition: ParsedModelDefinition, objectDefinition: ObjectDefinition): AbstractModelDefinition;
}
export declare function compileSchema(definition: SchemaDefinition): AbstractCompositeDefinition;
export declare function createAbstractCompositeDefinition(schema: string): AbstractCompositeDefinition;
export {};
