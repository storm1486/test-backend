import { fetchJson } from '@ceramicnetwork/common';
import { VIEWER_ID_HEADER } from '@composedb/constants';
import { createGraphQLSchema } from '@composedb/runtime';
import { createBatchingExecutor } from '@graphql-tools/batch-execute';
import { stitchSchemas } from '@graphql-tools/stitch';
import { print } from 'graphql';
export function createRemoteExecutor(url, getViewerID) {
    const remoteExecutor = async ({ document, variables })=>{
        const viewerID = getViewerID();
        const headers = viewerID ? {
            [VIEWER_ID_HEADER]: viewerID
        } : {};
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return await fetchJson(url, {
            method: 'POST',
            headers,
            body: {
                query: print(document),
                variables
            }
        });
    };
    return createBatchingExecutor(remoteExecutor);
}
export function createHybridSchema(params) {
    const { definition, getViewerID, remoteExecutor, serverURL } = params;
    let executor;
    if (typeof remoteExecutor === 'function') {
        executor = remoteExecutor;
    } else if (typeof getViewerID === 'function' && typeof serverURL === 'string') {
        executor = createRemoteExecutor(serverURL, getViewerID);
    } else {
        throw new Error('Invalid parameters to create hybrid schema: missing `remoteExecutor` or `getViewerID` and `serverURL` parameters');
    }
    const remoteSchemaConfig = {
        executor,
        schema: createGraphQLSchema({
            definition,
            readonly: true
        })
    };
    return stitchSchemas({
        subschemas: [
            createGraphQLSchema({
                definition
            }),
            remoteSchemaConfig
        ],
        mergeTypes: false,
        onTypeConflict: (left, right, info)=>{
            return info?.left.subschema === remoteSchemaConfig ? left : right;
        }
    });
}
