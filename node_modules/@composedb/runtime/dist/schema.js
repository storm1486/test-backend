function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
import { CeramicCommitID, getScalar } from '@composedb/graphql-scalars';
import { GraphQLBoolean, GraphQLEnumType, GraphQLFloat, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema, GraphQLString, assertValidSchema, isInterfaceType } from 'graphql';
import { connectionArgs, connectionDefinitions, mutationWithClientMutationId, nodeDefinitions } from 'graphql-relay';
import { assertValidQueryFilters, createRelationQueryFilters } from './query.js';
const NON_SCALAR_FIELD_TYPES = [
    'meta',
    'reference',
    'list',
    'view'
];
function isScalarField(field) {
    return !NON_SCALAR_FIELD_TYPES.includes(field.type);
}
const STRING_REFERENCE_TYPES = [
    'enum',
    'node'
];
function isStringReferenceField(field) {
    return field.type === 'reference' && STRING_REFERENCE_TYPES.includes(field.refType);
}
function createAccountReferenceQuery(models, account, reference, filters) {
    const query = {
        models
    };
    if (reference.type === 'account') {
        // Current account is referenced in a document field
        query.queryFilters = createRelationQueryFilters(reference.property, account, filters);
    } else {
        // Current account is the controller of the document
        query.account = account;
        if (filters != null) {
            assertValidQueryFilters(filters);
            query.queryFilters = filters;
        }
    }
    return query;
}
const connectionArgsWithAccount = {
    ...connectionArgs,
    account: {
        type: GraphQLID,
        description: 'Returns only documents created by the provided account'
    }
};
const SetOptionsInput = new GraphQLInputObjectType({
    name: 'SetOptionsInput',
    fields: {
        syncTimeout: {
            type: GraphQLInt,
            description: 'Maximum amount of time to lookup the stream over the network, in seconds - see https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.CreateOpts.html#syncTimeoutSeconds'
        }
    }
});
const UpdateOptionsInput = new GraphQLInputObjectType({
    name: 'UpdateOptionsInput',
    fields: {
        replace: {
            type: GraphQLBoolean,
            defaultValue: false,
            description: 'Fully replace the document contents instead of performing a shallow merge'
        },
        version: {
            type: CeramicCommitID,
            description: 'Only perform mutation if the document matches the provided version'
        }
    }
});
const SortOrder = new GraphQLEnumType({
    name: 'SortOrder',
    values: {
        ASC: {
            value: 'ASC'
        },
        DESC: {
            value: 'DESC'
        }
    }
});
function createEnumValueFilterInput(type) {
    return new GraphQLInputObjectType({
        name: `${type.name}ValueFilterInput`,
        fields: {
            isNull: {
                type: GraphQLBoolean
            },
            equalTo: {
                type
            },
            notEqualTo: {
                type
            },
            in: {
                type: new GraphQLList(new GraphQLNonNull(type))
            },
            notIn: {
                type: new GraphQLList(new GraphQLNonNull(type))
            }
        }
    });
}
function createScalarValueFilterInput(type) {
    return new GraphQLInputObjectType({
        name: `${type.name}ValueFilterInput`,
        fields: {
            isNull: {
                type: GraphQLBoolean
            },
            equalTo: {
                type
            },
            notEqualTo: {
                type
            },
            in: {
                type: new GraphQLList(new GraphQLNonNull(type))
            },
            notIn: {
                type: new GraphQLList(new GraphQLNonNull(type))
            },
            lessThan: {
                type
            },
            lessThanOrEqualTo: {
                type
            },
            greaterThan: {
                type
            },
            greaterThanOrEqualTo: {
                type
            }
        }
    });
}
const valueFilterInputs = {
    BooleanValueFilter: new GraphQLInputObjectType({
        name: 'BooleanValueFilterInput',
        fields: {
            isNull: {
                type: GraphQLBoolean
            },
            equalTo: {
                type: GraphQLBoolean
            }
        }
    }),
    FloatValueFilter: createScalarValueFilterInput(GraphQLFloat),
    IntValueFilter: createScalarValueFilterInput(GraphQLInt),
    StringValueFilter: createScalarValueFilterInput(GraphQLString)
};
const valueFilterInputsTypes = {
    boolean: 'BooleanValueFilter',
    float: 'FloatValueFilter',
    integer: 'IntValueFilter',
    string: 'StringValueFilter'
};
var // Source composite
_def = /*#__PURE__*/ new WeakMap(), // Schema options
_isReadonly = /*#__PURE__*/ new WeakMap(), // Internal records
_types = /*#__PURE__*/ new WeakMap(), _inputObjects = /*#__PURE__*/ new WeakMap(), _mutations = /*#__PURE__*/ new WeakMap(), // Internal mapping of model IDs to object names
_modelAliases = /*#__PURE__*/ new WeakMap();
class SchemaBuilder {
    build() {
        this._buildEnums();
        const definitions = this._createSharedDefinitions();
        this._buildObjects(definitions);
        this._buildConnections();
        const schema = this._createSchema(definitions);
        assertValidSchema(schema);
        return schema;
    }
    _createSharedDefinitions() {
        const nodeDefs = nodeDefinitions(async (id, ctx)=>{
            return id.startsWith('did:') ? id : await ctx.loadDoc(id);
        }, (didOrDoc)=>{
            return typeof didOrDoc === 'string' ? 'CeramicAccount' : _class_private_field_get(this, _modelAliases)[didOrDoc.metadata.model?.toString()];
        });
        const accountObject = new GraphQLObjectType({
            name: 'CeramicAccount',
            interfaces: [
                nodeDefs.nodeInterface
            ],
            fields: ()=>{
                const config = {
                    id: {
                        type: new GraphQLNonNull(GraphQLID),
                        description: 'Globally unique identifier of the account (DID string)',
                        resolve: (did)=>did
                    },
                    isViewer: {
                        type: new GraphQLNonNull(GraphQLBoolean),
                        description: 'Whether the Ceramic instance is currently authenticated with this account or not',
                        resolve: (did, _, ctx)=>ctx.isAuthenticated() && ctx.getViewerID() === did
                    }
                };
                for (const [alias, reference] of Object.entries(_class_private_field_get(this, _def).accountData ?? {})){
                    const model = _class_private_field_get(this, _def).models[reference.name];
                    if (model == null) {
                        throw new Error(`Missing model for reference name: ${reference.name}`);
                    }
                    if (reference.type === 'node') {
                        config[alias] = {
                            type: _class_private_field_get(this, _types)[reference.name],
                            resolve: async (account, _, ctx)=>{
                                return await ctx.querySingle({
                                    account,
                                    models: [
                                        model.id
                                    ]
                                });
                            }
                        };
                    } else if (reference.type === 'account' || reference.type === 'connection') {
                        const filtersObj = _class_private_field_get(this, _inputObjects)[`${reference.name}Filters`];
                        const sortingObj = _class_private_field_get(this, _inputObjects)[`${reference.name}Sorting`];
                        const args = {
                            ...connectionArgs
                        };
                        if (filtersObj && sortingObj) {
                            args.filters = {
                                type: filtersObj
                            };
                            args.sorting = {
                                type: sortingObj
                            };
                        }
                        config[alias] = {
                            type: _class_private_field_get(this, _types)[`${reference.name}Connection`],
                            args,
                            resolve: async (account, { filters, ...args }, ctx)=>{
                                const query = createAccountReferenceQuery([
                                    model.id
                                ], account, reference, filters);
                                return await ctx.queryConnection({
                                    ...query,
                                    ...args
                                });
                            }
                        };
                        config[`${alias}Count`] = {
                            type: new GraphQLNonNull(GraphQLInt),
                            args: filtersObj ? {
                                filters: {
                                    type: filtersObj
                                }
                            } : {},
                            resolve: async (account, { filters }, ctx)=>{
                                const query = createAccountReferenceQuery([
                                    model.id
                                ], account, reference, filters);
                                return await ctx.queryCount(query);
                            }
                        };
                    } else {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        throw new Error(`Unsupported reference type: ${reference.type}`);
                    }
                }
                return config;
            }
        });
        const queryFields = {
            node: nodeDefs.nodeField,
            viewer: {
                type: accountObject,
                description: 'Account currently authenticated on the Ceramic instance, if set',
                resolve: (_self, _args, ctx)=>ctx.getViewerID()
            }
        };
        return {
            ...nodeDefs,
            accountObject,
            queryFields
        };
    }
    _resolveInterfaces(modelName, ids = []) {
        const allInterfaces = ids.flatMap((id)=>{
            const name = _class_private_field_get(this, _modelAliases)[id];
            if (name == null) {
                // Interface is not part of the definition
                return [];
            }
            const type = _class_private_field_get(this, _types)[name];
            if (type == null) {
                throw new Error(`Missing interface ${name} for ${modelName}`);
            }
            if (!isInterfaceType(type)) {
                throw new Error(`Invalid type for ${name} for ${modelName}, expected interface`);
            }
            return [
                type
            ].concat(type.getInterfaces());
        });
        return Array.from(new Set(allInterfaces));
    }
    _buildEnums() {
        for (const [name, values] of Object.entries(_class_private_field_get(this, _def).enums)){
            _class_private_field_get(this, _types)[name] = new GraphQLEnumType({
                name,
                values: values.reduce((acc, value)=>{
                    acc[value] = {
                        value
                    };
                    return acc;
                }, {})
            });
        }
    }
    _buildObjects(definitions) {
        for (const [name, fields] of Object.entries(_class_private_field_get(this, _def).objects)){
            this._buildObjectType({
                definitions,
                name,
                fields
            });
        }
    }
    _buildObjectType(params) {
        const model = _class_private_field_get(this, _def).models[params.name];
        if (model == null) {
            this._buildEmbeddedObjectType(params);
        } else {
            const modelParams = {
                model,
                ...params
            };
            if (model.interface) {
                this._buildInterfaceObjectType(modelParams);
            } else {
                this._buildDocumentObjectType(modelParams);
            }
        }
    }
    _buildInterfaceObjectType({ model, definitions, name, fields }) {
        _class_private_field_get(this, _types)[name] = new GraphQLInterfaceType({
            name,
            interfaces: ()=>this._resolveInterfaces(name, model.implements),
            fields: ()=>{
                const config = {};
                for (const [key, field] of Object.entries(fields)){
                    switch(field.type){
                        case 'meta':
                            continue;
                        case 'reference':
                            config[key] = this._buildDocumentObjectReferenceField(key, field);
                            break;
                        case 'list':
                            config[key] = {
                                type: this._buildObjectListFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                            break;
                        case 'view':
                            {
                                const view = this._buildDocumentObjectViewField(key, definitions, field, fields);
                                if (view) {
                                    config[key] = view;
                                }
                                break;
                            }
                        default:
                            config[key] = {
                                type: this._buildScalarFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                    }
                }
                return config;
            }
        });
        this._buildFiltersType(name, fields, true);
        this._buildSortingType(name, fields, true);
    }
    _buildDocumentObjectType({ model, definitions, name, fields }) {
        _class_private_field_get(this, _types)[name] = new GraphQLObjectType({
            name,
            interfaces: ()=>{
                return [
                    definitions.nodeInterface
                ].concat(this._resolveInterfaces(name, model.implements));
            },
            isTypeOf: (value)=>{
                return value.metadata.model.toString() === model.id;
            },
            fields: ()=>{
                const config = {
                    id: {
                        // Use GraphQLID here for Relay compliance
                        type: new GraphQLNonNull(GraphQLID),
                        resolve: (doc)=>doc.id.toString()
                    }
                };
                for (const [key, field] of Object.entries(fields)){
                    switch(field.type){
                        case 'meta':
                            continue;
                        case 'reference':
                            config[key] = this._buildDocumentObjectReferenceField(key, field);
                            break;
                        case 'list':
                            config[key] = {
                                type: this._buildObjectListFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                            break;
                        case 'view':
                            {
                                const view = this._buildDocumentObjectViewField(key, definitions, field, fields);
                                if (view) {
                                    config[key] = view;
                                }
                                break;
                            }
                        default:
                            config[key] = {
                                type: this._buildScalarFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                    }
                }
                return config;
            }
        });
        this._buildFiltersType(name, fields);
        this._buildSortingType(name, fields);
        if (!_class_private_field_get(this, _isReadonly)) {
            this._buildInputObjectType(name, fields);
            this._buildNodeMutations(definitions.queryFields, name, model);
        }
    }
    _buildEmbeddedObjectType({ definitions, name, fields }) {
        _class_private_field_get(this, _types)[name] = new GraphQLObjectType({
            name,
            fields: ()=>{
                const config = {};
                for (const [key, field] of Object.entries(fields)){
                    switch(field.type){
                        case 'meta':
                            continue;
                        case 'reference':
                            config[key] = this._buildEmbeddedObjectReferenceField(key, field);
                            break;
                        case 'list':
                            config[key] = {
                                type: this._buildObjectListFieldType(definitions, field),
                                resolve: (obj)=>obj[key]
                            };
                            break;
                        case 'view':
                            throw new Error(`Unsupported view field ${key} on embedded object ${name}`);
                        default:
                            config[key] = {
                                type: this._buildScalarFieldType(definitions, field),
                                resolve: (obj)=>obj[key]
                            };
                    }
                }
                return config;
            }
        });
        if (!_class_private_field_get(this, _isReadonly)) {
            this._buildInputObjectType(name, fields);
        }
    }
    _buildConnections() {
        for (const objectName of Object.keys(_class_private_field_get(this, _def).models)){
            const nodeType = _class_private_field_get(this, _types)[objectName];
            if (nodeType == null) {
                throw new Error(`Missing object type for connection: ${objectName}`);
            }
            const { connectionType, edgeType } = connectionDefinitions({
                nodeType
            });
            _class_private_field_get(this, _types)[`${objectName}Connection`] = connectionType;
            _class_private_field_get(this, _types)[`${objectName}Edge`] = edgeType;
        }
    }
    _buildDocumentObjectReferenceField(key, field) {
        const name = field.refType === 'connection' ? field.refName + 'Connection' : field.refName;
        const ref = _class_private_field_get(this, _types)[name];
        if (ref == null) {
            throw new Error(`Missing type: ${name}`);
        }
        const type = field.required ? new GraphQLNonNull(ref) : ref;
        switch(field.refType){
            case 'connection':
                return {
                    type,
                    args: connectionArgs,
                    resolve: (_doc, _args, _ctx)=>{
                        throw new Error('Not implemented');
                    }
                };
            case 'node':
                return {
                    type,
                    args: connectionArgs,
                    resolve: async (doc, _, ctx)=>{
                        return await ctx.loadDoc(doc.content[key]);
                    }
                };
            case 'enum':
            case 'object':
                return {
                    type,
                    resolve: (doc)=>doc.content[key]
                };
            default:
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported reference type on document object: ${field.refType}`);
        }
    }
    _buildEmbeddedObjectReferenceField(key, field) {
        const ref = _class_private_field_get(this, _types)[field.refName];
        if (ref == null) {
            throw new Error(`Missing type: ${field.refName}`);
        }
        const type = field.required ? new GraphQLNonNull(ref) : ref;
        switch(field.refType){
            case 'enum':
            case 'object':
                return {
                    type,
                    resolve: (obj)=>obj[key]
                };
            default:
                throw new Error(`Unsupported reference type on embedded object: ${field.refType}`);
        }
    }
    _buildObjectListFieldType(definitions, field) {
        let itemType;
        if (field.item.type === 'reference') {
            itemType = _class_private_field_get(this, _types)[field.item.refName];
            if (itemType == null) {
                throw new Error(`Missing referenced object type: ${field.item.refName}`);
            }
        } else if (field.item.type === 'did') {
            itemType = definitions.accountObject;
        } else {
            itemType = getScalar(field.item.type);
        }
        if (field.item.required) {
            itemType = new GraphQLNonNull(itemType);
        }
        const type = new GraphQLList(itemType);
        return field.required ? new GraphQLNonNull(type) : type;
    }
    _buildDocumentObjectRelation(key, definitions, relation, objectFields) {
        if (relation.source === 'document') {
            const ref = objectFields[relation.property];
            if (ref == null) {
                throw new Error(`Missing reference field ${relation.property} for relation defined on field ${key}`);
            }
            const type = relation.model ? _class_private_field_get(this, _types)[_class_private_field_get(this, _modelAliases)[relation.model]] : definitions.nodeInterface;
            if (type == null) {
                throw new Error(`Model not found for relation with ID ${relation.model} on field ${key}`);
            }
            return {
                type,
                resolve: async (doc, _args, ctx)=>{
                    const id = doc.content?.[relation.property];
                    if (id == null) {
                        return null;
                    }
                    const loaded = await ctx.loadDoc(id);
                    if (loaded == null) {
                        return null;
                    }
                    if (relation.model != null) {
                        const loadedModel = loaded.metadata.model.toString();
                        if (isInterfaceType(type)) {
                            const model = _class_private_field_get(this, _def).models[_class_private_field_get(this, _modelAliases)[loadedModel]];
                            if (model == null || !model.implements.includes(relation.model)) {
                                console.warn(`Ignoring unsupported model ${loadedModel} for document ${id}, expected model implementing the ${relation.model} interface`);
                                return null;
                            }
                        } else if (loadedModel !== relation.model) {
                            console.warn(`Ignoring unexpected model ${loadedModel} for document ${id}, expected model ${relation.model}`);
                            return null;
                        }
                    }
                    return loaded;
                }
            };
        }
        const relationModel = relation.model;
        if (relationModel == null) {
            throw new Error(`Missing model for relation on field ${key}`);
        }
        const modelAlias = _class_private_field_get(this, _modelAliases)[relationModel];
        if (modelAlias == null) {
            throw new Error(`Model alias not found for relation with ID ${relationModel} on field ${key}`);
        }
        switch(relation.source){
            case 'queryConnection':
                {
                    const qcFiltersObj = _class_private_field_get(this, _inputObjects)[`${modelAlias}Filters`];
                    const qcSortingObj = _class_private_field_get(this, _inputObjects)[`${modelAlias}Sorting`];
                    const args = {
                        ...connectionArgsWithAccount
                    };
                    if (qcFiltersObj && qcSortingObj) {
                        args.filters = {
                            type: qcFiltersObj
                        };
                        args.sorting = {
                            type: qcSortingObj
                        };
                    }
                    return {
                        type: new GraphQLNonNull(_class_private_field_get(this, _types)[`${modelAlias}Connection`]),
                        args,
                        resolve: async (doc, args, ctx)=>{
                            const account = args.account === 'documentAccount' ? doc.metadata.controller : args.account;
                            const queryFilters = createRelationQueryFilters(relation.property, doc.id.toString(), args.filters);
                            return await ctx.queryConnection({
                                ...args,
                                account,
                                models: [
                                    relationModel
                                ],
                                queryFilters
                            });
                        }
                    };
                }
            case 'queryCount':
                {
                    const filtersObj = _class_private_field_get(this, _inputObjects)[`${modelAlias}Filters`];
                    const args = {
                        account: {
                            type: GraphQLID,
                            description: 'Counts only documents created by the provided account'
                        }
                    };
                    if (filtersObj) {
                        args.filters = {
                            type: filtersObj
                        };
                    }
                    return {
                        type: new GraphQLNonNull(GraphQLInt),
                        args,
                        resolve: async (doc, args, ctx)=>{
                            const account = args.account === 'documentAccount' ? doc.metadata.controller : args.account;
                            const queryFilters = createRelationQueryFilters(relation.property, doc.id.toString(), args.filters);
                            return await ctx.queryCount({
                                account,
                                models: [
                                    relationModel
                                ],
                                queryFilters
                            });
                        }
                    };
                }
            default:
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported relation source: ${relation.source}`);
        }
    }
    _buildDocumentObjectViewField(key, definitions, field, objectFields) {
        switch(field.viewType){
            case 'documentAccount':
                return {
                    type: new GraphQLNonNull(definitions.accountObject),
                    description: 'Account controlling the document',
                    resolve: (doc)=>doc.metadata.controller
                };
            case 'documentVersion':
                return {
                    type: new GraphQLNonNull(CeramicCommitID),
                    description: 'Current version of the document',
                    resolve: (doc)=>doc.commitId.toString()
                };
            case 'relation':
                return this._buildDocumentObjectRelation(key, definitions, field.relation, objectFields);
            default:
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported view type: ${field.viewType}`);
        }
    }
    _buildScalarFieldType(definitions, field) {
        const type = field.type === 'did' ? definitions.accountObject : getScalar(field.type);
        return field.required ? new GraphQLNonNull(type) : type;
    }
    _buildFiltersType(objectName, fields, isInterface = false) {
        const objectInputName = `${objectName}ObjectFilter`;
        const inputName = `${objectName}Filters`;
        const config = {};
        for (const [key, field] of Object.entries(fields)){
            let type;
            if (field.type === 'reference' && (field.indexed || isInterface)) {
                if (field.refType === 'enum') {
                    const enumType = _class_private_field_get(this, _types)[field.refName];
                    type = createEnumValueFilterInput(enumType);
                    _class_private_field_get(this, _inputObjects)[type.name] = type;
                } else if (field.refType === 'node') {
                    type = _class_private_field_get(this, _inputObjects).StringValueFilter;
                }
            } else if (isScalarField(field) && (field.indexed || isInterface)) {
                type = _class_private_field_get(this, _inputObjects)[valueFilterInputsTypes[field.type] ?? 'StringValueFilter'];
            }
            if (type != null) {
                config[key] = {
                    type
                };
            }
        }
        if (Object.keys(config).length > 0) {
            _class_private_field_get(this, _inputObjects)[objectInputName] = new GraphQLInputObjectType({
                name: `${objectInputName}Input`,
                fields: ()=>config
            });
            _class_private_field_get(this, _inputObjects)[inputName] = new GraphQLInputObjectType({
                name: `${inputName}Input`,
                fields: ()=>({
                        where: {
                            type: _class_private_field_get(this, _inputObjects)[objectInputName]
                        },
                        and: {
                            type: new GraphQLList(new GraphQLNonNull(_class_private_field_get(this, _inputObjects)[inputName]))
                        },
                        or: {
                            type: new GraphQLList(new GraphQLNonNull(_class_private_field_get(this, _inputObjects)[inputName]))
                        },
                        not: {
                            type: _class_private_field_get(this, _inputObjects)[inputName]
                        }
                    })
            });
        }
    }
    _buildSortingType(objectName, fields, isInterface = false) {
        const name = `${objectName}Sorting`;
        const config = {};
        for (const [key, field] of Object.entries(fields)){
            if ((isStringReferenceField(field) || isScalarField(field)) && (field.indexed || isInterface)) {
                config[key] = {
                    type: SortOrder
                };
            }
        }
        if (Object.keys(config).length > 0) {
            _class_private_field_get(this, _inputObjects)[name] = new GraphQLInputObjectType({
                name: `${name}Input`,
                fields: ()=>config
            });
        }
    }
    _buildInputObjectType(name, fields) {
        const isDocument = _class_private_field_get(this, _def).models[name] != null;
        const buildFields = (required)=>{
            const config = {};
            const inputPrefix = isDocument || required ? '' : 'Partial';
            for (const [key, field] of Object.entries(fields)){
                let type;
                switch(field.type){
                    case 'meta':
                    case 'view':
                        continue;
                    case 'reference':
                        switch(field.refType){
                            case 'connection':
                                continue;
                            case 'enum':
                                type = _class_private_field_get(this, _types)[field.refName];
                                break;
                            case 'node':
                                type = GraphQLID;
                                break;
                            case 'object':
                                {
                                    type = _class_private_field_get(this, _inputObjects)[inputPrefix + field.refName];
                                    if (type == null) {
                                        throw new Error(`Missing referenced input type: ${inputPrefix + field.refName}`);
                                    }
                                    break;
                                }
                        }
                        break;
                    case 'list':
                        {
                            let itemType;
                            if (field.item.type === 'reference') {
                                itemType = _class_private_field_get(this, _inputObjects)[inputPrefix + field.item.refName];
                                if (itemType == null) {
                                    throw new Error(`Missing referenced input type: ${inputPrefix + field.item.refName}`);
                                }
                            } else {
                                itemType = getScalar(field.item.type);
                            }
                            type = new GraphQLList(itemType);
                            break;
                        }
                    default:
                        type = getScalar(field.type);
                }
                if (type != null) {
                    config[key] = {
                        type: required && field.required ? new GraphQLNonNull(type) : type
                    };
                }
            }
            return config;
        };
        _class_private_field_get(this, _inputObjects)[name] = new GraphQLInputObjectType({
            name: `${name}Input`,
            fields: ()=>buildFields(true)
        });
        if (isDocument) {
            _class_private_field_get(this, _inputObjects)[`Partial${name}`] = new GraphQLInputObjectType({
                name: `Partial${name}Input`,
                fields: ()=>buildFields(false)
            });
        }
    }
    _buildNodeMutations(queryFields, name, model) {
        if (model.accountRelation.type === 'single') {
            _class_private_field_get(this, _mutations)[`create${name}`] = mutationWithClientMutationId({
                name: `Create${name}`,
                inputFields: ()=>({
                        content: {
                            type: new GraphQLNonNull(_class_private_field_get(this, _inputObjects)[name])
                        },
                        options: {
                            type: SetOptionsInput
                        }
                    }),
                outputFields: ()=>({
                        ...queryFields,
                        document: {
                            type: new GraphQLNonNull(_class_private_field_get(this, _types)[name])
                        }
                    }),
                mutateAndGetPayload: async (input, ctx)=>{
                    if (ctx.ceramic.did == null || !ctx.ceramic.did.authenticated) {
                        throw new Error('Ceramic instance is not authenticated');
                    }
                    const document = await ctx.createSingle(model.id, input.content, {
                        syncTimeoutSeconds: input.options?.syncTimeout
                    });
                    return {
                        document
                    };
                }
            });
        } else {
            _class_private_field_get(this, _mutations)[`create${name}`] = mutationWithClientMutationId({
                name: `Create${name}`,
                inputFields: ()=>({
                        content: {
                            type: new GraphQLNonNull(_class_private_field_get(this, _inputObjects)[name])
                        }
                    }),
                outputFields: ()=>({
                        ...queryFields,
                        document: {
                            type: new GraphQLNonNull(_class_private_field_get(this, _types)[name])
                        }
                    }),
                mutateAndGetPayload: async (input, ctx)=>{
                    if (ctx.ceramic.did == null || !ctx.ceramic.did.authenticated) {
                        throw new Error('Ceramic instance is not authenticated');
                    }
                    const document = await ctx.createDoc(model.id, input.content);
                    return {
                        document
                    };
                }
            });
        }
        _class_private_field_get(this, _mutations)[`update${name}`] = mutationWithClientMutationId({
            name: `Update${name}`,
            inputFields: ()=>({
                    id: {
                        type: new GraphQLNonNull(GraphQLID)
                    },
                    content: {
                        type: new GraphQLNonNull(_class_private_field_get(this, _inputObjects)[`Partial${name}`])
                    },
                    options: {
                        type: UpdateOptionsInput
                    }
                }),
            outputFields: ()=>({
                    ...queryFields,
                    document: {
                        type: new GraphQLNonNull(_class_private_field_get(this, _types)[name])
                    }
                }),
            mutateAndGetPayload: async (input, ctx)=>{
                if (ctx.ceramic.did == null || !ctx.ceramic.did.authenticated) {
                    throw new Error('Ceramic instance is not authenticated');
                }
                return {
                    document: await ctx.updateDoc(input.id, input.content, input.options)
                };
            }
        });
    }
    _createSchema(definitions) {
        const queryFields = {
            nodes: definitions.nodesField,
            ...definitions.queryFields
        };
        for (const [alias, model] of Object.entries(_class_private_field_get(this, _def).models)){
            const first = alias[0].toLowerCase();
            const rest = alias.slice(1);
            const filtersObj = _class_private_field_get(this, _inputObjects)[`${alias}Filters`];
            const sortingObj = _class_private_field_get(this, _inputObjects)[`${alias}Sorting`];
            const args = {
                ...connectionArgs
            };
            if (filtersObj && sortingObj) {
                args.filters = {
                    type: filtersObj
                };
                args.sorting = {
                    type: sortingObj
                };
            }
            queryFields[`${first}${rest}Index`] = {
                type: _class_private_field_get(this, _types)[`${alias}Connection`],
                args: args,
                resolve: async (_, { filters, ...args }, ctx)=>{
                    if (filters != null) {
                        assertValidQueryFilters(filters);
                    }
                    return await ctx.queryConnection({
                        ...args,
                        queryFilters: filters,
                        models: [
                            model.id
                        ]
                    });
                }
            };
            queryFields[`${first}${rest}Count`] = {
                type: new GraphQLNonNull(GraphQLInt),
                args: filtersObj ? {
                    filters: {
                        type: filtersObj
                    }
                } : {},
                resolve: async (_, { filters }, ctx)=>{
                    if (filters != null) {
                        assertValidQueryFilters(filters);
                    }
                    return await ctx.queryCount({
                        queryFilters: filters,
                        models: [
                            model.id
                        ]
                    });
                }
            };
        }
        const schemaFields = {
            query: new GraphQLObjectType({
                name: 'Query',
                fields: queryFields
            })
        };
        if (!_class_private_field_get(this, _isReadonly) && Object.keys(_class_private_field_get(this, _mutations)).length !== 0) {
            schemaFields.mutation = new GraphQLObjectType({
                name: 'Mutation',
                fields: _class_private_field_get(this, _mutations)
            });
        }
        return new GraphQLSchema(schemaFields);
    }
    constructor(params){
        _class_private_field_init(this, _def, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _isReadonly, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _types, {
            writable: true,
            value: {
                SortOrder
            }
        });
        _class_private_field_init(this, _inputObjects, {
            writable: true,
            value: {
                ...valueFilterInputs
            }
        });
        _class_private_field_init(this, _mutations, {
            writable: true,
            value: {}
        });
        _class_private_field_init(this, _modelAliases, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _def, params.definition);
        _class_private_field_set(this, _isReadonly, !!params.readonly);
        _class_private_field_set(this, _modelAliases, Object.entries(_class_private_field_get(this, _def).models).reduce((aliases, [alias, model])=>{
            aliases[model.id] = alias;
            return aliases;
        }, {}));
    }
}
/**
 * Create a GraphQL schema from a runtime composite definition
 */ export function createGraphQLSchema(params) {
    return new SchemaBuilder(params).build();
}
