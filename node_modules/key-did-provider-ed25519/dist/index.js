/**
 * # ed25519 key did provider
 * This is a DID Provider which implements [EIP2844](https://eips.ethereum.org/EIPS/eip-2844) for `did:key:` using ed25519. It also supports decryption using x25519.
 *
 * ## Installation
 *
 * ```
 * npm install --save key-did-provider-ed25519
 * ```
 *
 * ## Usage
 *
 * ```js
 * import { Ed25519Provider } from 'key-did-provider-ed25519'
 * import KeyResolver from 'key-did-resolver'
 * import { DID } from 'dids'
 *
 * const seed = new Uint8Array(...) //  32 bytes with high entropy
 * const provider = new Ed25519Provider(seed)
 * const did = new DID({ provider, resolver: KeyResolver.getResolver() })
 * await did.authenticate()
 *
 * // log the DID
 * console.log(did.id)
 *
 * // create JWS
 * const { jws, linkedBlock } = await did.createDagJWS({ hello: 'world' })
 *
 * // verify JWS
 * await did.verifyJWS(jws)
 *
 * // create JWE
 * const jwe = await did.createDagJWE({ very: 'secret' }, [did.id])
 *
 * // decrypt JWE
 * const decrypted = await did.decryptDagJWE(jwe)
 * ```
 *
 * @module key-did-provider-ed25519
 */ function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { ed25519, edwardsToMontgomeryPriv } from '@noble/curves/ed25519';
import { createJWS, decryptJWE, x25519Decrypter, EdDSASigner } from 'did-jwt';
import stringify from 'fast-json-stable-stringify';
import { RPCError, createHandler } from 'rpc-utils';
import { toString, concat } from 'uint8arrays';
const B64 = 'base64pad';
function toStableObject(obj) {
    return JSON.parse(stringify(obj));
}
export function encodeDID(publicKey) {
    const bytes = new Uint8Array(publicKey.length + 2);
    bytes[0] = 0xed // ed25519 multicodec
    ;
    // The multicodec is encoded as a varint so we need to add this.
    // See js-multicodec for a general implementation
    bytes[1] = 0x01;
    bytes.set(publicKey, 2);
    return `did:key:z${toString(bytes, 'base58btc')}`;
}
function toGeneralJWS(jws) {
    const [protectedHeader, payload, signature] = jws.split('.');
    return {
        payload,
        signatures: [
            {
                protected: protectedHeader,
                signature
            }
        ]
    };
}
const sign = async (payload, did, secretKey, protectedHeader = {})=>{
    const kid = `${did}#${did.split(':')[2]}`;
    const signer = EdDSASigner(secretKey);
    const header = toStableObject(Object.assign(protectedHeader, {
        kid,
        alg: 'EdDSA'
    }));
    return createJWS(typeof payload === 'string' ? payload : toStableObject(payload), signer, header);
};
const didMethods = {
    did_authenticate: async ({ did, secretKey }, params)=>{
        const response = await sign({
            did,
            aud: params.aud,
            nonce: params.nonce,
            paths: params.paths,
            exp: Math.floor(Date.now() / 1000) + 600
        }, did, secretKey);
        return toGeneralJWS(response);
    },
    did_createJWS: async ({ did, secretKey }, params)=>{
        const requestDid = params.did.split('#')[0];
        if (requestDid !== did) throw new RPCError(4100, `Unknown DID: ${did}`);
        const jws = await sign(params.payload, did, secretKey, params.protected);
        return {
            jws: toGeneralJWS(jws)
        };
    },
    did_decryptJWE: async ({ secretKey }, params)=>{
        const x25519PrivKey = edwardsToMontgomeryPriv(secretKey.subarray(0, 32));
        const decrypter = x25519Decrypter(x25519PrivKey);
        try {
            const bytes = await decryptJWE(params.jwe, decrypter);
            return {
                cleartext: toString(bytes, B64)
            };
        } catch (e) {
            throw new RPCError(-32000, e.message);
        }
    }
};
export class Ed25519Provider {
    get isDidProvider() {
        return true;
    }
    async send(msg) {
        return await this._handle(msg);
    }
    constructor(seed){
        _define_property(this, "_handle", void 0);
        const publicKey = ed25519.getPublicKey(seed);
        const secretKey = concat([
            seed,
            ed25519.getPublicKey(seed)
        ]);
        const did = encodeDID(publicKey);
        const handler = createHandler(didMethods);
        this._handle = async (msg)=>await handler({
                did,
                secretKey
            }, msg);
    }
}
