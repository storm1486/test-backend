import { create as createMultihash, decode as decodeMultihash } from 'multiformats/hashes/digest';
import { CID } from 'multiformats/cid';
import * as uint8arrays from 'uint8arrays';
import { contractInterface } from './interface.js';
export const SHA256_CODE = 0x12;
export const KECCAK_256_CODE = 0x1b;
export const DAG_CBOR_CODE = 0x71;
export const ETH_TX_CODE = 0x93;
export function createCidFromHexValue(hexValue) {
    const multihash = createMultihash(SHA256_CODE, uint8arrays.fromString(hexValue.slice(2), 'base16'));
    return CID.create(1, DAG_CBOR_CODE, multihash);
}
export function getCidFromAnchorEventLog(log) {
    const decodedArgs = contractInterface.decodeEventLog(contractInterface.events['DidAnchor(address,bytes32)'], log.data);
    return createCidFromHexValue(decodedArgs[1]);
}
const getCidFromV0Transaction = (txResponse) => {
    const withoutPrefix = txResponse.data.replace(/^(0x0?)/, '');
    return CID.decode(uint8arrays.fromString(withoutPrefix.slice(1), 'base16'));
};
const getCidFromV1Transaction = (txResponse) => {
    const decodedArgs = contractInterface.decodeFunctionData('anchorDagCbor', txResponse.data);
    return createCidFromHexValue(decodedArgs[0]);
};
const V1_PROOF_TYPE = 'f(bytes32)';
export const getCidFromTransaction = (txType, txResponse) => {
    if (txType === V1_PROOF_TYPE) {
        return getCidFromV1Transaction(txResponse);
    }
    else {
        return getCidFromV0Transaction(txResponse);
    }
};
export function convertEthHashToCid(hexValue) {
    const multihash = createMultihash(KECCAK_256_CODE, uint8arrays.fromString(hexValue.slice(2), 'base16'));
    return CID.create(1, ETH_TX_CODE, multihash);
}
export function convertCidToEthHash(cid) {
    const decoded = decodeMultihash(cid.multihash.bytes);
    return '0x' + uint8arrays.toString(decoded.digest, 'base16');
}
//# sourceMappingURL=cid.js.map