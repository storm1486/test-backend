import { Node, PathDirection } from './merkle-elements.js';
function pathFromRoot(element, result = []) {
    const parent = element.parent;
    if (!parent) {
        return result.reverse();
    }
    return pathFromRoot(parent, result.concat(parent.left === element ? PathDirection.L : PathDirection.R));
}
function calculateProof(element, result = []) {
    const parent = element.parent;
    if (!parent) {
        return result;
    }
    const proofNode = parent.left === element ? parent.right : parent.left;
    if (!proofNode)
        throw new Error(`Empty proof node`);
    return calculateProof(parent, result.concat(proofNode));
}
export class MerkleTree {
    constructor(mergeFn, root, leafNodes, metadata) {
        this.mergeFn = mergeFn;
        this.root = root;
        this.leafNodes = leafNodes;
        this.metadata = metadata;
    }
    getProof(elemIndex) {
        const leaf = this.leafNodes[elemIndex];
        if (!leaf)
            throw new Error(`Empty leaf at index ${elemIndex}`);
        return calculateProof(leaf);
    }
    getDirectPathFromRoot(elemIndex) {
        const leaf = this.leafNodes[elemIndex];
        if (!leaf)
            throw new Error(`Empty leaf at index ${elemIndex}`);
        return pathFromRoot(leaf);
    }
    async verifyProof(proof, element) {
        let current = new Node(element, null, null);
        for (const p of proof) {
            const parent = p.parent;
            if (!parent)
                throw new Error(`No parent for node ${p}`);
            const isLeft = parent.left == p;
            const isRoot = p == proof[proof.length - 1];
            const metadata = isRoot ? this.metadata : null;
            if (isLeft) {
                current = await this.mergeFn.merge(p, current, metadata);
            }
            else {
                current = await this.mergeFn.merge(current, p, metadata);
            }
        }
        return this.root.data === current.data;
    }
}
export function pathByIndex(index, leavesCount) {
    if (index >= leavesCount) {
        throw Error(`Leaf at index ${index} does not exist as there are only ${leavesCount} leaves`);
    }
    if (leavesCount === 1) {
        return [PathDirection.L];
    }
    return pathByIndexHelper(index, leavesCount);
}
function pathByIndexHelper(index, leavesCount, path = []) {
    if (leavesCount <= 1) {
        return path;
    }
    if (leavesCount === 2) {
        index === 0 ? path.push(PathDirection.L) : path.push(PathDirection.R);
        return path;
    }
    const middleIndex = Math.trunc(leavesCount / 2);
    if (index < middleIndex) {
        path.push(PathDirection.L);
        return pathByIndexHelper(index, middleIndex, path);
    }
    else {
        path.push(PathDirection.R);
        return pathByIndexHelper(index - middleIndex, leavesCount - middleIndex, path);
    }
}
//# sourceMappingURL=merkle-tree.js.map