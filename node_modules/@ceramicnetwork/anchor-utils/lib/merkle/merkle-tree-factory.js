import { Node } from './merkle-elements.js';
import { MerkleTree } from './merkle-tree.js';
export class EmptyLeavesError extends Error {
    constructor() {
        super('Cannot generate Merkle structure with no elements');
    }
}
export class MerkleDepthError extends Error {
    constructor(depthLimit, leavesLimit) {
        super(`Merkle tree exceeded configured limit of ${depthLimit} levels (${leavesLimit} nodes)`);
    }
}
export class MerkleTreeFactory {
    constructor(mergeFn, compareFn, metadataFn, depthLimit) {
        this.mergeFn = mergeFn;
        this.compareFn = compareFn;
        this.metadataFn = metadataFn;
        this.depthLimit = depthLimit;
    }
    async build(leaves) {
        if (!leaves || !leaves.length)
            throw new EmptyLeavesError();
        if (this.depthLimit) {
            const leavesLimit = Math.pow(2, this.depthLimit);
            if (leavesLimit < leaves.length)
                throw new MerkleDepthError(this.depthLimit, leavesLimit);
        }
        const nodes = leaves.map((leaf) => new Node(leaf));
        if (this.compareFn) {
            nodes.sort(this.compareFn.compare);
        }
        const metadata = this.metadataFn ? await this.metadataFn.generateMetadata(nodes) : null;
        const root = await this.buildLevel(nodes, 0, metadata);
        return new MerkleTree(this.mergeFn, root, nodes, metadata);
    }
    async buildLevel(elements, currentDepth, metadata = null) {
        if (elements.length === 1) {
            const first = elements[0];
            if (currentDepth === 0) {
                const merged = await this.mergeFn.merge(first, null, metadata);
                first.parent = merged;
                return merged;
            }
            return first;
        }
        const middleIndex = Math.trunc(elements.length / 2);
        const leftElements = elements.slice(0, middleIndex);
        const rightElements = elements.slice(middleIndex);
        const nextDepth = currentDepth + 1;
        const leftNode = await this.buildLevel(leftElements, nextDepth);
        const rightNode = await this.buildLevel(rightElements, nextDepth);
        const merged = await this.mergeFn.merge(leftNode, rightNode, metadata);
        leftNode.parent = merged;
        rightNode.parent = merged;
        return merged;
    }
}
//# sourceMappingURL=merkle-tree-factory.js.map