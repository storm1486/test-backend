var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { CID } from 'multiformats/cid';
import { base36 } from 'multiformats/bases/base36';
import { hash as sha256 } from '@stablelib/sha256';
import varint from 'varint';
import * as cbor from 'cborg';
import * as u8a from 'uint8arrays';
import { STREAMID_CODEC } from './constants.js';
import { Memoize } from 'mapmoize';
const TAG = Symbol.for('@ceramicnetwork/streamid/EventID');
const EVENT_ID_CODEC = 0x05;
const STREAMID_CODEC_LEN = 2;
const EVENT_ID_CODEC_LEN = 1;
const NETWORK = {
    mainnet: 0x00,
    'testnet-clay': 0x01,
    'dev-unstable': 0x02,
    inmemory: 0xff,
};
function networkByName(net) {
    const netId = NETWORK[net];
    if (!netId && netId !== 0)
        throw new Error('Not a valid network name');
    return netId;
}
export class EventID {
    constructor(networkID, separator, controller, init, eventHeight, event) {
        this._tag = TAG;
        this._networkID = networkID;
        this._separator = separator;
        this._controller = controller;
        this._init = init;
        this._eventHeight = eventHeight;
        this._event = event;
    }
    static isInstance(instance) {
        return typeof instance === 'object' && '_tag' in instance && instance._tag === TAG;
    }
    static create(networkID, separator, controller, init, eventHeight, event) {
        const networkIDInt = typeof networkID === 'string' ? networkByName(networkID) : networkID;
        const separatorAllBytes = typeof separator === 'string' ? u8a.fromString(separator) : separator;
        const separatorBytes = sha256(separatorAllBytes).slice(-8);
        const controllerBytes = sha256(u8a.fromString(controller)).slice(-8);
        const initCid = typeof init === 'string' ? CID.parse(init) : init;
        const initBytes = initCid.bytes.slice(-4);
        const eventCid = typeof event === 'string' ? CID.parse(event) : event;
        return new EventID(networkIDInt, separatorBytes, controllerBytes, initBytes, eventHeight, eventCid);
    }
    get bytes() {
        const streamCodec = new Uint8Array(varint.encode(STREAMID_CODEC));
        const eventIDCodec = new Uint8Array(varint.encode(EVENT_ID_CODEC));
        const networkID = new Uint8Array(varint.encode(this._networkID));
        const eventHeight = cbor.encode(this._eventHeight);
        const event = this._event.bytes;
        return u8a.concat([
            streamCodec,
            eventIDCodec,
            networkID,
            this._separator,
            this._controller,
            this._init,
            eventHeight,
            event,
        ]);
    }
    static fromBytes(bytes) {
        try {
            const netOffset = STREAMID_CODEC_LEN + EVENT_ID_CODEC_LEN;
            const networkID = varint.decode(bytes, netOffset);
            const sepOffset = varint.decode.bytes + netOffset;
            const conOffset = sepOffset + 8;
            const seperator = bytes.slice(sepOffset, conOffset);
            const initOffest = conOffset + 8;
            const controller = bytes.slice(conOffset, initOffest);
            const ehOffset = initOffest + 4;
            const init = bytes.slice(initOffest, ehOffset);
            const remaining = bytes.slice(ehOffset);
            const eventHeight = cbor.decode(bytes.slice(ehOffset, ehOffset + remaining.length - 36));
            const event = CID.decode(remaining.slice(remaining.length - 36));
            return new EventID(networkID, seperator, controller, init, eventHeight, event);
        }
        catch (e) {
            throw new Error(`Invalid EventID: ${e.message}`);
        }
    }
    static fromString(str) {
        const bytes = base36.decode(str);
        return this.fromBytes(bytes);
    }
    toString() {
        return base36.encode(this.bytes);
    }
    equals(other) {
        if (EventID.isInstance(other)) {
            return (this._networkID === other._networkID &&
                u8a.equals(this._separator, other._separator) &&
                u8a.equals(this._controller, other._controller) &&
                u8a.equals(this._init, other._init) &&
                this._eventHeight === other._eventHeight &&
                this._event.equals(other._event));
        }
        else {
            return false;
        }
    }
    toUrl() {
        return `ceramic://${this.toString()}`;
    }
    get networkID() {
        return this._networkID;
    }
    get separator() {
        return this._separator;
    }
    get controller() {
        return this._controller;
    }
    get init() {
        return this._controller;
    }
    get eventHeight() {
        return this._eventHeight;
    }
    get event() {
        return this._event;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `EventID(${this.toString()})`;
    }
    [Symbol.toPrimitive]() {
        return this.toString();
    }
}
__decorate([
    Memoize(),
    __metadata("design:type", Uint8Array),
    __metadata("design:paramtypes", [])
], EventID.prototype, "bytes", null);
__decorate([
    Memoize(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], EventID.prototype, "toString", null);
__decorate([
    Memoize(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], EventID.prototype, "toUrl", null);
//# sourceMappingURL=event-id.js.map