import { filter, fromEvent, map, pipe, scan, } from 'rxjs';
import { mapLoadBlockForBlockProofs, mapLoadBlockProofsForRange, } from './loader.js';
export function createContinuousBlocksListener(provider, confirmations = 0) {
    return fromEvent(provider, 'block').pipe(map((blockNumber) => blockNumber - confirmations), scan((state, blockNumber) => {
        if (state.highest == null) {
            return { load: [blockNumber], highest: blockNumber };
        }
        if (blockNumber <= state.highest) {
            return { ...state, load: [] };
        }
        const lastLoadedNumber = state.highest;
        return {
            load: new Array(blockNumber - lastLoadedNumber).fill(0).map((_, i) => {
                return lastLoadedNumber + 1 + i;
            }),
            highest: blockNumber,
        };
    }, { load: [] }), map((state) => state.load), filter((blocks) => blocks.length !== 0));
}
export function mapProcessBlockProofs(expectedParentHash) {
    return pipe(scan((state, data) => {
        if (state.status === 'initial') {
            return expectedParentHash == null || data.block.parentHash === expectedParentHash
                ? { ...data, status: 'process', previousHash: data.block.hash }
                : { ...data, status: 'reorganized', previousHash: expectedParentHash };
        }
        return data.block.parentHash === state.block.hash
            ? { ...data, status: 'process', previousHash: data.block.hash }
            : { ...data, status: 'reorganized', previousHash: state.previousHash };
    }, { status: 'initial' }), map(({ status, block, proofs, previousHash }) => {
        return status === 'process'
            ? { reorganized: false, block, proofs }
            : { reorganized: true, block, proofs, expectedParentHash: previousHash };
    }));
}
export function createBlockProofsListener({ chainId, confirmations, expectedParentHash, provider, retryConfig, }) {
    return createContinuousBlocksListener(provider, confirmations).pipe(map((blockNumbers) => ({
        fromBlock: blockNumbers[0],
        toBlock: blockNumbers[blockNumbers.length - 1],
    })), mapLoadBlockProofsForRange(provider, chainId, retryConfig), mapLoadBlockForBlockProofs(provider, retryConfig), mapProcessBlockProofs(expectedParentHash));
}
//# sourceMappingURL=listener.js.map