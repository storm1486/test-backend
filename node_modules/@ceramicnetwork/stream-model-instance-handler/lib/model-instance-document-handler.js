import jsonpatch from 'fast-json-patch';
import { ModelInstanceDocument, validateContentLength, } from '@ceramicnetwork/stream-model-instance';
import { AnchorStatus, CommitType, SignatureStatus, SignatureUtils, StreamUtils, } from '@ceramicnetwork/common';
import { StreamID } from '@ceramicnetwork/streamid';
import { SchemaValidation } from './schema-utils.js';
import { Model } from '@ceramicnetwork/stream-model';
import { applyAnchorCommit } from '@ceramicnetwork/stream-handler-common';
const MODEL_STREAM_TYPE_ID = 2;
export class ModelInstanceDocumentHandler {
    constructor() {
        this._schemaValidator = new SchemaValidation();
    }
    get type() {
        return ModelInstanceDocument.STREAM_TYPE_ID;
    }
    get name() {
        return ModelInstanceDocument.STREAM_TYPE_NAME;
    }
    get stream_constructor() {
        return ModelInstanceDocument;
    }
    async applyCommit(commitData, context, state) {
        if (state == null) {
            return this._applyGenesis(commitData, context);
        }
        if (StreamUtils.isAnchorCommitData(commitData)) {
            return this._applyAnchor(commitData, state);
        }
        return this._applySigned(commitData, state, context);
    }
    async _applyGenesis(commitData, context) {
        const payload = commitData.commit;
        const { controllers, model } = payload.header;
        const controller = controllers[0];
        const modelStreamID = StreamID.fromBytes(model);
        const streamId = new StreamID(ModelInstanceDocument.STREAM_TYPE_ID, commitData.cid);
        const metadata = { controllers: [controller], model: modelStreamID };
        if (!(payload.header.controllers && payload.header.controllers.length === 1)) {
            throw new Error('Exactly one controller must be specified');
        }
        if (!StreamUtils.validDIDString(payload.header.controllers[0])) {
            throw new Error(`Attempting to create a ModelInstanceDocument with an invalid DID string: ${payload.header.controllers[0]}`);
        }
        if (modelStreamID.type != MODEL_STREAM_TYPE_ID) {
            throw new Error(`Model for ModelInstanceDocument must refer to a StreamID of a Model stream`);
        }
        const isSigned = StreamUtils.isSignedCommitData(commitData);
        if (isSigned) {
            await SignatureUtils.verifyCommitSignature(commitData, context.did, controller, modelStreamID, streamId);
        }
        else if (payload.data || payload.header.unique) {
            throw Error('ModelInstanceDocument genesis commit with content must be signed');
        }
        const modelStream = await context.api.loadStream(metadata.model);
        this._validateModel(modelStream);
        await this._validateContent(context.api, modelStream, payload.data, true);
        await this._validateHeader(modelStream, payload.header);
        return {
            type: ModelInstanceDocument.STREAM_TYPE_ID,
            content: payload.data || {},
            metadata,
            signature: SignatureStatus.SIGNED,
            anchorStatus: AnchorStatus.NOT_REQUESTED,
            log: [StreamUtils.commitDataToLogEntry(commitData, CommitType.GENESIS)],
        };
    }
    async _applySigned(commitData, state, context) {
        const payload = commitData.commit;
        StreamUtils.assertCommitLinksToState(state, payload);
        const metadata = state.metadata;
        const controller = metadata.controllers[0];
        const model = metadata.model;
        const streamId = StreamUtils.streamIdFromState(state);
        await SignatureUtils.verifyCommitSignature(commitData, context.did, controller, model, streamId);
        if (payload.header) {
            throw new Error(`Updating metadata for ModelInstanceDocument Streams is not allowed.  Tried to change metadata for Stream ${streamId} from ${JSON.stringify(state.metadata)} to ${JSON.stringify(payload.header)}\``);
        }
        const oldContent = state.content;
        const newContent = jsonpatch.applyPatch(oldContent, payload.data).newDocument;
        const modelStream = await context.api.loadStream(metadata.model);
        await this._validateContent(context.api, modelStream, newContent, false);
        state.signature = SignatureStatus.SIGNED;
        state.anchorStatus = AnchorStatus.NOT_REQUESTED;
        state.content = newContent;
        state.log.push(StreamUtils.commitDataToLogEntry(commitData, CommitType.SIGNED));
        return state;
    }
    async _applyAnchor(commitData, state) {
        return applyAnchorCommit(commitData, state);
    }
    _validateModel(model) {
        if (model.content.version !== '1.0' && model.content.interface) {
            throw new Error(`ModelInstanceDocument Streams cannot be created on interface Models. Use a different model than ${model.id.toString()} to create the ModelInstanceDocument.`);
        }
    }
    async _validateContent(ceramic, model, content, genesis) {
        if (genesis && model.content.accountRelation.type === 'single') {
            if (content) {
                throw new Error(`Deterministic genesis commits for ModelInstanceDocuments must not have content`);
            }
            return;
        }
        validateContentLength(content);
        await this._schemaValidator.validateSchema(content, model.content.schema, model.commitId.toString());
        await this._validateRelationsContent(ceramic, model, content);
    }
    async _validateRelationsContent(ceramic, model, content) {
        if (!model.content.relations) {
            return;
        }
        for (const [fieldName, relationDefinition] of Object.entries(model.content.relations)) {
            switch (relationDefinition.type) {
                case 'account':
                    continue;
                case 'document': {
                    if (content[fieldName] == null) {
                        continue;
                    }
                    let midStreamId;
                    try {
                        midStreamId = StreamID.fromString(content[fieldName]);
                    }
                    catch (err) {
                        throw new Error(`Error while parsing relation from field ${fieldName}: Invalid StreamID: ${err.toString()}`);
                    }
                    const linkedMid = await ModelInstanceDocument.load(ceramic, midStreamId);
                    const expectedModelStreamId = relationDefinition.model;
                    if (expectedModelStreamId == null) {
                        continue;
                    }
                    const foundModelStreamId = linkedMid.metadata.model.toString();
                    if (foundModelStreamId === expectedModelStreamId) {
                        continue;
                    }
                    const linkedModel = await Model.load(ceramic, foundModelStreamId);
                    if (linkedModel.content.version !== '1.0' &&
                        linkedModel.content.implements.includes(expectedModelStreamId)) {
                        continue;
                    }
                    throw new Error(`Relation on field ${fieldName} points to Stream ${midStreamId.toString()}, which belongs to Model ${foundModelStreamId}, but this Stream's Model (${model.id.toString()}) specifies that this relation must be to a Stream in the Model ${expectedModelStreamId}`);
                }
            }
        }
    }
    async _validateHeader(model, header) {
        if (model.content.accountRelation.type === 'single') {
            if (header.unique) {
                throw new Error(`ModelInstanceDocuments for models with SINGLE accountRelations must be created deterministically`);
            }
        }
        else {
            if (!header.unique) {
                throw new Error(`Deterministic ModelInstanceDocuments are only allowed on models that have the SINGLE accountRelation`);
            }
        }
    }
}
//# sourceMappingURL=model-instance-document-handler.js.map