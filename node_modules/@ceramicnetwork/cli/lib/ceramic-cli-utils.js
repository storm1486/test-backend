import os from 'os';
import pc from 'picocolors';
import { randomBytes } from '@stablelib/random';
import * as u8a from 'uint8arrays';
import * as fs from 'fs/promises';
import { Ed25519Provider } from 'key-did-provider-ed25519';
import { CeramicClient } from '@ceramicnetwork/http-client';
import { AnchorServiceAuthMethods, LogLevel, Networks, StreamUtils, } from '@ceramicnetwork/common';
import { StreamID, CommitID } from '@ceramicnetwork/streamid';
import { CeramicDaemon } from './ceramic-daemon.js';
import { DaemonConfig, IpfsMode, StateStoreMode, validateConfig } from './daemon-config.js';
import { TileDocument } from '@ceramicnetwork/stream-tile';
import * as ThreeIdResolver from '@ceramicnetwork/3id-did-resolver';
import * as KeyDidResolver from 'key-did-resolver';
import { Resolver } from 'did-resolver';
import { DID } from 'dids';
import { handleHeapdumpSignal } from './daemon/handle-heapdump-signal.js';
import { handleSigintSignal } from './daemon/handle-sigint-signal.js';
import { generateSeedUrl } from './daemon/did-utils.js';
import { TypedJSON } from 'typedjson';
import { getDefaultCDBDatabaseConfig } from '@ceramicnetwork/indexing';
const HOMEDIR = new URL(`file://${os.homedir()}/`);
const CWD = new URL(`file://${process.cwd()}/`);
const DEFAULT_CONFIG_PATH = new URL('.ceramic/', HOMEDIR);
const DEFAULT_STATE_STORE_DIRECTORY = new URL('statestore/', DEFAULT_CONFIG_PATH);
const DEFAULT_DAEMON_CONFIG_FILENAME = new URL('daemon.config.json', DEFAULT_CONFIG_PATH);
const DEFAULT_CLI_CONFIG_FILENAME = new URL('client.config.json', DEFAULT_CONFIG_PATH);
const DEFAULT_INDEXING_DB_FILENAME = new URL('./indexing.sqlite', DEFAULT_CONFIG_PATH);
const generateDefaultDaemonConfig = () => {
    const privateSeedUrl = generateSeedUrl();
    const defaultIndexingConfig = getDefaultCDBDatabaseConfig(Networks.TESTNET_CLAY);
    return DaemonConfig.fromObject({
        anchor: {
            'auth-method': AnchorServiceAuthMethods.DID,
        },
        'http-api': { 'cors-allowed-origins': [new RegExp('.*')], 'admin-dids': [] },
        ipfs: { mode: IpfsMode.BUNDLED },
        logger: { 'log-level': LogLevel.important, 'log-to-files': false },
        metrics: {
            'metrics-exporter-enabled': false,
        },
        network: { name: Networks.TESTNET_CLAY },
        node: {
            'private-seed-url': privateSeedUrl.toString(),
        },
        'state-store': {
            mode: StateStoreMode.FS,
            'local-directory': DEFAULT_STATE_STORE_DIRECTORY.pathname,
        },
        indexing: {
            db: `sqlite://${DEFAULT_INDEXING_DB_FILENAME.pathname}`,
            'disable-composedb': false,
            'enable-historical-sync': defaultIndexingConfig.run_historical_sync_worker,
            'allow-queries-before-historical-sync': defaultIndexingConfig.allow_queries_before_historical_sync,
        },
    });
};
export class CeramicCliUtils {
    static async createDaemon(configFilename, ipfsApi, ethereumRpc, anchorServiceApi, ipfsPinningEndpoints, stateStoreDirectory, stateStoreS3Bucket, port, hostname, debug, verbose, logToFiles, logDirectory, metricsExporterEnabled, collectorHost, network, pubsubTopic, corsAllowedOrigins, syncOverride, disableComposedb, readOnly) {
        const configFilepath = configFilename
            ? new URL(configFilename, CWD)
            : DEFAULT_DAEMON_CONFIG_FILENAME;
        const config = await this._loadDaemonConfig(configFilepath);
        if (process.env.CERAMIC_INDEXING_DB_URI)
            config.indexing.db = process.env.CERAMIC_INDEXING_DB_URI;
        if (process.env.CERAMIC_METRICS_EXPORTER_ENABLED)
            config.metrics.metricsExporterEnabled = process.env.CERAMIC_METRICS_EXPORTER_ENABLED == 'true';
        if (process.env.COLLECTOR_HOSTNAME)
            config.metrics.collectorHost = process.env.COLLECTOR_HOSTNAME;
        if (process.env.CERAMIC_NODE_PRIVATE_SEED_URL)
            config.node.privateSeedUrl = process.env.CERAMIC_NODE_PRIVATE_SEED_URL;
        if (process.env.CERAMIC_DISABLE_IPFS_PEER_DATA_SYNC == 'true')
            config.ipfs.disablePeerDataSync = true;
        validateConfig(config);
        {
            if (stateStoreDirectory && stateStoreS3Bucket) {
                throw new Error('Cannot specify both --state-store-directory and --state-store-s3-bucket. Only one state store - either on local storage or on S3 - can be used at a time');
            }
            if (anchorServiceApi) {
                config.anchor.anchorServiceUrl = anchorServiceApi;
            }
            if (ethereumRpc) {
                config.anchor.ethereumRpcUrl = ethereumRpc;
            }
            if (corsAllowedOrigins) {
                config.httpApi.corsAllowedOrigins = corsAllowedOrigins
                    .split(' ')
                    .map((origin) => new RegExp(origin));
            }
            if (hostname) {
                config.httpApi.hostname = hostname;
            }
            if (port) {
                config.httpApi.port = port;
            }
            if (ipfsApi) {
                config.ipfs.mode = IpfsMode.REMOTE;
                config.ipfs.host = ipfsApi;
            }
            if (ipfsPinningEndpoints) {
                config.ipfs.pinningEndpoints = ipfsPinningEndpoints;
            }
            if (verbose || debug) {
                const logLevel = verbose ? LogLevel.verbose : debug ? LogLevel.debug : LogLevel.important;
                config.logger.logLevel = logLevel;
            }
            if (logDirectory) {
                config.logger.logDirectory = logDirectory;
            }
            if (logToFiles) {
                config.logger.logToFiles = logToFiles;
            }
            if (metricsExporterEnabled) {
                config.metrics.metricsExporterEnabled = metricsExporterEnabled;
            }
            if (network) {
                config.network.name = network;
            }
            if (pubsubTopic) {
                config.network.pubsubTopic = pubsubTopic;
            }
            if (readOnly) {
                config.node.readOnly = readOnly;
            }
            if (syncOverride) {
                config.node.syncOverride = syncOverride;
            }
            if (disableComposedb) {
                config.indexing.disableComposedb = true;
            }
            if (process.env.CERAMIC_DISABLE_COMPOSE_DB === 'true') {
                config.indexing.disableComposedb = true;
            }
            if (stateStoreDirectory) {
                config.stateStore.mode = StateStoreMode.FS;
                config.stateStore.localDirectory = stateStoreDirectory;
            }
            if (stateStoreS3Bucket) {
                config.stateStore.mode = StateStoreMode.S3;
                config.stateStore.s3Bucket = stateStoreS3Bucket;
            }
        }
        const daemon = await CeramicDaemon.create(config);
        handleHeapdumpSignal(new URL('./', configFilepath), daemon.diagnosticsLogger);
        handleSigintSignal(daemon);
        return daemon;
    }
    static async _createDoc(content, controllers, onlyGenesis, deterministic, schemaStreamId = null) {
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const parsedControllers = CeramicCliUtils._parseControllers(controllers);
            const parsedContent = CeramicCliUtils._parseContent(content);
            const metadata = { controllers: parsedControllers, schema: schemaStreamId, deterministic };
            const doc = await TileDocument.create(ceramic, parsedContent, metadata, {
                anchor: !onlyGenesis,
                publish: !onlyGenesis,
            });
            console.log(doc.id);
            console.log(JSON.stringify(doc.content, null, 2));
            deprecationNotice();
        });
    }
    static async update(streamId, content, controllers, schemaCommitId) {
        const id = StreamID.fromString(streamId);
        if (id.type != TileDocument.STREAM_TYPE_ID) {
            throw new Error(`CLI does not currently support updating stream types other than 'tile'. StreamID ${id.toString()} has streamtype '${id.typeName}'`);
        }
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const parsedControllers = CeramicCliUtils._parseControllers(controllers);
            const parsedContent = CeramicCliUtils._parseContent(content);
            const doc = await TileDocument.load(ceramic, id);
            const metadata = { controllers: parsedControllers };
            if (schemaCommitId) {
                const schemaId = CommitID.fromString(schemaCommitId);
                metadata.schema = schemaId;
            }
            await doc.update(parsedContent, metadata);
            console.log(JSON.stringify(doc.content, null, 2));
            deprecationNotice();
        });
    }
    static async show(streamRef) {
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const stream = await TileDocument.load(ceramic, streamRef);
            console.log(JSON.stringify(stream.content, null, 2));
        });
    }
    static async state(streamRef) {
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const stream = await ceramic.loadStream(streamRef);
            console.log(JSON.stringify(StreamUtils.serializeState(stream.state), null, 2));
        });
    }
    static async watch(streamId) {
        const id = StreamID.fromString(streamId);
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const doc = await TileDocument.load(ceramic, id);
            console.log(JSON.stringify(doc.content, null, 2));
            deprecationNotice();
            doc.subscribe(() => {
                console.log('--- document changed ---');
                console.log(JSON.stringify(doc.content, null, 2));
            });
        });
    }
    static async commits(streamId) {
        const id = StreamID.fromString(streamId);
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            const stream = await ceramic.loadStream(id);
            const commits = stream.allCommitIds.map((v) => v.toString());
            console.log(JSON.stringify(commits, null, 2));
        });
    }
    static async nonSchemaCreateDoc(content, controllers, onlyGenesis, deterministic, schemaStreamId = null) {
        return CeramicCliUtils._createDoc(content, controllers, onlyGenesis, deterministic, schemaStreamId);
    }
    static async schemaCreateDoc(content, controllers, onlyGenesis, deterministic) {
        return CeramicCliUtils._createDoc(content, controllers, onlyGenesis, deterministic);
    }
    static async schemaUpdateDoc(schemaStreamId, content, controllers) {
        StreamID.fromString(schemaStreamId);
        return CeramicCliUtils.update(schemaStreamId, content, controllers, null);
    }
    static async pinAdd(streamId, privateKey) {
        const id = StreamID.fromString(streamId);
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            if (privateKey) {
                await CeramicCliUtils._authenticateClient(ceramic, privateKey);
            }
            else {
                await ceramic.did.authenticate();
            }
            const result = await ceramic.admin.pin.add(id);
            console.log(JSON.stringify(result, null, 2));
        });
    }
    static async pinRm(streamId, privateKey) {
        const id = StreamID.fromString(streamId);
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            if (privateKey) {
                await CeramicCliUtils._authenticateClient(ceramic, privateKey);
            }
            else {
                await ceramic.did.authenticate();
            }
            const result = await ceramic.admin.pin.rm(id);
            console.log(JSON.stringify(result, null, 2));
        });
    }
    static async pinLs(streamId, privateKey) {
        const id = streamId ? StreamID.fromString(streamId) : null;
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            if (privateKey) {
                await CeramicCliUtils._authenticateClient(ceramic, privateKey);
            }
            else {
                await ceramic.did.authenticate();
            }
            const pinnedStreamIds = [];
            const iterator = await ceramic.admin.pin.ls(id);
            let i = 0;
            let truncated = false;
            for await (const id of iterator) {
                pinnedStreamIds.push(id);
                i++;
                if (i > 20) {
                    truncated = true;
                    break;
                }
            }
            if (truncated) {
                console.log('Too many results to show them all, printing the first 20:');
            }
            console.log(JSON.stringify(pinnedStreamIds, null, 2));
            if (truncated) {
                console.log('... Additional results were not shown');
            }
        });
    }
    static async status() {
        await CeramicCliUtils._runWithCeramicClient(async (ceramic) => {
            console.log(JSON.stringify(await ceramic.admin.nodeStatus()));
        });
    }
    static _makeDID(seed, ceramic) {
        const provider = new Ed25519Provider(seed);
        const keyDidResolver = KeyDidResolver.getResolver();
        const threeIdResolver = ThreeIdResolver.getResolver(ceramic);
        const resolver = new Resolver({
            ...threeIdResolver,
            ...keyDidResolver,
        });
        return new DID({ provider, resolver });
    }
    static async _authenticateClient(ceramic, privateKey) {
        const pk = u8a.fromString(privateKey, 'base16');
        const did = CeramicCliUtils._makeDID(pk, ceramic);
        await did.authenticate();
        await ceramic.setDID(did);
    }
    static async _runWithCeramicClient(fn) {
        const cliConfig = await CeramicCliUtils._loadCliConfig();
        if (!cliConfig.seed) {
            cliConfig.seed = u8a.toString(randomBytes(32), 'base16');
            console.log('Identity wallet seed generated');
            await CeramicCliUtils._saveConfig(cliConfig, DEFAULT_CLI_CONFIG_FILENAME);
        }
        let ceramic;
        const { ceramicHost } = cliConfig;
        if (ceramicHost !== undefined) {
            ceramic = new CeramicClient(ceramicHost);
        }
        else {
            ceramic = new CeramicClient();
        }
        const seed = u8a.fromString(cliConfig.seed, 'base16');
        const did = CeramicCliUtils._makeDID(seed, ceramic);
        await did.authenticate();
        await ceramic.setDID(did);
        try {
            await fn(ceramic);
        }
        catch (e) {
            console.error(e.message);
            process.exit(-1);
        }
        finally {
            ceramic.close();
        }
    }
    static async showCliConfig() {
        const cliConfig = await this._loadCliConfig();
        console.log(JSON.stringify(cliConfig, null, 2));
        deprecationNotice();
    }
    static async setCliConfig(variable, value) {
        let cliConfig = await this._loadCliConfig();
        if (cliConfig == null) {
            cliConfig = {};
        }
        Object.assign(cliConfig, {
            [variable]: value,
        });
        await this._saveConfig(cliConfig, DEFAULT_CLI_CONFIG_FILENAME);
        console.log(`Ceramic CLI configuration ${variable} set to ${value}`);
        console.log(JSON.stringify(cliConfig));
        deprecationNotice();
    }
    static async unsetCliConfig(variable) {
        const cliConfig = await this._loadCliConfig();
        delete cliConfig[variable];
        await this._saveConfig(cliConfig, DEFAULT_CLI_CONFIG_FILENAME);
        console.log(`Ceramic CLI configuration ${variable} unset`);
        console.log(JSON.stringify(cliConfig, null, 2));
        deprecationNotice();
    }
    static async _loadCliConfig() {
        const configFileContents = await CeramicCliUtils._loadCliConfigFileContents();
        if (configFileContents == '') {
            await this._saveConfig({}, DEFAULT_CLI_CONFIG_FILENAME);
            return {};
        }
        return JSON.parse(configFileContents);
    }
    static async _loadCliConfigFileContents() {
        try {
            await fs.access(DEFAULT_CLI_CONFIG_FILENAME);
            return await fs.readFile(DEFAULT_CLI_CONFIG_FILENAME, { encoding: 'utf8' });
        }
        catch (e) {
        }
        return '';
    }
    static async _loadDaemonConfig(filepath) {
        try {
            await fs.access(filepath);
        }
        catch (err) {
            const defaultConfig = generateDefaultDaemonConfig();
            const plainConfig = TypedJSON.toPlainJson(defaultConfig, DaemonConfig);
            plainConfig.node.privateSeedUrl = defaultConfig.node.sensitive_privateSeedUrl();
            await this._saveConfig(plainConfig, filepath);
            return defaultConfig;
        }
        return DaemonConfig.fromFile(filepath);
    }
    static async _saveConfig(config, filename) {
        const parentFolder = new URL('./', filename);
        await fs.mkdir(parentFolder, { recursive: true });
        await fs.writeFile(filename, JSON.stringify(config, null, 2));
    }
    static _parseContent(content) {
        return content == null ? null : JSON.parse(content);
    }
    static _parseControllers(controllers) {
        if (controllers == null) {
            return undefined;
        }
        return controllers.includes(',') ? controllers.split(',') : [controllers];
    }
}
const deprecationNotice = () => {
    console.log(`${pc.red(pc.bold('This command has been deprecated.'))} It will be removed in a future version of the CLI.`);
};
//# sourceMappingURL=ceramic-cli-utils.js.map