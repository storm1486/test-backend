var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var DaemonConfig_1;
import 'reflect-metadata';
import { jsonObject, jsonMember, jsonArrayMember, TypedJSON, toJson, AnyT } from 'typedjson';
import { readFile } from 'node:fs/promises';
import { homedir } from 'os';
import { AnchorServiceAuthMethods } from '@ceramicnetwork/common';
import { StartupError } from './daemon/error-handler.js';
function expandHomedir(input) {
    return input.replace(/^~\+(?=$|\/|\\)/, process.cwd()).replace(/^~(?=$|\/|\\)/, homedir());
}
function expandSinglePath(input, configFilepath) {
    return new URL(expandHomedir(input), configFilepath).pathname;
}
function expandPaths(config, configFilepath) {
    if (config.logger?.logDirectory) {
        config.logger.logDirectory = expandSinglePath(config.logger.logDirectory, configFilepath);
    }
    if (config.stateStore?.localDirectory) {
        config.stateStore.localDirectory = expandSinglePath(config.stateStore.localDirectory, configFilepath);
    }
}
export var IpfsMode;
(function (IpfsMode) {
    IpfsMode["BUNDLED"] = "bundled";
    IpfsMode["REMOTE"] = "remote";
})(IpfsMode || (IpfsMode = {}));
let DaemonIpfsConfig = class DaemonIpfsConfig {
    constructor() {
        this.disablePeerDataSync = false;
    }
};
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], DaemonIpfsConfig.prototype, "mode", void 0);
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], DaemonIpfsConfig.prototype, "host", void 0);
__decorate([
    jsonArrayMember(String, { name: 'pinning-endpoints' }),
    __metadata("design:type", Array)
], DaemonIpfsConfig.prototype, "pinningEndpoints", void 0);
__decorate([
    jsonMember(Boolean, { name: 'disable-peer-data-sync' }),
    __metadata("design:type", Boolean)
], DaemonIpfsConfig.prototype, "disablePeerDataSync", void 0);
DaemonIpfsConfig = __decorate([
    jsonObject,
    toJson
], DaemonIpfsConfig);
export { DaemonIpfsConfig };
export var StateStoreMode;
(function (StateStoreMode) {
    StateStoreMode["S3"] = "s3";
    StateStoreMode["FS"] = "fs";
})(StateStoreMode || (StateStoreMode = {}));
let DaemonStateStoreConfig = class DaemonStateStoreConfig {
};
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], DaemonStateStoreConfig.prototype, "mode", void 0);
__decorate([
    jsonMember(String, { name: 'local-directory' }),
    __metadata("design:type", String)
], DaemonStateStoreConfig.prototype, "localDirectory", void 0);
__decorate([
    jsonMember(String, { name: 's3-bucket' }),
    __metadata("design:type", String)
], DaemonStateStoreConfig.prototype, "s3Bucket", void 0);
__decorate([
    jsonMember(String, { name: 's3-endpoint' }),
    __metadata("design:type", String)
], DaemonStateStoreConfig.prototype, "s3Endpoint", void 0);
DaemonStateStoreConfig = __decorate([
    jsonObject,
    toJson
], DaemonStateStoreConfig);
export { DaemonStateStoreConfig };
let DaemonHTTPApiConfig = class DaemonHTTPApiConfig {
};
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], DaemonHTTPApiConfig.prototype, "hostname", void 0);
__decorate([
    jsonMember(AnyT),
    __metadata("design:type", Number)
], DaemonHTTPApiConfig.prototype, "port", void 0);
__decorate([
    jsonArrayMember(RegExp, {
        name: 'cors-allowed-origins',
        deserializer: (arr) => {
            if (!arr) {
                return arr;
            }
            return arr.map((value) => new RegExp(value));
        },
        serializer: (arr) => {
            if (!arr) {
                return arr;
            }
            return arr.map((value) => value.source);
        },
    }),
    __metadata("design:type", Array)
], DaemonHTTPApiConfig.prototype, "corsAllowedOrigins", void 0);
__decorate([
    jsonArrayMember(String, { name: 'admin-dids' }),
    __metadata("design:type", Array)
], DaemonHTTPApiConfig.prototype, "adminDids", void 0);
DaemonHTTPApiConfig = __decorate([
    jsonObject,
    toJson
], DaemonHTTPApiConfig);
export { DaemonHTTPApiConfig };
let DaemonCeramicNetworkConfig = class DaemonCeramicNetworkConfig {
};
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], DaemonCeramicNetworkConfig.prototype, "name", void 0);
__decorate([
    jsonMember(String, { name: 'pubsub-topic' }),
    __metadata("design:type", String)
], DaemonCeramicNetworkConfig.prototype, "pubsubTopic", void 0);
DaemonCeramicNetworkConfig = __decorate([
    jsonObject,
    toJson
], DaemonCeramicNetworkConfig);
export { DaemonCeramicNetworkConfig };
let DaemonAnchorConfig = class DaemonAnchorConfig {
};
__decorate([
    jsonMember(String, { name: 'anchor-service-url' }),
    __metadata("design:type", String)
], DaemonAnchorConfig.prototype, "anchorServiceUrl", void 0);
__decorate([
    jsonMember(String, { name: 'auth-method' }),
    __metadata("design:type", String)
], DaemonAnchorConfig.prototype, "authMethod", void 0);
__decorate([
    jsonMember(String, { name: 'ethereum-rpc-url' }),
    __metadata("design:type", String)
], DaemonAnchorConfig.prototype, "ethereumRpcUrl", void 0);
DaemonAnchorConfig = __decorate([
    jsonObject,
    toJson
], DaemonAnchorConfig);
export { DaemonAnchorConfig };
let IndexingConfig = class IndexingConfig {
    constructor() {
        this.allowQueriesBeforeHistoricalSync = false;
        this.disableComposedb = false;
        this.enableHistoricalSync = false;
    }
};
__decorate([
    jsonMember(String),
    __metadata("design:type", String)
], IndexingConfig.prototype, "db", void 0);
__decorate([
    jsonMember(Boolean, {
        name: 'allow-queries-before-historical-sync',
    }),
    __metadata("design:type", Object)
], IndexingConfig.prototype, "allowQueriesBeforeHistoricalSync", void 0);
__decorate([
    jsonMember(Boolean, {
        name: 'disable-composedb',
    }),
    __metadata("design:type", Object)
], IndexingConfig.prototype, "disableComposedb", void 0);
__decorate([
    jsonMember(Boolean, {
        name: 'enable-historical-sync',
    }),
    __metadata("design:type", Object)
], IndexingConfig.prototype, "enableHistoricalSync", void 0);
IndexingConfig = __decorate([
    jsonObject,
    toJson
], IndexingConfig);
export { IndexingConfig };
let DaemonCeramicNodeConfig = class DaemonCeramicNodeConfig {
    get privateSeedUrl() {
        return undefined;
    }
    set privateSeedUrl(value) {
        this._privateSeedUrl = value;
    }
    sensitive_privateSeedUrl() {
        return this._privateSeedUrl;
    }
};
__decorate([
    jsonMember(String, { name: 'private-seed-url' }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], DaemonCeramicNodeConfig.prototype, "privateSeedUrl", null);
__decorate([
    jsonMember(Boolean),
    __metadata("design:type", Boolean)
], DaemonCeramicNodeConfig.prototype, "readOnly", void 0);
__decorate([
    jsonMember(String, { name: 'sync-override' }),
    __metadata("design:type", String)
], DaemonCeramicNodeConfig.prototype, "syncOverride", void 0);
__decorate([
    jsonMember(Boolean, { name: 'disable-composedb' }),
    __metadata("design:type", Boolean)
], DaemonCeramicNodeConfig.prototype, "disableComposedb", void 0);
__decorate([
    jsonMember(Number, { name: 'stream-cache-limit' }),
    __metadata("design:type", Number)
], DaemonCeramicNodeConfig.prototype, "streamCacheLimit", void 0);
DaemonCeramicNodeConfig = __decorate([
    jsonObject,
    toJson
], DaemonCeramicNodeConfig);
export { DaemonCeramicNodeConfig };
let DaemonLoggerConfig = class DaemonLoggerConfig {
};
__decorate([
    jsonMember(String, { name: 'log-directory' }),
    __metadata("design:type", String)
], DaemonLoggerConfig.prototype, "logDirectory", void 0);
__decorate([
    jsonMember(Number, { name: 'log-level' }),
    __metadata("design:type", Number)
], DaemonLoggerConfig.prototype, "logLevel", void 0);
__decorate([
    jsonMember(Boolean, { name: 'log-to-files' }),
    __metadata("design:type", Boolean)
], DaemonLoggerConfig.prototype, "logToFiles", void 0);
DaemonLoggerConfig = __decorate([
    jsonObject,
    toJson
], DaemonLoggerConfig);
export { DaemonLoggerConfig };
let DaemonMetricsConfig = class DaemonMetricsConfig {
};
__decorate([
    jsonMember(Boolean, { name: 'prometheus-exporter-enabled' }),
    __metadata("design:type", Boolean)
], DaemonMetricsConfig.prototype, "prometheusExporterEnabled", void 0);
__decorate([
    jsonMember(Number, { name: 'prometheus-exporter-port' }),
    __metadata("design:type", Number)
], DaemonMetricsConfig.prototype, "prometheusExporterPort", void 0);
__decorate([
    jsonMember(Boolean, { name: 'metrics-exporter-enabled' }),
    __metadata("design:type", Boolean)
], DaemonMetricsConfig.prototype, "metricsExporterEnabled", void 0);
__decorate([
    jsonMember(String, { name: 'collector-host' }),
    __metadata("design:type", String)
], DaemonMetricsConfig.prototype, "collectorHost", void 0);
DaemonMetricsConfig = __decorate([
    jsonObject,
    toJson
], DaemonMetricsConfig);
export { DaemonMetricsConfig };
let DaemonConfig = DaemonConfig_1 = class DaemonConfig {
    static fromString(jsonString) {
        const jsonObject = JSON.parse(jsonString);
        return this.fromObject(jsonObject);
    }
    static async fromFile(filepath) {
        const content = await readFile(filepath, { encoding: 'utf8' });
        const config = DaemonConfig_1.fromString(content);
        expandPaths(config, filepath);
        return config;
    }
    static fromObject(json) {
        const serializer = new TypedJSON(DaemonConfig_1, {
            errorHandler: (err) => {
                throw err;
            },
        });
        const config = serializer.parse(json);
        if (json.node) {
            if (json.node.privateSeedUrl) {
                config.node.privateSeedUrl = json.node.privateSeedUrl;
            }
        }
        return config;
    }
};
__decorate([
    jsonMember(DaemonAnchorConfig),
    __metadata("design:type", DaemonAnchorConfig)
], DaemonConfig.prototype, "anchor", void 0);
__decorate([
    jsonMember(DaemonHTTPApiConfig, { name: 'http-api' }),
    __metadata("design:type", DaemonHTTPApiConfig)
], DaemonConfig.prototype, "httpApi", void 0);
__decorate([
    jsonMember(DaemonIpfsConfig),
    __metadata("design:type", DaemonIpfsConfig)
], DaemonConfig.prototype, "ipfs", void 0);
__decorate([
    jsonMember(DaemonLoggerConfig),
    __metadata("design:type", DaemonLoggerConfig)
], DaemonConfig.prototype, "logger", void 0);
__decorate([
    jsonMember(DaemonMetricsConfig),
    __metadata("design:type", DaemonMetricsConfig)
], DaemonConfig.prototype, "metrics", void 0);
__decorate([
    jsonMember(DaemonCeramicNetworkConfig),
    __metadata("design:type", DaemonCeramicNetworkConfig)
], DaemonConfig.prototype, "network", void 0);
__decorate([
    jsonMember(DaemonCeramicNodeConfig),
    __metadata("design:type", DaemonCeramicNodeConfig)
], DaemonConfig.prototype, "node", void 0);
__decorate([
    jsonMember(DaemonStateStoreConfig, { name: 'state-store' }),
    __metadata("design:type", DaemonStateStoreConfig)
], DaemonConfig.prototype, "stateStore", void 0);
__decorate([
    jsonMember(IndexingConfig),
    __metadata("design:type", IndexingConfig)
], DaemonConfig.prototype, "indexing", void 0);
DaemonConfig = DaemonConfig_1 = __decorate([
    jsonObject,
    toJson
], DaemonConfig);
export { DaemonConfig };
export function validateConfig(config) {
    if (config.anchor) {
        if (config.anchor.authMethod == AnchorServiceAuthMethods.DID) {
            if (!config.node)
                throw new StartupError('Daemon config is missing node.private-seed-url');
            if (!config.node.sensitive_privateSeedUrl())
                throw new StartupError('Daemon config is missing node.private-seed-url');
        }
    }
}
//# sourceMappingURL=daemon-config.js.map