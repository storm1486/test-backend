import { default as PgBoss, type SendOptions } from 'pg-boss';
import { DiagnosticsLogger } from '@ceramicnetwork/common';
export interface Job<T extends Record<any, any>> {
    name: string;
    data: T;
    id?: string;
    options?: SendOptions;
}
export interface JobWithMetadata<T> extends Job<T> {
    startedOn: Date;
    createdOn: Date;
    completedOn: Date | null;
}
export declare type JobState = 'created' | 'retry' | 'active' | 'completed' | 'expired' | 'cancelled' | 'failed';
export interface IJobQueue<T extends Record<any, any>> {
    init: (workersByJob: Record<string, Worker<T>>) => Promise<void>;
    addJob: (job: Job<T>) => Promise<void>;
    addJobs: (jobs: Job<T>[]) => Promise<void>;
    updateJob: (jobId: string, data: T) => Promise<void>;
    stop: () => Promise<void>;
    getJobs(state: JobState, jobTypes: Array<string>): Promise<Record<string, Array<JobWithMetadata<T>>>>;
}
export declare type Worker<T> = {
    handler: (job: PgBoss.Job<T>) => any;
};
export declare class JobQueue<T extends Record<any, any>> implements IJobQueue<T> {
    private readonly logger;
    private queue;
    private dbConnection;
    private jobs;
    constructor(db: string, logger: DiagnosticsLogger);
    _getJobIds(state?: JobState, jobTypes?: string[]): Promise<string[]>;
    getJobs(state?: JobState, jobTypes?: string[]): Promise<Record<string, Array<JobWithMetadata<T>>>>;
    init(workersByJob: Record<string, Worker<T>>, resumeActive?: boolean): Promise<void>;
    _workerExistsForJob(jobName: string): boolean;
    addJob(job: Job<T>): Promise<void>;
    addJobs(jobs: Job<T>[]): Promise<void>;
    stop(): Promise<void>;
    updateJob(jobId: string, data: T): Promise<void>;
    _clearAllJobs(): Promise<void>;
    _waitForAllJobsToComplete(): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map