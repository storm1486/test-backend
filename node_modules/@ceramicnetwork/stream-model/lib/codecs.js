import { didString, streamIdAsBytes, streamIdString } from '@ceramicnetwork/codecs';
import Ajv from 'ajv/dist/2020.js';
import addFormats from 'ajv-formats';
import { Type, identity, literal, nullCodec, optional, record, sparse, strict, string, union, array, boolean, } from 'codeco';
const ajv = new Ajv({
    strict: true,
    allErrors: true,
    allowMatchingProperties: false,
    ownProperties: false,
    unevaluated: false,
});
addFormats(ajv);
export function createSchemaType(type, name) {
    function isSchemaType(input) {
        return typeof input === 'object' && input != null && input.type === type;
    }
    return new Type(name, isSchemaType, (input, context) => {
        if (!isSchemaType(input)) {
            return context.failure(`Input is not a JSON schema of type: ${type}`);
        }
        const isValid = ajv.validateSchema(input);
        ajv.removeSchema(input);
        return isValid
            ? context.success(input)
            : context.failure(`Validation Error: ${ajv.errorsText()}`);
    }, identity);
}
export const ObjectSchema = createSchemaType('object', 'ObjectSchema');
export const optionalModelString = union([streamIdString, nullCodec]);
export const ModelMetadata = strict({
    controller: didString,
    model: streamIdAsBytes,
}, 'ModelMetadata');
export const ModelAccountRelation = union([strict({ type: literal('list') }), strict({ type: literal('single') })], 'ModelAccountRelation');
export const ModelAccountRelationV2 = union([
    strict({ type: literal('list') }),
    strict({ type: literal('single') }),
    strict({ type: literal('none') }),
    strict({ type: literal('set'), fields: array(string) }),
], 'ModelAccountRelationV2');
export const ModelRelationDefinition = union([
    strict({ type: literal('account') }),
    strict({ type: literal('document'), model: streamIdString }),
], 'ModelRelationDefinition');
export const ModelRelationDefinitionV2 = union([
    strict({ type: literal('account') }),
    strict({ type: literal('document'), model: optionalModelString }),
], 'ModelRelationDefinitionV2');
export const ModelRelationsDefinition = record(string, ModelRelationDefinition, 'ModelRelationsDefinition');
export const ModelRelationsDefinitionV2 = record(string, ModelRelationDefinitionV2, 'ModelRelationsDefinitionV2');
export const ModelDocumentMetadataViewDefinition = union([strict({ type: literal('documentAccount') }), strict({ type: literal('documentVersion') })], 'ModelDocumentMetadataViewDefinition');
export const ModelRelationViewDefinition = union([
    strict({ type: literal('relationDocument'), model: streamIdString, property: string }),
    strict({ type: literal('relationFrom'), model: streamIdString, property: string }),
    strict({ type: literal('relationCountFrom'), model: streamIdString, property: string }),
], 'ModelRelationViewDefinition');
export const ModelRelationViewDefinitionV2 = union([
    strict({ type: literal('relationDocument'), model: optionalModelString, property: string }),
    strict({ type: literal('relationFrom'), model: streamIdString, property: string }),
    strict({ type: literal('relationCountFrom'), model: streamIdString, property: string }),
], 'ModelRelationViewDefinitionV2');
export const ModelViewDefinition = union([ModelDocumentMetadataViewDefinition, ModelRelationViewDefinition], 'ModelViewDefinition');
export const ModelViewDefinitionV2 = union([ModelDocumentMetadataViewDefinition, ModelRelationViewDefinitionV2], 'ModelViewDefinitionV2');
export const ModelViewsDefinition = record(string, ModelViewDefinition, 'ModelViewDefinition');
export const ModelViewsDefinitionV2 = record(string, ModelViewDefinitionV2, 'ModelViewDefinitionV2');
export const ModelDefinitionV1 = sparse({
    version: literal('1.0'),
    name: string,
    description: optional(string),
    schema: ObjectSchema,
    accountRelation: ModelAccountRelation,
    relations: optional(ModelRelationsDefinition),
    views: optional(ModelViewsDefinition),
}, 'ModelDefinitionV1');
export const ModelDefinitionV2 = sparse({
    version: literal('2.0'),
    name: string,
    description: optional(string),
    interface: boolean,
    implements: array(streamIdString),
    schema: ObjectSchema,
    accountRelation: ModelAccountRelationV2,
    relations: optional(ModelRelationsDefinitionV2),
    views: optional(ModelViewsDefinitionV2),
}, 'ModelDefinitionV2');
export const ModelDefinition = union([ModelDefinitionV1, ModelDefinitionV2], 'ModelDefinition');
//# sourceMappingURL=codecs.js.map