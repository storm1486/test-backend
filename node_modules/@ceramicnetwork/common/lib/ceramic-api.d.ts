import type { DID } from 'dids';
import type { Stream, StreamHandler, CeramicCommit, StreamState } from './stream.js';
import type { AnchorOpts, CreateOpts, LoadOpts, PublishOpts, UpdateOpts } from './streamopts.js';
import type { StreamID, CommitID } from '@ceramicnetwork/streamid';
import type { LoggerProvider } from './logger-provider.js';
import type { GenesisCommit } from './index.js';
import type { IndexApi } from './index-api.js';
import { NodeStatusResponse } from './node-status-interface.js';
import type { AnchorStatus } from './stream.js';
export declare type Field = {
    path: Array<string>;
};
export declare type FieldsIndex = {
    fields: Array<Field>;
};
export declare type ModelData = {
    streamID: StreamID;
    indices?: Array<FieldsIndex>;
};
export interface PinApi {
    add(streamId: StreamID, force?: boolean): Promise<void>;
    rm(streamId: StreamID, opts?: PublishOpts): Promise<void>;
    ls(streamId?: StreamID): Promise<AsyncIterable<string>>;
}
export type { DIDProvider } from 'dids';
interface CeramicCommon {
    loggerProvider?: LoggerProvider;
}
export interface CeramicSigner extends CeramicCommon {
    did: DID | undefined;
    [index: string]: any;
}
export declare function convertModelIdsToModelData(modelIds: Array<StreamID>): Array<ModelData>;
export interface AdminApi {
    nodeStatus(): Promise<NodeStatusResponse>;
    getIndexedModels(): Promise<Array<StreamID>>;
    getIndexedModelData(): Promise<Array<ModelData>>;
    startIndexingModels(modelsIDs: Array<StreamID>): Promise<void>;
    startIndexingModelData(modelData: Array<ModelData>): Promise<void>;
    stopIndexingModels(modelsIDs: Array<StreamID>): Promise<void>;
    stopIndexingModelData(modelData: Array<ModelData>): Promise<void>;
    pin: PinApi;
}
export interface CeramicApi extends CeramicSigner {
    readonly index: IndexApi;
    readonly admin: AdminApi;
    addStreamHandler<T extends Stream>(streamHandler: StreamHandler<T>): void;
    createStreamFromGenesis<T extends Stream>(type: number, genesis: any, opts?: CreateOpts): Promise<T>;
    loadStream<T extends Stream>(streamId: StreamID | CommitID | string, opts?: LoadOpts): Promise<T>;
    loadStreamCommits(streamId: StreamID | string): Promise<Array<Record<string, any>>>;
    multiQuery(queries: Array<MultiQuery>, timeout?: number): Promise<Record<string, Stream>>;
    applyCommit<T extends Stream>(streamId: StreamID | string, commit: CeramicCommit, opts?: UpdateOpts): Promise<T>;
    requestAnchor(streamId: StreamID | string, opts?: LoadOpts & AnchorOpts): Promise<AnchorStatus>;
    setDID(did: DID): Promise<void>;
    getSupportedChains(): Promise<Array<string>>;
    buildStreamFromState<T extends Stream = Stream>(state: StreamState): T;
    close(): Promise<void>;
}
export interface MultiQuery {
    genesis?: GenesisCommit;
    streamId: CommitID | StreamID | string;
    paths?: Array<string>;
    opts?: LoadOpts;
}
export declare type CeramicCoreApi = {
    loadStream<T extends Stream>(streamId: StreamID | CommitID | string, opts?: LoadOpts): Promise<T>;
    loadStreamState(streamId: StreamID): Promise<StreamState | undefined>;
};
//# sourceMappingURL=ceramic-api.d.ts.map