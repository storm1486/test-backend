import { BehaviorSubject, firstValueFrom } from 'rxjs';
import { filter } from 'rxjs/operators';
import { CID } from 'multiformats/cid';
import * as random from '@stablelib/random';
import { StreamID } from '@ceramicnetwork/streamid';
import first from 'it-first';
import { create } from 'multiformats/hashes/digest';
import { StreamUtils } from './stream-utils.js';
import { AnchorStatus, CommitType, SignatureStatus } from '../stream.js';
class FakeRunningState extends BehaviorSubject {
    constructor(value) {
        super(value);
        this.state = this.value;
        this.id = new StreamID(this.state.type, this.state.log[0].cid);
    }
}
export class TestUtils {
    static async waitForConditionOrTimeout(predicate, timeoutMs = 1000 * 30) {
        const startTime = new Date();
        const deadline = new Date(startTime.getTime() + timeoutMs);
        let now = startTime;
        while (now < deadline) {
            await TestUtils.delay(100);
            now = new Date();
            try {
                const res = await predicate();
                if (res) {
                    return res;
                }
            }
            catch (err) {
                console.warn(err);
            }
        }
        console.warn(`timed out after ${timeoutMs}ms waiting for condition to be true`);
        return false;
    }
    static async waitForState(stream, timeoutMs, predicate, onFailure) {
        let now = new Date();
        const expiration = new Date(now.getTime() + timeoutMs);
        while (now < expiration) {
            await stream.sync();
            if (predicate(stream.state)) {
                return;
            }
            now = new Date();
            await TestUtils.delay(100);
        }
        if (onFailure) {
            onFailure(stream.state);
        }
        else {
            throw new Error(`Timeout while waiting for desired state to be reached.  Current state: ${JSON.stringify(StreamUtils.serializeState(stream.state), null, 2)}`);
        }
    }
    static waitForAnchor(stream, timeout) {
        return this.waitForState(stream, timeout, (s) => s.anchorStatus === AnchorStatus.ANCHORED, () => {
            throw new Error(`Expect anchored`);
        });
    }
    static runningState(state) {
        return new FakeRunningState(state);
    }
    static async delay(ms, signal) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => resolve(), ms);
            if (signal) {
                const handleAbort = () => {
                    clearTimeout(timeout);
                    signal.removeEventListener('abort', handleAbort);
                    reject(signal.reason);
                };
                if (signal.aborted)
                    handleAbort();
                signal.addEventListener('abort', handleAbort);
            }
        });
    }
    static async isPinned(ceramic, streamId) {
        const iterator = await ceramic.admin.pin.ls(streamId);
        return (await first(iterator)) == streamId.toString();
    }
    static randomCID(version = 1, codec = 0x71, hasher = 0x12) {
        return CID.create(version, codec, create(hasher, random.randomBytes(32)));
    }
    static randomStreamID() {
        return new StreamID(0, this.randomCID());
    }
    static async anchorUpdate(ceramic, stream) {
        const anchorService = ceramic.anchorService;
        if ('anchor' in anchorService) {
            const tillAnchored = firstValueFrom(stream.pipe(filter((state) => [AnchorStatus.ANCHORED, AnchorStatus.FAILED].includes(state.anchorStatus))));
            await anchorService.anchor();
            await tillAnchored;
        }
    }
    static makeStreamState() {
        const cid = TestUtils.randomCID();
        return {
            type: 0,
            content: { num: 0 },
            metadata: {
                controllers: [''],
            },
            signature: SignatureStatus.GENESIS,
            anchorStatus: AnchorStatus.NOT_REQUESTED,
            log: [
                {
                    type: CommitType.GENESIS,
                    cid,
                },
            ],
        };
    }
}
//# sourceMappingURL=test-utils.js.map