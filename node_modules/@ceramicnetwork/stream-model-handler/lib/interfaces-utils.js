import { Model, } from '@ceramicnetwork/stream-model';
import { JsonReference } from 'json-ptr';
import isMatch from 'lodash.ismatch';
export function getErrorMessage(data) {
    const path = data.path.join('.');
    const target = data.property
        ? `property ${data.property} of ${path}`
        : data.index
            ? `index ${data.index} of ${path}`
            : path;
    const actual = data.actual ? String(data.actual) : 'no value';
    return `Invalid value for ${target}: expected ${String(data.expected)} but got ${actual}`;
}
export class ValidationError extends Error {
    constructor(data, message) {
        super(message ?? getErrorMessage(data));
        this.path = data.path;
        this.property = data.property;
        this.index = data.index;
        this.expected = data.expected;
        this.actual = data.actual;
    }
}
export function childContext(ctx, key) {
    return { ...ctx, path: [...ctx.path, key] };
}
export function resolveReference(childSchema, parentSchema) {
    let schema = childSchema;
    if (childSchema.$ref != null) {
        const ref = new JsonReference(childSchema.$ref);
        schema = ref.resolve(parentSchema);
    }
    return schema ?? null;
}
export function validateInterface(model) {
    if (Object.keys(model.schema?.properties ?? {}).length === 0 &&
        Object.keys(model.views ?? {}).length === 0) {
        throw new Error('Invalid interface: a least one propery or view must be present');
    }
}
export function validateArraySchema(context, expected, implemented) {
    const errors = [];
    if (expected.maxItems != null &&
        (implemented.maxItems == null || implemented.maxItems > expected.maxItems)) {
        errors.push({
            path: context.path,
            property: 'maxItems',
            expected: expected.maxItems,
            actual: implemented.maxItems,
        });
    }
    if (expected.minItems != null &&
        (implemented.minItems == null || implemented.minItems < expected.minItems)) {
        errors.push({
            path: context.path,
            property: 'minItems',
            expected: expected.minItems,
            actual: implemented.minItems,
        });
    }
    if (expected.items == null || implemented.items == null) {
        errors.push({
            path: context.path,
            property: 'items',
            expected: expected.items,
            actual: implemented.items,
        });
    }
    else {
        const resolvedExpected = context.resolveExpected(expected.items);
        const resolvedImplemented = context.resolveImplemented(implemented.items);
        if (resolvedExpected == null || resolvedImplemented == null) {
            errors.push({
                path: context.path,
                property: 'items',
                expected: resolvedExpected,
                actual: resolvedImplemented,
            });
        }
        else {
            return errors.concat(validateSchemaType(childContext(context, 'items'), resolvedExpected, resolvedImplemented));
        }
    }
    return errors;
}
export function validateBooleanSchema(context, expected, implemented) {
    if (expected.const != null && implemented.const !== expected.const) {
        return [
            {
                path: context.path,
                property: 'const',
                expected: expected.const,
                actual: implemented.const,
            },
        ];
    }
    return [];
}
export function validateObjectSchema(context, expected, implemented) {
    let errors = [];
    const implementedRequired = implemented.required ?? [];
    for (const required of expected.required ?? []) {
        if (!implementedRequired.includes(required)) {
            errors.push({ path: context.path, property: 'required', expected: required });
        }
    }
    const implementedProperties = implemented.properties ?? {};
    for (const [key, expectedValue] of Object.entries(expected.properties ?? {})) {
        const implementedValue = implementedProperties[key];
        if (implementedValue == null) {
            errors.push({ path: context.path, property: 'properties', expected: key });
        }
        else {
            const resolvedExpected = context.resolveExpected(expectedValue);
            const resolvedImplemented = context.resolveImplemented(implementedValue);
            const propertyErrors = validateSchemaType(childContext(context, key), resolvedExpected, resolvedImplemented);
            errors = errors.concat(propertyErrors);
        }
    }
    return errors;
}
export function validateNumberSchema(context, expected, implemented) {
    const errors = [];
    if (expected.const != null && implemented.const !== expected.const) {
        errors.push({
            path: context.path,
            property: 'const',
            expected: expected.const,
            actual: implemented.const,
        });
    }
    if (expected.maximum != null) {
        if (implemented.const != null) {
            if (implemented.const > expected.maximum) {
                errors.push({
                    path: context.path,
                    property: 'maximum',
                    expected: expected.maximum,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.maximum == null || implemented.maximum > expected.maximum) {
            errors.push({
                path: context.path,
                property: 'maximum',
                expected: expected.maximum,
                actual: implemented.maximum,
            });
        }
    }
    if (expected.minimum != null) {
        if (implemented.const != null) {
            if (implemented.const < expected.minimum) {
                errors.push({
                    path: context.path,
                    property: 'minimum',
                    expected: expected.minimum,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.minimum == null || implemented.minimum < expected.minimum) {
            errors.push({
                path: context.path,
                property: 'minimum',
                expected: expected.minimum,
                actual: implemented.minimum,
            });
        }
    }
    if (expected.exclusiveMaximum != null) {
        if (implemented.const != null) {
            if (implemented.const >= expected.exclusiveMaximum) {
                errors.push({
                    path: context.path,
                    property: 'exclusiveMaximum',
                    expected: expected.exclusiveMaximum,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.exclusiveMaximum == null ||
            implemented.exclusiveMaximum > expected.exclusiveMaximum) {
            errors.push({
                path: context.path,
                property: 'exclusiveMaximum',
                expected: expected.exclusiveMaximum,
                actual: implemented.exclusiveMaximum,
            });
        }
    }
    if (expected.exclusiveMinimum != null) {
        if (implemented.const != null) {
            if (implemented.const <= expected.exclusiveMinimum) {
                errors.push({
                    path: context.path,
                    property: 'exclusiveMinimum',
                    expected: expected.exclusiveMinimum,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.exclusiveMinimum == null ||
            implemented.exclusiveMinimum < expected.exclusiveMinimum) {
            errors.push({
                path: context.path,
                property: 'exclusiveMinimum',
                expected: expected.exclusiveMinimum,
                actual: implemented.exclusiveMinimum,
            });
        }
    }
    return errors;
}
export function validateStringSchema(context, expected, implemented) {
    const errors = [];
    if (expected.const != null && implemented.const !== expected.const) {
        errors.push({
            path: context.path,
            property: 'const',
            expected: expected.const,
            actual: implemented.const,
        });
    }
    if (expected.enum != null) {
        if (implemented.const != null) {
            if (!expected.enum.includes(implemented.const)) {
                errors.push({
                    path: context.path,
                    property: 'enum',
                    expected: expected.enum,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.enum != null) {
            let hasAnyValue = false;
            for (const value of expected.enum) {
                if (implemented.enum.includes(value)) {
                    hasAnyValue = true;
                    break;
                }
            }
            if (hasAnyValue) {
                for (const value of implemented.enum) {
                    if (!expected.enum.includes(value)) {
                        errors.push({
                            path: context.path,
                            property: 'enum',
                            expected: expected.enum,
                            actual: implemented.enum,
                        });
                        break;
                    }
                }
            }
            else {
                errors.push({
                    path: context.path,
                    property: 'enum',
                    expected: expected.enum,
                    actual: implemented.enum,
                });
            }
        }
        else {
            errors.push({ path: context.path, property: 'enum', expected: expected.enum });
        }
    }
    if (expected.pattern != null && implemented.pattern !== expected.pattern) {
        errors.push({
            path: context.path,
            property: 'pattern',
            expected: expected.pattern,
            actual: implemented.pattern,
        });
    }
    if (expected.maxLength != null) {
        if (implemented.const != null) {
            if (implemented.const.length > expected.maxLength) {
                errors.push({
                    path: context.path,
                    property: 'maxLength',
                    expected: expected.maxLength,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.maxLength == null || implemented.maxLength > expected.maxLength) {
            errors.push({
                path: context.path,
                property: 'maxLength',
                expected: expected.maxLength,
                actual: implemented.maxLength,
            });
        }
    }
    if (expected.minLength != null) {
        if (implemented.const != null) {
            if (implemented.const.length < expected.minLength) {
                errors.push({
                    path: context.path,
                    property: 'minLength',
                    expected: expected.minLength,
                    actual: implemented.const,
                });
            }
        }
        else if (implemented.minLength == null || implemented.minLength < expected.minLength) {
            errors.push({
                path: context.path,
                property: 'minLength',
                expected: expected.minLength,
                actual: implemented.minLength,
            });
        }
    }
    return errors;
}
export function validateAllSchemaTypes(context, expectedList, implementedList) {
    if (implementedList.length !== expectedList.length) {
        return [
            {
                path: context.path,
                property: 'length',
                expected: expectedList.length,
                actual: implementedList.length,
            },
        ];
    }
    const errors = [];
    expectedLoop: for (const [index, expected] of expectedList.entries()) {
        for (const implemented of implementedList) {
            const matchErrors = validateSchemaType(context, expected, implemented);
            if (matchErrors.length === 0) {
                continue expectedLoop;
            }
        }
        errors.push({ path: context.path, index, expected });
    }
    return errors;
}
export function validateAnySchemaTypes(context, expectedList, implementedList) {
    const errors = [];
    for (const [index, expected] of expectedList.entries()) {
        for (const implemented of implementedList) {
            const matchErrors = validateSchemaType(context, expected, implemented);
            if (matchErrors.length === 0) {
                return [];
            }
        }
        errors.push({ path: context.path, index, expected });
    }
    return errors;
}
export function validateSchemaType(context, expected, implemented) {
    if (typeof expected === 'boolean') {
        return implemented === expected ? [] : [{ path: context.path, expected, actual: implemented }];
    }
    else if (typeof implemented === 'boolean') {
        return [{ path: context.path, expected, actual: implemented }];
    }
    let errors = [];
    if (expected.title != null && implemented.title !== expected.title) {
        errors.push({
            path: context.path,
            property: 'title',
            expected: expected.title,
            actual: implemented.title,
        });
    }
    if (Array.isArray(expected.allOf)) {
        if (Array.isArray(implemented.allOf)) {
            const allOfErrors = validateAllSchemaTypes(childContext(context, 'allOf'), expected.allOf, implemented.allOf);
            errors = errors.concat(allOfErrors);
        }
        else {
            errors.push({
                path: context.path,
                property: 'allOf',
                expected: expected.allOf,
                actual: implemented.allOf,
            });
        }
    }
    else if (Array.isArray(expected.anyOf)) {
        const anyOfErrors = validateAnySchemaTypes(childContext(context, 'anyOf'), expected.anyOf, Array.isArray(implemented.anyOf) ? implemented.anyOf : [implemented]);
        errors = errors.concat(anyOfErrors);
    }
    else if (Array.isArray(expected.oneOf)) {
        if (Array.isArray(implemented.oneOf)) {
            const oneOfErrors = validateAllSchemaTypes(childContext(context, 'oneOf'), expected.oneOf, implemented.oneOf);
            errors = errors.concat(oneOfErrors);
        }
        else {
            errors.push({
                path: context.path,
                property: 'oneOf',
                expected: expected.oneOf,
                actual: implemented.oneOf,
            });
        }
    }
    else if (implemented.type !== expected.type) {
        errors.push({
            path: context.path,
            property: 'type',
            expected: expected.type,
            actual: implemented.type,
        });
    }
    else {
        let schemaTypeErrors = [];
        switch (expected.type) {
            case 'array': {
                schemaTypeErrors = validateArraySchema(context, expected, implemented);
                break;
            }
            case 'object': {
                schemaTypeErrors = validateObjectSchema(context, expected, implemented);
                break;
            }
            case 'integer':
            case 'number': {
                schemaTypeErrors = validateNumberSchema(context, expected, implemented);
                break;
            }
            case 'string': {
                schemaTypeErrors = validateStringSchema(context, expected, implemented);
                break;
            }
            case 'boolean':
                schemaTypeErrors = validateBooleanSchema(context, expected, implemented);
                break;
            case 'null':
                break;
            default:
                throw new Error(`Unsupported schema type: ${expected.type}`);
        }
        return errors.concat(schemaTypeErrors);
    }
    return errors;
}
export function createResolvers(expected, implemented) {
    return {
        resolveExpected: (schema) => resolveReference(schema, expected),
        resolveImplemented: (schema) => resolveReference(schema, implemented),
    };
}
export function validateSchemaImplementation(expected, implemented) {
    const resolvers = createResolvers(expected, implemented);
    return validateSchemaType({ ...resolvers, path: [] }, expected, implemented);
}
export function isValidRelationsImplementation(expected = {}, implemented = {}) {
    return isMatch(implemented, expected);
}
export function isValidViewsImplementation(expected = {}, implemented = {}) {
    return isMatch(implemented, expected);
}
export function validateInterfaceImplementation(interfaceID, expected, implemented) {
    const errors = [];
    const schemaErrors = validateSchemaImplementation(expected.schema, implemented.schema);
    if (schemaErrors.length) {
        errors.push(new AggregateError(schemaErrors.map((data) => new ValidationError(data)), `Invalid schema implementation of interface ${interfaceID}`));
    }
    if (!isValidRelationsImplementation(expected.relations, implemented.relations)) {
        errors.push(new Error(`Invalid relations implementation of interface ${interfaceID}`));
    }
    if (!isValidViewsImplementation(expected.views, implemented.views)) {
        errors.push(new Error(`Invalid views implementation of interface ${interfaceID}`));
    }
    if (errors.length) {
        throw new AggregateError(errors, `Invalid implementation of interface ${interfaceID}`);
    }
}
export async function validateImplementedInterfaces(model, context) {
    const errors = [];
    const toValidate = (model.implements ?? []).map(async (interfaceID) => {
        try {
            const interfaceModel = await Model.load(context.api, interfaceID);
            validateInterfaceImplementation(interfaceID, interfaceModel.content, model);
        }
        catch (error) {
            errors.push(error);
        }
    });
    await Promise.all(toValidate);
    if (errors.length) {
        throw new AggregateError(errors, `Interfaces validation failed for model ${model.name}`);
    }
}
//# sourceMappingURL=interfaces-utils.js.map