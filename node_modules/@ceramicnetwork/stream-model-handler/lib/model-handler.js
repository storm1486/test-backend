import { Model } from '@ceramicnetwork/stream-model';
import { AnchorStatus, CommitType, SignatureStatus, SignatureUtils, StreamUtils, } from '@ceramicnetwork/common';
import { StreamID } from '@ceramicnetwork/streamid';
import { SchemaValidation } from './schema-utils.js';
import { ViewsValidation } from './views-utils.js';
import { applyAnchorCommit } from '@ceramicnetwork/stream-handler-common';
import { validateInterface, validateImplementedInterfaces } from './interfaces-utils.js';
const ALLOWED_CONTENT_KEYS = new Set([
    'version',
    'name',
    'description',
    'schema',
    'accountRelation',
    'relations',
    'views',
    'interface',
    'implements',
]);
const assertNoExtraKeys = function (content) {
    for (const key of Object.keys(content)) {
        if (!ALLOWED_CONTENT_KEYS.has(key)) {
            throw new Error(`Unexpected key '${key}' found in content for Model Stream`);
        }
    }
};
export class ModelHandler {
    constructor() {
        this._schemaValidator = new SchemaValidation();
        this._viewsValidator = new ViewsValidation();
    }
    get type() {
        return Model.STREAM_TYPE_ID;
    }
    get name() {
        return Model.STREAM_TYPE_NAME;
    }
    get stream_constructor() {
        return Model;
    }
    async applyCommit(commitData, context, state) {
        if (state == null) {
            return this._applyGenesis(commitData, context);
        }
        if (StreamUtils.isAnchorCommitData(commitData)) {
            return this._applyAnchor(commitData, state);
        }
        throw new Error('Cannot update a finalized Model');
    }
    async _applyGenesis(commitData, context) {
        const payload = commitData.commit;
        const isSigned = StreamUtils.isSignedCommitData(commitData);
        if (!isSigned) {
            throw Error('Model genesis commit must be signed');
        }
        if (!(payload.header.controllers && payload.header.controllers.length === 1)) {
            throw new Error('Exactly one controller must be specified');
        }
        const streamId = new StreamID(Model.STREAM_TYPE_ID, commitData.cid);
        const { controllers, model } = payload.header;
        const controller = controllers[0];
        const modelStreamID = StreamID.fromBytes(model);
        await SignatureUtils.verifyCommitSignature(commitData, context.did, controller, modelStreamID, streamId);
        assertNoExtraKeys(payload.data);
        Model.assertComplete(payload.data);
        Model.assertVersionValid(payload.data, 'major');
        Model.assertRelationsValid(payload.data);
        const modelStreamId = StreamID.fromBytes(payload.header.model);
        if (!modelStreamId.equals(Model.MODEL)) {
            throw new Error(`Invalid 'model' metadata property in Model stream: ${modelStreamId.toString()}`);
        }
        const metadata = { controllers: [controller], model: modelStreamId };
        const state = {
            type: Model.STREAM_TYPE_ID,
            content: payload.data,
            metadata,
            signature: SignatureStatus.SIGNED,
            anchorStatus: AnchorStatus.NOT_REQUESTED,
            log: [StreamUtils.commitDataToLogEntry(commitData, CommitType.GENESIS)],
        };
        await this._schemaValidator.validateSchema(state.content.schema);
        if (state.content.views) {
            this._viewsValidator.validateViews(state.content.views, state.content.schema);
        }
        if (state.content.interface) {
            validateInterface(state.content);
        }
        if (state.content.implements?.length) {
            await validateImplementedInterfaces(state.content, context);
        }
        return state;
    }
    async _applyAnchor(commitData, state) {
        return applyAnchorCommit(commitData, state);
    }
}
//# sourceMappingURL=model-handler.js.map