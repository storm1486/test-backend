import { createBlocksProofsLoader } from '@ceramicnetwork/anchor-listener';
import { concatMap, lastValueFrom, of, catchError } from 'rxjs';
import { createRebuildAnchorJob } from './rebuild-anchor.js';
import { HISTORY_SYNC_JOB, CONTINUOUS_SYNC_JOB, } from '../interfaces.js';
const SYNC_JOB_OPTIONS = {
    retryLimit: 5,
    retryDelay: 60,
    retryBackoff: true,
    expireInHours: 12,
    retentionDays: 3,
};
export function createContinuousSyncJob(data, options) {
    return {
        name: CONTINUOUS_SYNC_JOB,
        data,
        options: options || SYNC_JOB_OPTIONS,
    };
}
export function createHistorySyncJob(data, options) {
    return {
        name: HISTORY_SYNC_JOB,
        data,
        options: options || SYNC_JOB_OPTIONS,
    };
}
export class SyncWorker {
    constructor(provider, jobQueue, chainId, logger, syncCompleteCallback) {
        this.provider = provider;
        this.jobQueue = jobQueue;
        this.chainId = chainId;
        this.logger = logger;
        this.syncCompleteCallback = syncCompleteCallback;
    }
    async handler(job) {
        const jobData = job.data;
        const { jobType, fromBlock, toBlock, models } = jobData;
        const currentBlock = jobData.currentBlock || fromBlock;
        const blockProof$ = createBlocksProofsLoader({
            provider: this.provider,
            chainId: this.chainId,
            fromBlock: currentBlock,
            toBlock,
        }).pipe(catchError((err) => {
            this.logger.err(`Received error when retrieving block proofs for models ${models} from block ${currentBlock} to block ${toBlock}: ${err}`);
            return of(null);
        }), concatMap(async (blockProofs) => {
            if (!blockProofs) {
                throw Error('Error loading block proof');
            }
            const { proofs, blockNumber } = blockProofs;
            if (proofs.length > 0) {
                const jobs = proofs.map((proof) => createRebuildAnchorJob(proof, models));
                await this.jobQueue.addJobs(jobs);
                this.logger.debug(`Successfully created ${jobs.length} rebuild anchor commit jobs for block ${blockNumber}`);
            }
            await this.jobQueue.updateJob(job.id, {
                fromBlock,
                currentBlock: blockNumber + 1,
                toBlock,
                models,
                jobType,
            });
        }));
        await lastValueFrom(blockProof$).then(() => {
            if (this.syncCompleteCallback) {
                for (const model of models) {
                    this.syncCompleteCallback({
                        jobType: jobType,
                        modelId: model,
                    });
                }
            }
            this.logger.debug(`Sync completed for models ${models} from block ${fromBlock} to block ${toBlock}`);
        });
    }
}
//# sourceMappingURL=sync.js.map