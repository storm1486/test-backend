import * as uint8arrays from 'uint8arrays';
import { StreamID } from '@ceramicnetwork/streamid';
import { PaginationKind, parsePagination, } from './parse-pagination.js';
import { asTableName } from './as-table-name.util.js';
import { UnsupportedOrderingError } from './unsupported-ordering-error.js';
import { addColumnPrefix } from './column-name.util.js';
import { contentKey, convertQueryFilter, DATA_FIELD } from './query-filter-converter.js';
import { parseQueryFilters } from './query-filter-parser.js';
class Cursor {
    static parse(cursor) {
        return cursor
            ? JSON.parse(uint8arrays.toString(uint8arrays.fromString(cursor, 'base64url')))
            : undefined;
    }
    static stringify(input, orderByKeys = []) {
        if (input == null) {
            return undefined;
        }
        let cursor;
        if (orderByKeys.length === 0) {
            cursor = { type: 'timestamp', id: input.stream_id, value: input.created_at };
        }
        else {
            const content = typeof input.stream_content === 'string'
                ? JSON.parse(input.stream_content)
                : input.stream_content;
            cursor = { type: 'content', id: input.stream_id, value: {} };
            for (const key of orderByKeys) {
                if (content[key] != null) {
                    cursor.value[key] = content[key];
                }
            }
        }
        return uint8arrays.toString(uint8arrays.fromString(JSON.stringify(cursor)), 'base64url');
    }
}
const REVERSE_ORDER = {
    ASC: 'DESC',
    DESC: 'ASC',
};
function getComparisonSign(order = 'ASC', reverse = false) {
    return order === 'ASC' ? (reverse ? '<' : '>') : reverse ? '>' : '<';
}
function reverseOrder(entries) {
    return entries.map((entry) => ({ ...entry, order: REVERSE_ORDER[entry.order] }));
}
const INSERTION_ORDER = [{ column: 'created_at', order: 'ASC' }];
export class InsertionOrder {
    constructor(dbConnection) {
        this.dbConnection = dbConnection;
    }
    async page(models, query) {
        const orderByKeys = Object.keys(query.sorting ?? {});
        const pagination = parsePagination(query);
        const paginationKind = pagination.kind;
        switch (paginationKind) {
            case PaginationKind.FORWARD: {
                const limit = pagination.first;
                const response = await this.forwardQuery(models, query, pagination);
                const entries = response.slice(0, limit);
                const firstEntry = entries[0];
                const lastEntry = entries[entries.length - 1];
                return {
                    edges: entries.map((row) => {
                        return {
                            cursor: Cursor.stringify(row, orderByKeys),
                            node: StreamID.fromString(row.stream_id),
                        };
                    }),
                    pageInfo: {
                        hasNextPage: response.length > limit,
                        hasPreviousPage: false,
                        endCursor: Cursor.stringify(lastEntry, orderByKeys),
                        startCursor: Cursor.stringify(firstEntry, orderByKeys),
                    },
                };
            }
            case PaginationKind.BACKWARD: {
                const limit = pagination.last;
                const response = await this.backwardQuery(models, query, pagination);
                const entries = response.slice(-limit);
                const firstEntry = entries[0];
                const lastEntry = entries[entries.length - 1];
                return {
                    edges: entries.map((row) => {
                        return {
                            cursor: Cursor.stringify(row, orderByKeys),
                            node: StreamID.fromString(row.stream_id),
                        };
                    }),
                    pageInfo: {
                        hasNextPage: false,
                        hasPreviousPage: response.length > limit,
                        endCursor: Cursor.stringify(lastEntry, orderByKeys),
                        startCursor: Cursor.stringify(firstEntry, orderByKeys),
                    },
                };
            }
            default:
                throw new UnsupportedOrderingError(paginationKind);
        }
    }
    async forwardQuery(models, query, pagination) {
        return await this.query(models, query, false, Cursor.parse(pagination.after)).limit(pagination.first + 1);
    }
    async backwardQuery(models, query, pagination) {
        const response = await this.query(models, query, true, Cursor.parse(pagination.before)).limit(pagination.last + 1);
        response.reverse();
        return response;
    }
    query(models, query, isReverseOrder, cursor) {
        let builder = this.dbConnection
            .from((qb) => {
            const subQueries = Array.from(models).map((model) => {
                const subQuery = this.dbConnection
                    .from(asTableName(model))
                    .columns(['stream_id', 'last_anchored_at', 'created_at', DATA_FIELD])
                    .select();
                return this.applyFilters(subQuery, query);
            });
            return qb.unionAll(subQueries).as('models');
        })
            .columns(['stream_id', 'last_anchored_at', 'created_at', DATA_FIELD])
            .select();
        const sorting = query.sorting ?? {};
        if (cursor != null) {
            builder = this.applyCursor(builder, cursor, isReverseOrder, sorting);
        }
        builder = this.applySorting(builder, isReverseOrder, sorting);
        return builder;
    }
    applyFilters(builder, query) {
        if (query.account) {
            builder = builder.where({ controller_did: query.account });
        }
        if (query.queryFilters) {
            const parsed = parseQueryFilters(query.queryFilters);
            const converted = convertQueryFilter(parsed);
            if (converted) {
                builder = builder.where(converted.where);
            }
        }
        else if (query.filter) {
            for (const [key, value] of Object.entries(query.filter)) {
                const filterObj = {};
                filterObj[addColumnPrefix(key)] = value;
                builder = builder.andWhere(filterObj);
            }
        }
        return builder;
    }
    applyCursor(builder, cursor, isReverseOrder, sorting) {
        if (cursor.type === 'timestamp') {
            builder = builder.where((qb) => {
                qb.where('created_at', isReverseOrder ? '<' : '>', cursor.value)
                    .orWhere('created_at', '=', cursor.value)
                    .andWhere('stream_id', '>', cursor.id);
            });
        }
        else {
            for (const [key, value] of Object.entries(cursor.value)) {
                const field = contentKey(key);
                const sign = getComparisonSign(sorting[key], isReverseOrder);
                builder = builder.where((qb) => {
                    qb.whereRaw(`${field} ${sign} ?`, [value])
                        .orWhereRaw(`${field} = ?`, [value])
                        .andWhere('stream_id', '>', cursor.id);
                });
            }
        }
        return builder;
    }
    applySorting(builder, isReverseOrder, sorting) {
        const sortingEntries = Object.entries(sorting ?? {});
        if (sortingEntries.length === 0) {
            builder = builder.orderBy(isReverseOrder ? reverseOrder(INSERTION_ORDER) : INSERTION_ORDER);
        }
        else {
            for (const [field, order] of sortingEntries) {
                const orderBy = isReverseOrder ? REVERSE_ORDER[order] : order;
                builder = builder.orderByRaw(`${contentKey(field)} ${orderBy}`);
            }
        }
        builder = builder.orderBy('stream_id', 'asc');
        return builder;
    }
}
//# sourceMappingURL=insertion-order.js.map