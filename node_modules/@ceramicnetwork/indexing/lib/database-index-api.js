var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DatabaseIndexApi_interfacesModels;
import { StreamID } from '@ceramicnetwork/streamid';
import { InsertionOrder } from './insertion-order.js';
import { asTableName } from './as-table-name.util.js';
import { IndexQueryNotAvailableError } from './index-query-not-available.error.js';
import { PostgresTablesManager, SqliteTablesManager } from './tables-manager.js';
import { addColumnPrefix } from './column-name.util.js';
import cloneDeep from 'lodash.clonedeep';
import { indexNameFromTableName } from './migrations/1-create-model-table.js';
export const INDEXED_MODEL_CONFIG_TABLE_NAME = 'ceramic_models';
export const MODEL_IMPLEMENTS_TABLE_NAME = 'ceramic_model_implements';
export function fieldsIndexName(idx, table) {
    const fieldPath = idx.fields
        .flatMap((f) => f.path)
        .map((p) => p.slice(0, 5))
        .join('_');
    return `${indexNameFromTableName(table)}_${fieldPath}`.slice(0, 64);
}
export class DatabaseIndexApi {
    constructor(dbConnection, allowQueriesBeforeHistoricalSync, logger, network) {
        this.dbConnection = dbConnection;
        this.allowQueriesBeforeHistoricalSync = allowQueriesBeforeHistoricalSync;
        this.logger = logger;
        this.network = network;
        this.indexedModels = [];
        this.modelRelations = new Map();
        _DatabaseIndexApi_interfacesModels.set(this, {});
        this.insertionOrder = new InsertionOrder(dbConnection);
    }
    setSyncQueryApi(api) {
        this.syncApi = api;
    }
    addModelImplements(modelID, interfaceID) {
        const models = __classPrivateFieldGet(this, _DatabaseIndexApi_interfacesModels, "f")[interfaceID] ?? new Set();
        models.add(modelID);
        __classPrivateFieldGet(this, _DatabaseIndexApi_interfacesModels, "f")[interfaceID] = models;
    }
    async indexModels(models) {
        await this.indexModelsInDatabase(models);
        for (const modelArgs of models) {
            await this.assertNoOngoingSyncForModel(modelArgs.model);
            const foundModelToIndex = this.indexedModels.find((indexedModel) => indexedModel.streamID.equals(modelArgs.model));
            if (!foundModelToIndex) {
                this.indexedModels.push({
                    streamID: modelArgs.model,
                    indices: modelArgs.indices,
                });
            }
            if (modelArgs.relations) {
                this.modelRelations.set(modelArgs.model.toString(), Object.keys(modelArgs.relations));
            }
        }
    }
    async indexModelsInDatabase(models) {
        if (models.length === 0)
            return;
        await this.tablesManager.initMidTables(models);
        await this.tablesManager.verifyTables(models);
        await this.dbConnection.transaction(async (trx) => {
            await trx(INDEXED_MODEL_CONFIG_TABLE_NAME)
                .insert(models.map((indexModelArgs) => {
                return {
                    model: indexModelArgs.model.toString(),
                    ...(indexModelArgs.indices && { indices: JSON.stringify(indexModelArgs.indices) }),
                    is_indexed: true,
                    updated_by: '0',
                    updated_at: this.now(),
                };
            }))
                .onConflict('model')
                .merge({
                updated_at: this.now(),
                is_indexed: true,
                updated_by: '0',
            });
            const modelImplements = models.flatMap((args) => {
                const modelID = args.model.toString();
                return (args.implements ?? []).map((interfaceID) => {
                    this.addModelImplements(modelID, interfaceID);
                    return { interface_id: interfaceID, implemented_by_id: modelID };
                });
            });
            if (modelImplements.length) {
                await trx(MODEL_IMPLEMENTS_TABLE_NAME).insert(modelImplements).onConflict().ignore();
            }
        });
    }
    async stopIndexingModels(models) {
        await this.stopIndexingModelsInDatabase(models);
        this.indexedModels = this.indexedModels.filter((idx) => !models.some((data) => data.streamID.equals(idx.streamID)));
    }
    async stopIndexingModelsInDatabase(models) {
        if (models.length === 0)
            return;
        await this.dbConnection(INDEXED_MODEL_CONFIG_TABLE_NAME)
            .insert(models.map((model) => {
            return {
                model: model.streamID.toString(),
                is_indexed: false,
                updated_by: '0',
                updated_at: this.now(),
            };
        }))
            .onConflict('model')
            .merge({
            updated_at: this.now(),
            is_indexed: false,
            updated_by: '0',
        });
    }
    async indexStream(indexingArgs) {
        const tableName = asTableName(indexingArgs.model);
        const indexedData = this.getIndexedData(indexingArgs);
        const relations = this.modelRelations.get(indexingArgs.model.toString()) ?? [];
        for (const relation of relations) {
            indexedData[addColumnPrefix(relation)] = indexingArgs.streamContent[relation];
        }
        const toMerge = cloneDeep(indexedData);
        delete toMerge['created_at'];
        await this.dbConnection(tableName).insert(indexedData).onConflict('stream_id').merge(toMerge);
    }
    getIndexedModels() {
        return this.indexedModels;
    }
    async getIndexedModelsFromDatabase() {
        return (await this.dbConnection(INDEXED_MODEL_CONFIG_TABLE_NAME).select('model', 'indices').where({
            is_indexed: true,
        })).map((result) => {
            return {
                streamID: StreamID.fromString(result.model),
                indices: this.parseIndices(result.indices),
            };
        });
    }
    async _getInterfacesModelsFromDataBase() {
        const interfacesModels = {};
        const results = await this.dbConnection(MODEL_IMPLEMENTS_TABLE_NAME).select('interface_id', 'implemented_by_id');
        for (const result of results) {
            const interfaceID = result.interface_id;
            if (interfacesModels[interfaceID] == null) {
                interfacesModels[interfaceID] = new Set();
            }
            interfacesModels[interfaceID].add(result.implemented_by_id);
        }
        return interfacesModels;
    }
    async getModelsNoLongerIndexed() {
        return (await this.dbConnection(INDEXED_MODEL_CONFIG_TABLE_NAME).select('model', 'indices').where({
            is_indexed: false,
        })).map((result) => {
            return {
                streamID: StreamID.fromString(result.model),
                indices: result.indices,
            };
        });
    }
    async assertModelQueryable(modelStreamId) {
        await this.assertModelIsIndexed(modelStreamId);
        await this.assertNoOngoingSyncForModel(modelStreamId);
    }
    _getIndexedModel(id) {
        return this.indexedModels.find((indexedModel) => id.equals(indexedModel.streamID));
    }
    async assertModelIsIndexed(modelStreamId) {
        const foundModelToIndex = this._getIndexedModel(modelStreamId);
        if (foundModelToIndex == undefined) {
            const err = new Error(`Query failed: Model ${modelStreamId.toString()} is not indexed on this node`);
            this.logger.debug(err);
            throw err;
        }
    }
    async assertNoOngoingSyncForModel(modelStreamId) {
        if (!this.allowQueriesBeforeHistoricalSync &&
            !(await this.syncApi.syncComplete(modelStreamId.toString()))) {
            throw new IndexQueryNotAvailableError(modelStreamId);
        }
    }
    async getQueryModels(query) {
        let ids = [];
        if (Array.isArray(query.models) && query.models.length !== 0) {
            ids = query.models;
        }
        else if (query.model != null) {
            ids = [query.model];
        }
        else {
            throw new Error(`Missing "models" values to execute query`);
        }
        const models = new Set();
        for (const modelID of ids) {
            const id = modelID.toString();
            const interfaceModels = __classPrivateFieldGet(this, _DatabaseIndexApi_interfacesModels, "f")[id];
            if (interfaceModels == null) {
                models.add(id);
            }
            else {
                for (const model of interfaceModels) {
                    if (this._getIndexedModel(StreamID.fromString(model)) != null) {
                        models.add(model);
                    }
                }
            }
        }
        await Promise.all(Array.from(models).map(async (id) => {
            await this.assertModelQueryable(StreamID.fromString(id));
        }));
        return models;
    }
    async count(query) {
        const models = await this.getQueryModels(query);
        if (models.size === 0) {
            return 0;
        }
        return this.dbConnection
            .count('*')
            .from((qb) => {
            const subQueries = Array.from(models).map((model) => {
                return this.insertionOrder.applyFilters(this.dbConnection.from(asTableName(model)).select('stream_id'), query);
            });
            return qb.unionAll(subQueries).as('models');
        })
            .then((response) => this.getCountFromResult(response));
    }
    async page(query) {
        const models = await this.getQueryModels(query);
        if (models.size === 0) {
            return { edges: [], pageInfo: { hasNextPage: false, hasPreviousPage: false } };
        }
        return this.insertionOrder.page(models, query);
    }
    async init() {
        await this.tablesManager.initConfigTables(this.network);
        const [indexedModels, interfacesModels] = await Promise.all([
            this.getIndexedModelsFromDatabase(),
            this._getInterfacesModelsFromDataBase(),
        ]);
        this.indexedModels = indexedModels;
        __classPrivateFieldSet(this, _DatabaseIndexApi_interfacesModels, interfacesModels, "f");
    }
    async close() {
        await this.dbConnection.destroy();
    }
}
_DatabaseIndexApi_interfacesModels = new WeakMap();
export class PostgresIndexApi extends DatabaseIndexApi {
    constructor(dbConnection, allowQueriesBeforeHistoricalSync, logger, network) {
        super(dbConnection, allowQueriesBeforeHistoricalSync, logger, network);
        this.tablesManager = new PostgresTablesManager(dbConnection, logger);
    }
    now() {
        return new Date();
    }
    getCountFromResult(response) {
        return Number(response[0]['count']);
    }
    getIndexedData(indexingArgs) {
        const now = this.now();
        return {
            stream_id: indexingArgs.streamID.toString(),
            controller_did: indexingArgs.controller.toString(),
            stream_content: indexingArgs.streamContent,
            tip: indexingArgs.tip.toString(),
            last_anchored_at: indexingArgs.lastAnchor,
            first_anchored_at: indexingArgs.firstAnchor,
            created_at: indexingArgs.createdAt || now,
            updated_at: indexingArgs.updatedAt || now,
        };
    }
    parseIndices(indices) {
        return indices ?? undefined;
    }
}
export function asTimestamp(input) {
    if (input) {
        return input.valueOf();
    }
    else {
        return null;
    }
}
export class SqliteIndexApi extends DatabaseIndexApi {
    constructor(dbConnection, allowQueriesBeforeHistoricalSync, logger, network) {
        super(dbConnection, allowQueriesBeforeHistoricalSync, logger, network);
        this.tablesManager = new SqliteTablesManager(dbConnection, logger);
    }
    now() {
        return new Date().valueOf();
    }
    getCountFromResult(response) {
        return Number(response[0]['count(*)']);
    }
    getIndexedData(indexingArgs) {
        const now = this.now();
        return {
            stream_id: indexingArgs.streamID.toString(),
            controller_did: indexingArgs.controller.toString(),
            stream_content: JSON.stringify(indexingArgs.streamContent),
            tip: indexingArgs.tip.toString(),
            last_anchored_at: asTimestamp(indexingArgs.lastAnchor),
            first_anchored_at: asTimestamp(indexingArgs.firstAnchor),
            created_at: asTimestamp(indexingArgs.createdAt) || now,
            updated_at: asTimestamp(indexingArgs.updatedAt) || now,
        };
    }
    parseIndices(indices) {
        return indices ? JSON.parse(indices) : undefined;
    }
}
//# sourceMappingURL=database-index-api.js.map