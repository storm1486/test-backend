import { makeIndexApi } from './make-index-api.js';
import { Model, loadAllModelInterfaces, } from '@ceramicnetwork/stream-model';
async function _getIndexModelArgs(req, core, loading = {}) {
    const modelStreamId = req.streamID;
    if (modelStreamId.type != Model.STREAM_TYPE_ID && !modelStreamId.equals(Model.MODEL)) {
        throw new Error(`Cannot index ${modelStreamId.toString()}, it is not a Model StreamID`);
    }
    const opts = {
        model: modelStreamId,
    };
    if (modelStreamId.type == Model.STREAM_TYPE_ID) {
        const modelState = await core.loadStream(modelStreamId, {});
        const content = modelState.state.next?.content ?? modelState.state.content;
        Model.assertVersionValid(content, 'major');
        if (content.interface) {
            throw new Error(`Model ${modelStreamId.toString()} is an interface and cannot be indexed`);
        }
        if (content.relations) {
            opts.relations = content.relations;
        }
        if (content.implements) {
            opts.implements = await loadAllModelInterfaces(core, content.implements, loading);
        }
        opts.indices = req.indices;
    }
    return opts;
}
export class LocalIndexApi {
    constructor(indexingConfig, core, logger, networkName) {
        this.core = core;
        this.logger = logger;
        this.databaseIndexApi = makeIndexApi(indexingConfig, networkName, logger);
        this.enabled = indexingConfig != null && !indexingConfig.disableComposedb;
    }
    setSyncQueryApi(api) {
        if (this.databaseIndexApi) {
            this.databaseIndexApi.setSyncQueryApi(api);
        }
    }
    shouldIndexStream(args) {
        if (!this.databaseIndexApi) {
            return false;
        }
        return this.databaseIndexApi.getIndexedModels().some(function (idx) {
            return idx.streamID.equals(args);
        });
    }
    async indexStream(args) {
        if (!this.shouldIndexStream(args.model)) {
            return;
        }
        await this.databaseIndexApi.indexStream(args);
    }
    async count(query) {
        return this.databaseIndexApi.count(query);
    }
    async query(query) {
        if (!this.databaseIndexApi) {
            this.logger.warn(`Indexing is not configured. Unable to serve query ${JSON.stringify(query)}`);
            return {
                edges: [],
                pageInfo: {
                    hasNextPage: false,
                    hasPreviousPage: false,
                },
            };
        }
        const page = await this.databaseIndexApi.page(query);
        const edges = await Promise.all(page.edges.map(async (edge) => {
            const node = (await this.core.loadStreamState(edge.node)) ?? null;
            if (!node) {
                this.logger.warn(`
            Did not find stream state for streamid ${edge.node} in our state store when serving an indexed query.
            This may indicate a problem with data persistence of your state store, which can result in data loss.
            Please check that your state store is properly configured with strong persistence guarantees.
            This query may have incomplete results. Affected query: ${JSON.stringify(query)}
            `);
            }
            return {
                cursor: edge.cursor,
                node: node,
            };
        }));
        return {
            edges: edges,
            pageInfo: page.pageInfo,
        };
    }
    indexedModels() {
        return this.databaseIndexApi?.getIndexedModels() ?? [];
    }
    async convertModelDataToIndexModelsArgs(modelsNoLongerIndexed, modelData, loading = {}) {
        const modelStreamId = modelData.streamID;
        this.logger.imp(`Starting indexing for Model ${modelStreamId.toString()}`);
        const modelNoLongerIndexed = modelsNoLongerIndexed.some(function (oldIdx) {
            return oldIdx.streamID.equals(modelStreamId);
        });
        if (modelNoLongerIndexed) {
            throw new Error(`Cannot re-index model ${modelStreamId.toString()}, data may not be up-to-date`);
        }
        return await _getIndexModelArgs(modelData, this.core, loading);
    }
    async indexModels(models) {
        const modelsNoLongerIndexed = (await this.databaseIndexApi?.getModelsNoLongerIndexed()) ?? [];
        const loading = {};
        const indexModelsArgs = await Promise.all(models.map(async (idx) => {
            return await this.convertModelDataToIndexModelsArgs(modelsNoLongerIndexed, idx, loading);
        }));
        await this.databaseIndexApi?.indexModels(indexModelsArgs);
    }
    async stopIndexingModels(models) {
        this.logger.imp(`Stopping indexing for Models: ${models.map(String).join(',')}`);
        await this.databaseIndexApi?.stopIndexingModels(models);
    }
    async init() {
        if (!this.databaseIndexApi) {
            return;
        }
        await this.databaseIndexApi.init();
        const modelsToIndex = this.databaseIndexApi.getIndexedModels();
        await this.indexModels(modelsToIndex);
    }
    async close() {
        await this.databaseIndexApi?.close();
    }
}
//# sourceMappingURL=local-index-api.js.map