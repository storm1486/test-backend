import { DatabaseType, ColumnType, createConfigTable, createPostgresModelTable, createSqliteModelTable, defaultIndices, createSqliteIndices, createPostgresIndices, migrateConfigTable, } from './migrations/1-create-model-table.js';
import { asTableName } from './as-table-name.util.js';
import { Model } from '@ceramicnetwork/stream-model';
import { INDEXED_MODEL_CONFIG_TABLE_NAME, MODEL_IMPLEMENTS_TABLE_NAME, fieldsIndexName, } from './database-index-api.js';
import { STRUCTURES } from './migrations/cdb-schema-verification.js';
import { CONFIG_TABLE_NAME } from './config.js';
import { addColumnPrefix } from './column-name.util.js';
function relationsDefinitionsToColumnInfo(relations) {
    if (!relations) {
        return [];
    }
    return Object.keys(relations).map((keyName) => {
        return { name: addColumnPrefix(keyName), type: ColumnType.STRING };
    });
}
export class TablesManager {
    constructor(dbType, dataSource, logger) {
        this.dbType = dbType;
        this.dataSource = dataSource;
        this.logger = logger;
    }
    async listMidTables() {
        throw new Error('Must be implemented in extending class');
    }
    async initMidTables(_modelsToIndex) {
        throw new Error('Must be implemented in extending class');
    }
    async hasMidIndices(_tableName, _args) {
        throw new Error('Must be implemented in extending class');
    }
    hasJsonBSupport() {
        throw new Error('Must be implemented in extending class');
    }
    listConfigTables() {
        return [
            {
                tableName: INDEXED_MODEL_CONFIG_TABLE_NAME,
                validSchema: STRUCTURES[this.dbType].CONFIG_TABLE_MODEL_INDEX,
            },
            { tableName: CONFIG_TABLE_NAME, validSchema: STRUCTURES[this.dbType].CONFIG_TABLE },
            {
                tableName: MODEL_IMPLEMENTS_TABLE_NAME,
                validSchema: STRUCTURES[this.dbType].MODEL_IMPLEMENTS_TABLE,
            },
        ];
    }
    async initConfigTables(network) {
        const configTables = this.listConfigTables();
        await Promise.all(configTables.map(async (table) => {
            await this.initConfigTable(table, network);
        }));
    }
    async initConfigTable(table, network) {
        const exists = await this.dataSource.schema.hasTable(table.tableName);
        if (!exists) {
            this.logger.imp(`Creating ComposeDB config table: ${table.tableName}`);
            await createConfigTable(this.dataSource, table.tableName, network, this.hasJsonBSupport());
        }
        else {
            await migrateConfigTable(this.dataSource, table.tableName, this.hasJsonBSupport());
            if (table.tableName === CONFIG_TABLE_NAME) {
                const config = await this.dataSource
                    .from(table.tableName)
                    .where('option', 'network')
                    .first('value');
                if (config.value !== network) {
                    throw new Error(`Initialization failed for config table: ${table.tableName}. The database is configured to use the network ${config.value} but the current network is ${network}.`);
                }
            }
        }
    }
    async _verifyConfigTables() {
        const configTables = this.listConfigTables();
        await Promise.all(configTables.map(async (configTable) => {
            await this._verifyConfigTable(configTable);
        }));
    }
    async _verifyConfigTable(table) {
        const columns = await this.dataSource.table(table.tableName).columnInfo();
        const validSchema = JSON.stringify(table.validSchema);
        const actualSchema = JSON.stringify(columns);
        if (validSchema != actualSchema) {
            throw new Error(`Schema verification failed for config table: ${table.tableName}. Please make sure node has been setup correctly.`);
        }
    }
    async _verifyMidTables(modelsToIndex) {
        const tableNames = await this.listMidTables();
        await Promise.all(tableNames.map(async (tableName) => {
            await this._verifyMidTable(tableName, modelsToIndex);
        }));
    }
    async _verifyMidTable(tableName, modelsToIndex) {
        const modelIndexArgs = modelsToIndex.find((model) => tableName == asTableName(model.model));
        if (!modelIndexArgs) {
            return;
        }
        const expectedTableStructure = Object.assign({}, STRUCTURES[this.dbType].COMMON_TABLE);
        if (modelIndexArgs.relations) {
            for (const relation of Object.keys(modelIndexArgs.relations)) {
                expectedTableStructure[addColumnPrefix(relation)] = STRUCTURES[this.dbType].RELATION_COLUMN;
            }
        }
        const validSchema = JSON.stringify(expectedTableStructure);
        const columns = await this.dataSource.table(tableName).columnInfo();
        const actualSchema = JSON.stringify(columns);
        if (validSchema != actualSchema) {
            throw new Error(`Schema verification failed for index: ${tableName}. Please make sure latest migrations have been applied.`);
        }
        if (!(await this.hasMidIndices(tableName, modelIndexArgs))) {
            throw new Error(`Schema verification failed for index: ${tableName}. Please make sure latest migrations have been applied.`);
        }
    }
    async verifyTables(modelsToIndex) {
        await Promise.all([this._verifyConfigTables(), this._verifyMidTables(modelsToIndex)]);
    }
}
export class PostgresTablesManager extends TablesManager {
    constructor(dataSource, logger) {
        super(DatabaseType.POSTGRES, dataSource, logger);
    }
    async listMidTables() {
        const result = await this.dataSource
            .select('tablename')
            .from('pg_tables')
            .andWhere((q) => q.whereLike('tablename', 'kjz%').orWhere('tablename', Model.MODEL.toString()));
        return result.map((value) => value.tablename);
    }
    async initMidTables(modelsToIndex) {
        await Promise.all(modelsToIndex.map(async (modelIndexArgs) => {
            await this.initMidTable(modelIndexArgs);
        }));
    }
    async initMidTable(modelIndexArgs) {
        const tableName = asTableName(modelIndexArgs.model);
        if (tableName.length > 63) {
            const errStr = `Cannot index model ${modelIndexArgs.model.toString()}.  Table name is too long: ${tableName}`;
            this.logger.err(errStr);
            throw new Error(errStr);
        }
        const exists = await this.dataSource.schema.hasTable(tableName);
        if (!exists) {
            this.logger.imp(`Creating ComposeDB Indexing table for model: ${tableName}`);
            const relationColumns = relationsDefinitionsToColumnInfo(modelIndexArgs.relations);
            await createPostgresModelTable(this.dataSource, tableName, relationColumns);
            if (modelIndexArgs.indices) {
                await createPostgresIndices(this.dataSource, tableName, modelIndexArgs.indices);
            }
        }
    }
    async hasMidIndices(tableName, args) {
        const expectedIndices = defaultIndices(tableName).indices.flatMap((index) => index.name);
        if (args && args.indices) {
            for (const index of args.indices) {
                expectedIndices.push(fieldsIndexName(index, tableName));
            }
        }
        const sqlIndices = expectedIndices.map((s) => `'${s}'`);
        const actualIndices = await this.dataSource.raw(`
select *
from pg_indexes
where tablename like '${tableName}'
and indexname in (${sqlIndices});
  `);
        return expectedIndices.length == actualIndices.rowCount;
    }
    hasJsonBSupport() {
        return true;
    }
}
export class SqliteTablesManager extends TablesManager {
    constructor(dataSource, logger) {
        super(DatabaseType.SQLITE, dataSource, logger);
    }
    async listMidTables() {
        const result = await this.dataSource
            .from('sqlite_schema')
            .select('name')
            .whereIn('type', ['table'])
            .andWhere((q) => q.whereLike('name', 'kjz%').orWhere('name', Model.MODEL.toString()));
        return result.map((r) => r.name);
    }
    async initMidTables(modelsToIndex) {
        const existingTables = await this.listMidTables();
        await Promise.all(modelsToIndex.map(async (modelIndexArgs) => {
            await this.initMidTable(modelIndexArgs, existingTables);
        }));
    }
    async initMidTable(modelIndexArgs, existingTables) {
        const tableName = asTableName(modelIndexArgs.model);
        if (existingTables.includes(tableName)) {
            return;
        }
        this.logger.imp(`Creating ComposeDB Indexing table for model: ${tableName}`);
        const relationColumns = relationsDefinitionsToColumnInfo(modelIndexArgs.relations);
        await createSqliteModelTable(this.dataSource, tableName, relationColumns);
        if (modelIndexArgs.indices) {
            await createSqliteIndices(this.dataSource, tableName, modelIndexArgs.indices);
        }
    }
    async hasMidIndices(tableName, args) {
        const expectedIndices = defaultIndices(tableName).indices.flatMap((index) => index.name);
        if (args && args.indices) {
            for (const index of args.indices) {
                expectedIndices.push(fieldsIndexName(index, tableName));
            }
        }
        const sqlIndices = expectedIndices.map((s) => `'${s}'`);
        const actualIndices = await this.dataSource.raw(`
select name, tbl_name
FROM sqlite_master
WHERE type='index'
and tbl_name like '${tableName}'
and name in (${sqlIndices})
;
  `);
        return expectedIndices.length == actualIndices.length;
    }
    hasJsonBSupport() {
        return false;
    }
}
//# sourceMappingURL=tables-manager.js.map