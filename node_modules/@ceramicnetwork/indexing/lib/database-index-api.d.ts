import { StreamID } from '@ceramicnetwork/streamid';
import type { BaseQuery, Pagination, Page, DiagnosticsLogger, Networks, FieldsIndex, ModelData } from '@ceramicnetwork/common';
import { Knex } from 'knex';
import type { CID } from 'multiformats/cid';
import { ModelRelationsDefinition } from '@ceramicnetwork/stream-model';
import { TablesManager } from './tables-manager.js';
import { ISyncQueryApi } from './history-sync/interfaces.js';
export declare const INDEXED_MODEL_CONFIG_TABLE_NAME = "ceramic_models";
export declare const MODEL_IMPLEMENTS_TABLE_NAME = "ceramic_model_implements";
export interface IndexStreamArgs {
    readonly streamID: StreamID;
    readonly model: StreamID;
    readonly controller: string;
    readonly streamContent: Record<string, any>;
    readonly tip: CID;
    readonly lastAnchor: Date | null;
    readonly firstAnchor: Date | null;
}
export declare function fieldsIndexName(idx: FieldsIndex, table: string): string;
export interface IndexModelArgs {
    readonly model: StreamID;
    relations?: ModelRelationsDefinition;
    indices?: Array<FieldsIndex>;
    implements?: Array<string>;
}
declare type IndexedData<DateType> = {
    stream_id: string;
    controller_did: string;
    stream_content: Record<string, any> | string;
    tip: string;
    last_anchored_at: DateType | null;
    first_anchored_at: DateType | null;
    created_at?: DateType;
    updated_at: DateType;
};
export declare abstract class DatabaseIndexApi<DateType = Date | number> {
    #private;
    protected readonly dbConnection: Knex;
    private readonly allowQueriesBeforeHistoricalSync;
    private readonly logger;
    private readonly network;
    private readonly insertionOrder;
    private indexedModels;
    private readonly modelRelations;
    tablesManager: TablesManager;
    syncApi: ISyncQueryApi;
    protected constructor(dbConnection: Knex, allowQueriesBeforeHistoricalSync: boolean, logger: DiagnosticsLogger, network: Networks);
    abstract getIndexedData(indexingArgs: IndexStreamArgs & {
        createdAt?: Date;
        updatedAt?: Date;
    }): IndexedData<DateType>;
    abstract now(): DateType;
    abstract parseIndices(indices: unknown): Array<FieldsIndex>;
    setSyncQueryApi(api: ISyncQueryApi): void;
    addModelImplements(modelID: string, interfaceID: string): void;
    indexModels(models: Array<IndexModelArgs>): Promise<void>;
    private indexModelsInDatabase;
    stopIndexingModels(models: Array<ModelData>): Promise<void>;
    private stopIndexingModelsInDatabase;
    indexStream(indexingArgs: IndexStreamArgs & {
        createdAt?: Date;
        updatedAt?: Date;
    }): Promise<void>;
    getIndexedModels(): Array<ModelData>;
    private getIndexedModelsFromDatabase;
    _getInterfacesModelsFromDataBase(): Promise<Record<string, Set<string>>>;
    getModelsNoLongerIndexed(): Promise<Array<ModelData>>;
    assertModelQueryable(modelStreamId: StreamID): Promise<void>;
    _getIndexedModel(id: StreamID): ModelData | undefined;
    assertModelIsIndexed(modelStreamId: StreamID): Promise<void>;
    assertNoOngoingSyncForModel(modelStreamId: StreamID): Promise<void>;
    abstract getCountFromResult(response: Array<Record<string, string | number>>): number;
    getQueryModels(query: BaseQuery): Promise<Set<string>>;
    count(query: BaseQuery): Promise<number>;
    page(query: BaseQuery & Pagination): Promise<Page<StreamID>>;
    init(): Promise<void>;
    close(): Promise<void>;
}
export declare class PostgresIndexApi extends DatabaseIndexApi<Date> {
    constructor(dbConnection: Knex, allowQueriesBeforeHistoricalSync: boolean, logger: DiagnosticsLogger, network: Networks);
    now(): Date;
    getCountFromResult(response: Array<Record<string, string | number>>): number;
    getIndexedData(indexingArgs: IndexStreamArgs & {
        createdAt?: Date;
        updatedAt?: Date;
    }): IndexedData<Date>;
    parseIndices(indices: Array<FieldsIndex>): Array<FieldsIndex>;
}
export declare function asTimestamp(input: Date | null | undefined): number | null;
export declare class SqliteIndexApi extends DatabaseIndexApi<number> {
    constructor(dbConnection: Knex, allowQueriesBeforeHistoricalSync: boolean, logger: DiagnosticsLogger, network: Networks);
    now(): number;
    getCountFromResult(response: [Record<string, string | number>]): number;
    getIndexedData(indexingArgs: IndexStreamArgs & {
        createdAt?: Date;
        updatedAt?: Date;
    }): IndexedData<number>;
    parseIndices(indices: string): Array<FieldsIndex>;
}
export {};
//# sourceMappingURL=database-index-api.d.ts.map