import { PostgresIndexApi, SqliteIndexApi } from './database-index-api.js';
import knex from 'knex';
import * as fs from 'fs';
export class UnsupportedDatabaseProtocolError extends Error {
    constructor(protocol) {
        super(`Not supported database protocol ${protocol}`);
    }
}
class InvalidConnectionStringError extends Error {
    constructor(connectionString) {
        super(`Invalid database connection string: ${connectionString}`);
    }
}
function parseURL(input) {
    try {
        return new URL(input);
    }
    catch {
        throw new InvalidConnectionStringError(input);
    }
}
export function buildIndexing(indexingConfig, logger, network) {
    const connectionString = parseURL(indexingConfig.db);
    const protocol = connectionString.protocol.replace(/:$/, '');
    switch (protocol) {
        case 'sqlite':
        case 'sqlite3': {
            logger.imp('Initializing SQLite connection');
            if (fs) {
                fs.mkdirSync(connectionString.pathname.substring(0, connectionString.pathname.lastIndexOf('/')), { recursive: true });
            }
            const dbConnection = knex({
                client: 'sqlite3',
                useNullAsDefault: true,
                connection: {
                    filename: connectionString.pathname,
                },
            });
            return new SqliteIndexApi(dbConnection, indexingConfig.allowQueriesBeforeHistoricalSync, logger, network);
        }
        case 'postgres':
        case 'postgresql': {
            logger.imp('Initializing PostgreSQL connection');
            const dataSource = knex({
                client: 'pg',
                connection: connectionString.toString(),
                pool: { min: 0 },
            });
            return new PostgresIndexApi(dataSource, indexingConfig.allowQueriesBeforeHistoricalSync, logger, network);
        }
        default:
            throw new UnsupportedDatabaseProtocolError(protocol);
    }
}
//# sourceMappingURL=build-indexing.js.map