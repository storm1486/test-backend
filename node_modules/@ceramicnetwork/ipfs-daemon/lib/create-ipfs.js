import { path } from 'go-ipfs';
import * as Ctl from 'ipfsd-ctl';
import * as ipfsClient from 'ipfs-http-client';
import getPort from 'get-port';
import mergeOpts from 'merge-options';
import tmp from 'tmp-promise';
import { RustIpfs } from './rust-ipfs.js';
const mergeOptions = mergeOpts.bind({ ignoreUndefined: true });
const ipfsHttpModule = {
    create: (ipfsEndpoint) => {
        return ipfsClient.create({
            url: ipfsEndpoint,
        });
    },
};
const createFactory = () => {
    return Ctl.createFactory({
        ipfsHttpModule,
        ipfsOptions: {
            repoAutoMigrate: true,
        },
    }, {
        go: {
            ipfsBin: path(),
        },
    });
};
class GoRunningIpfs {
    constructor(api) {
        this._api = api;
    }
    api() {
        return this._api;
    }
    isOnline() {
        return this._api.isOnline();
    }
    async shutdown(logger) {
        return await this._api.stop();
    }
}
export async function createGoController(ipfsOptions, disposable = true) {
    const ipfsd = await createFactory().spawn({
        type: 'go',
        ipfsOptions,
        disposable,
    });
    if (disposable) {
        return ipfsd;
    }
    return ipfsd.init();
}
async function createIpfsOptions(override = {}, repoPath) {
    const swarmPort = await getPort();
    const apiPort = await getPort();
    const gatewayPort = await getPort();
    return mergeOptions({
        start: true,
        config: {
            Addresses: {
                Swarm: [`/ip4/127.0.0.1/tcp/${swarmPort}`],
                Gateway: `/ip4/127.0.0.1/tcp/${gatewayPort}`,
                API: `/ip4/127.0.0.1/tcp/${apiPort}`,
            },
            Pubsub: {
                Enabled: true,
                SeenMessagesTTL: '10m',
            },
            Bootstrap: [],
            Discovery: {
                MDNS: {
                    Enabled: false,
                },
            },
        },
    }, repoPath ? { repo: `${repoPath}/ipfs${swarmPort}/` } : {}, override);
}
export async function createIPFS(goOptions = {}, disposable = true, rustOptions = { type: 'binary' }) {
    const env_flavor = process.env.IPFS_FLAVOR || 'go';
    if (env_flavor == 'go') {
        return (await createIPFSFlavor({
            name: 'go',
            options: goOptions,
        }, disposable)).api();
    }
    else {
        return (await createIPFSFlavor({
            name: 'rust',
            options: rustOptions,
        }, disposable)).api();
    }
}
export async function createIPFSFlavor(flavor, disposable = true) {
    switch (flavor.name) {
        case 'go': {
            let options;
            let tmpFolder;
            if (flavor.options.repo) {
                options = await createIpfsOptions(flavor.options);
            }
            else {
                tmpFolder = await tmp.dir({ unsafeCleanup: true });
                options = await createIpfsOptions(flavor.options, tmpFolder.path);
            }
            const ipfsd = await createGoController(options, disposable);
            const started = await ipfsd.start();
            if (!tmpFolder) {
                return new GoRunningIpfs(started.api);
            }
            else {
                const p = new Proxy(started.api, {
                    get(target, p) {
                        if (p === 'stop') {
                            return () => {
                                const vanilla = target[p];
                                return vanilla().finally(() => tmpFolder.cleanup());
                            };
                        }
                        return target[p];
                    },
                });
                return new GoRunningIpfs(p);
            }
        }
        case 'rust': {
            const ipfs = new RustIpfs(flavor.options);
            return await ipfs.start();
        }
    }
}
export async function swarmConnect(a, b) {
    const addressB = (await b.id()).addresses[0];
    const addressA = (await a.id()).addresses[0];
    await a.swarm.connect(addressB);
    await b.swarm.connect(addressA);
}
export async function withFleet(n, task, overrideConfig = {}) {
    const factory = createFactory();
    const controllers = await Promise.all(Array.from({ length: n }).map(async () => {
        const ipfsOptions = await createIpfsOptions(overrideConfig);
        return factory.spawn({
            ipfsOptions,
        });
    }));
    const instances = controllers.map((c) => c.api);
    try {
        await task(instances);
    }
    finally {
        await factory.clean();
    }
}
//# sourceMappingURL=create-ipfs.js.map