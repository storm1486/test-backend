import getPort from 'get-port';
import tmp from 'tmp-promise';
import { create as createIpfsClient } from 'ipfs-http-client';
import { spawn } from 'child_process';
import fs from 'node:fs';
import path from 'node:path';
class BinaryRunningIpfs {
    constructor(proc, api, dir) {
        this.proc = proc;
        this.dir = dir;
        const shutdown = this.shutdown.bind(this);
        this._api = new Proxy(api, {
            get(target, p) {
                if (p === 'stop') {
                    return shutdown;
                }
                return target[p];
            },
        });
    }
    api() {
        return this._api;
    }
    async shutdown(logger) {
        try {
            this.proc.kill();
            await this.dir.cleanup();
        }
        catch (e) {
            if (logger) {
                logger.err(`Failed to shutdown binary Rust IPFS: ${e}`);
            }
        }
    }
}
async function binary(binary_path, port) {
    const bin = binary_path || process.env.CERAMIC_ONE_PATH;
    const apiPort = port || (await getPort());
    const metricsPort = await getPort();
    const dir = await tmp.dir({ unsafeCleanup: true });
    const out = fs.openSync(path.join(dir.path, '/stdout.log'), 'a');
    const err = fs.openSync(path.join(dir.path, '/stderr.log'), 'a');
    const proc = spawn(bin, [
        'daemon',
        '--bind-address',
        `127.0.0.1:${apiPort}`,
        '--store-dir',
        dir.path,
        '--metrics-bind-address',
        `127.0.0.1:${metricsPort}`,
        '--swarm-addresses',
        '/ip4/0.0.0.0/udp/0/quic-v1',
        '--network',
        'local',
        '--local-network-id',
        '0',
    ], {
        env: {
            RUST_LOG: process.env.RUST_LOG || 'info',
        },
        stdio: ['ignore', out, err],
    });
    const ipfs = createIpfsClient({
        host: '127.0.0.1',
        port: apiPort,
    });
    let ipfsOnline = false;
    while (!ipfsOnline) {
        try {
            await ipfs.id();
            ipfsOnline = true;
        }
        catch (e) {
            await new Promise((f) => setTimeout(f, 1000));
        }
    }
    return new BinaryRunningIpfs(proc, ipfs, dir);
}
class RemoteRunningIpfs {
    constructor(api) {
        this._api = api;
    }
    api() {
        return this._api;
    }
    isOnline() {
        return this._api.isOnline();
    }
    async shutdown() {
    }
}
async function remote(host, port) {
    const resolvedHost = host || 'localhost';
    const resolvedPort = port || 5001;
    const ipfs = createIpfsClient({
        host: resolvedHost,
        port: resolvedPort,
    });
    const p = new Proxy(ipfs, {
        get(target, p) {
            if (p === 'stop') {
                return () => undefined;
            }
            return target[p];
        },
    });
    return new RemoteRunningIpfs(p);
}
export class RustIpfs {
    constructor(opts) {
        this.opts = opts;
    }
    async start() {
        if (!this.api) {
            if (!this.opts.type) {
                throw new Error('Rust IPFS requires a type');
            }
            switch (this.opts.type) {
                case 'remote': {
                    this.api = await remote(this.opts.host, this.opts.port);
                    break;
                }
                case 'binary': {
                    this.api = await binary(this.opts.path, this.opts.port);
                    break;
                }
            }
        }
        return this.api;
    }
}
//# sourceMappingURL=rust-ipfs.js.map