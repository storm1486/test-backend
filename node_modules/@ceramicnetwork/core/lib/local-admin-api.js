var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _LocalAdminApi_provider;
import { convertModelIdsToModelData, } from '@ceramicnetwork/common';
import { convertCidToEthHash } from '@ceramicnetwork/anchor-utils';
export const NUMBER_OF_BLOCKS_BEFORE_TX_TO_START_SYNC = 7200;
export class LocalAdminApi {
    constructor(logger, indexApi, syncApi, nodeStatusFn, pinApi, providersCache, loadStream) {
        this.logger = logger;
        this.indexApi = indexApi;
        this.syncApi = syncApi;
        this.nodeStatusFn = nodeStatusFn;
        this.pinApi = pinApi;
        this.providersCache = providersCache;
        this.loadStream = loadStream;
        _LocalAdminApi_provider.set(this, void 0);
    }
    async nodeStatus() {
        return this.nodeStatusFn();
    }
    async startIndexingModels(modelsIDs) {
        await this.startIndexingModelData(convertModelIdsToModelData(modelsIDs));
    }
    async _getStartBlock(modelData) {
        const models = await Promise.all(modelData.map(({ streamID }) => this.loadStream(streamID)));
        const unachoredModel = models.find((model) => {
            return !model.state.log[0].timestamp;
        });
        if (unachoredModel) {
            this.logger.warn(`Detected an indexed Model without an anchor timestamp ${unachoredModel.id}. Starting historical sync at ethereum block representing the beginning of time for indexable ComposeDB Models`);
            return null;
        }
        const oldestModel = models.reduce((oldestModel, currentModel) => {
            const oldestModelTimestamp = oldestModel.state.log[0].timestamp || Infinity;
            const currentModelTimestamp = currentModel.state.log[0].timestamp || Infinity;
            if (currentModelTimestamp < oldestModelTimestamp) {
                return currentModel;
            }
            return oldestModel;
        });
        this.logger.imp(`Oldest indexed Model (${oldestModel}) was indexed at time ${oldestModel.state.log[0].timestamp}. Starting Historical Data Sync 24 hours earlier.`);
        if (!__classPrivateFieldGet(this, _LocalAdminApi_provider, "f")) {
            const nodeStatus = await this.nodeStatus();
            __classPrivateFieldSet(this, _LocalAdminApi_provider, await this.providersCache.getProvider(nodeStatus.anchor.chainId), "f");
        }
        const startTx = await __classPrivateFieldGet(this, _LocalAdminApi_provider, "f").getTransaction(convertCidToEthHash(oldestModel.state.anchorProof.txHash));
        if (!startTx.blockNumber) {
            return null;
        }
        return startTx.blockNumber - NUMBER_OF_BLOCKS_BEFORE_TX_TO_START_SYNC;
    }
    async startIndexingModelData(modelData) {
        await this.indexApi.indexModels(modelData);
        if (!this.syncApi.enabled) {
            return;
        }
        const startBlock = await this._getStartBlock(modelData);
        await this.syncApi.startModelSync(modelData.map((idx) => idx.streamID.toString()), { startBlock });
    }
    async getIndexedModels() {
        const models = await this.getIndexedModelData();
        return models.map((m) => m.streamID);
    }
    async getIndexedModelData() {
        return Promise.resolve(this.indexApi?.indexedModels() || []);
    }
    async stopIndexingModels(modelsIDs) {
        await this.stopIndexingModelData(convertModelIdsToModelData(modelsIDs));
    }
    async stopIndexingModelData(modelData) {
        await Promise.all([
            this.indexApi.stopIndexingModels(modelData),
            this.syncApi.stopModelSync(modelData.map((data) => data.streamID.toString())),
        ]);
    }
    get pin() {
        return this.pinApi;
    }
}
_LocalAdminApi_provider = new WeakMap();
//# sourceMappingURL=local-admin-api.js.map