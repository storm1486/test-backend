import type { AnchorEvent, AnchorProof, CeramicApi, FetchRequest } from '@ceramicnetwork/common';
import type { StreamID } from '@ceramicnetwork/streamid';
import type { CID } from 'multiformats/cid';
import type { CAR } from 'cartonne';
import type { AnchorRequestCarFileReader } from './anchor-request-car-file-reader.js';
import type { Observable } from 'rxjs';
export declare type AnchorLoopHandler = {
    buildRequestCar(streamId: StreamID, tip: CID): Promise<CAR>;
    handle(event: AnchorEvent): Promise<boolean>;
};
export interface AnchorService {
    readonly validator: AnchorValidator;
    init(): Promise<void>;
    ceramic: CeramicApi;
    url: string;
    requestAnchor(carFile: CAR, waitForConfirmation: boolean): Promise<Observable<AnchorEvent>>;
    getSupportedChains(): Promise<Array<string>>;
    pollForAnchorResponse(streamId: StreamID, tip: CID): Observable<AnchorEvent>;
    close(): Promise<void>;
}
export interface AuthenticatedAnchorService extends AnchorService {
    auth: AnchorServiceAuth;
}
export interface AnchorServiceAuth {
    init(): Promise<void>;
    ceramic: CeramicApi;
    sendAuthenticatedRequest: FetchRequest;
}
export interface AnchorValidator {
    chainId: string;
    ethereumRpcEndpoint: string | null;
    init(chainId: string | null): Promise<void>;
    validateChainInclusion(anchorProof: AnchorProof): Promise<number>;
}
export interface CASClient {
    supportedChains(): Promise<Array<string>>;
    create(carFileReader: AnchorRequestCarFileReader, waitForConfirmation: boolean): Promise<AnchorEvent>;
    get(streamId: StreamID, tip: CID): Promise<AnchorEvent>;
    close(): Promise<void>;
}
export declare class MultipleChainsError extends Error {
    constructor();
}
export declare class CasConnectionError extends Error {
    constructor(streamId: StreamID, tip: CID, cause: string);
}
export declare class MaxAnchorPollingError extends Error {
    constructor();
}
//# sourceMappingURL=anchor-service.d.ts.map