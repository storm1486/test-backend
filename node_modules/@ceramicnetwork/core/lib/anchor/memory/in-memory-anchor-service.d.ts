import { CID } from 'multiformats/cid';
import { Observable } from 'rxjs';
import type { AnchorCommit, AnchorEvent } from '@ceramicnetwork/common';
import type { Ceramic } from '../../ceramic.js';
import type { StreamID } from '@ceramicnetwork/streamid';
import { type CAR } from 'cartonne';
import { AnchorRequestCarFileReader } from '../anchor-request-car-file-reader.js';
import type { AnchorService, AnchorValidator } from '../anchor-service.js';
declare class Candidate {
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly key: string;
    static fromCarFileReader(reader: AnchorRequestCarFileReader): Candidate;
    constructor(streamId: StreamID, cid: CID, key: string);
}
declare type InMemoryAnchorConfig = {
    anchorDelay: number;
    anchorOnRequest: boolean;
};
export declare class InMemoryAnchorService implements AnchorService {
    #private;
    readonly chainId = "inmemory:12345";
    readonly url = "<inmemory>";
    readonly ethereumRpcEndpoint: any;
    readonly events: Observable<AnchorEvent>;
    readonly validator: AnchorValidator;
    constructor(_config?: Partial<InMemoryAnchorConfig>);
    init(): Promise<void>;
    getSupportedChains(): Promise<Array<string>>;
    anchor(): Promise<void>;
    failPendingAnchors(): Promise<void>;
    startProcessingPendingAnchors(): Promise<void>;
    _findCandidates(): Promise<Candidate[]>;
    _startProcessingCandidate(candidate: Candidate, message?: string): void;
    set ceramic(ceramic: Ceramic);
    requestAnchor(carFile: CAR, waitForConfirmation: boolean): Promise<Observable<AnchorEvent>>;
    pollForAnchorResponse(streamId: StreamID, tip: CID): Observable<AnchorEvent>;
    _publishAnchorCommit(streamId: StreamID, commit: AnchorCommit): Promise<CID>;
    _buildWitnessCAR(proofCid: CID, anchorCommitCid: CID): Promise<CAR>;
    _process(leaf: Candidate): Promise<void>;
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=in-memory-anchor-service.d.ts.map