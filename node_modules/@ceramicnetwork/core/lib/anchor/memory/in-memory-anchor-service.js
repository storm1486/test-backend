var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InMemoryAnchorService_ceramic, _InMemoryAnchorService_dispatcher, _InMemoryAnchorService_anchorDelay, _InMemoryAnchorService_anchorOnRequest, _InMemoryAnchorService_events, _InMemoryAnchorService_anchors, _InMemoryAnchorService_queue;
import { Subject, concat, of } from 'rxjs';
import { filter } from 'rxjs/operators';
import { TestUtils } from '@ceramicnetwork/common';
import { CARFactory } from 'cartonne';
import * as DAG_JOSE from 'dag-jose';
import { AnchorRequestCarFileReader } from '../anchor-request-car-file-reader.js';
import { AnchorRequestStatusName } from '@ceramicnetwork/codecs';
import { InMemoryAnchorValidator, TRANSACTION_CACHE } from './in-memory-anchor-validator.js';
const CHAIN_ID = 'inmemory:12345';
const V1_PROOF_TYPE = 'f(bytes32)';
class Candidate {
    constructor(streamId, cid, key) {
        this.streamId = streamId;
        this.cid = cid;
        this.key = key;
    }
    static fromCarFileReader(reader) {
        return new Candidate(reader.streamId, reader.tip, reader.streamId.toString());
    }
}
const carFactory = new CARFactory();
carFactory.codecs.add(DAG_JOSE);
function groupCandidatesByStreamId(candidates) {
    const result = {};
    for (const req of candidates) {
        const key = req.key;
        const items = result[key] || [];
        if (items.find((c) => c.cid.equals(req.cid))) {
            continue;
        }
        items.push(req);
        result[key] = items;
    }
    return result;
}
export class InMemoryAnchorService {
    constructor(_config = {}) {
        _InMemoryAnchorService_ceramic.set(this, void 0);
        _InMemoryAnchorService_dispatcher.set(this, void 0);
        _InMemoryAnchorService_anchorDelay.set(this, void 0);
        _InMemoryAnchorService_anchorOnRequest.set(this, void 0);
        _InMemoryAnchorService_events.set(this, void 0);
        _InMemoryAnchorService_anchors.set(this, new Map());
        _InMemoryAnchorService_queue.set(this, []);
        this.chainId = CHAIN_ID;
        this.url = '<inmemory>';
        this.ethereumRpcEndpoint = null;
        __classPrivateFieldSet(this, _InMemoryAnchorService_anchorDelay, _config.anchorDelay ?? 0, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_anchorOnRequest, _config.anchorOnRequest ?? true, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_events, new Subject(), "f");
        __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").subscribe((asr) => __classPrivateFieldGet(this, _InMemoryAnchorService_anchors, "f").set(asr.cid.toString(), asr));
        this.events = __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f");
        this.validator = new InMemoryAnchorValidator(CHAIN_ID);
    }
    async init() {
        return;
    }
    async getSupportedChains() {
        return [CHAIN_ID];
    }
    async anchor() {
        const candidates = await this._findCandidates();
        for (const candidate of candidates) {
            await this._process(candidate);
        }
        __classPrivateFieldSet(this, _InMemoryAnchorService_queue, [], "f");
    }
    async failPendingAnchors() {
        const candidates = await this._findCandidates();
        for (const candidate of candidates) {
            __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
                status: AnchorRequestStatusName.FAILED,
                streamId: candidate.streamId,
                cid: candidate.cid,
                message: 'anchor failed',
            });
        }
        __classPrivateFieldSet(this, _InMemoryAnchorService_queue, [], "f");
    }
    async startProcessingPendingAnchors() {
        const candidates = await this._findCandidates();
        for (const candidate of candidates) {
            this._startProcessingCandidate(candidate, 'anchor is being processed');
        }
        __classPrivateFieldSet(this, _InMemoryAnchorService_queue, [], "f");
    }
    async _findCandidates() {
        const groupedCandidates = groupCandidatesByStreamId(__classPrivateFieldGet(this, _InMemoryAnchorService_queue, "f"));
        return Object.values(groupedCandidates).map((candidates) => {
            const init = candidates.slice(0, candidates.length - 1);
            const last = candidates[candidates.length - 1];
            for (const replaced of init) {
                __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
                    status: AnchorRequestStatusName.REPLACED,
                    streamId: replaced.streamId,
                    cid: replaced.cid,
                    message: 'replaced',
                });
            }
            return last;
        });
    }
    _startProcessingCandidate(candidate, message) {
        if (!message) {
            message = `Processing request to anchor CID ${candidate.cid.toString()} for stream ${candidate.streamId.toString()}`;
        }
        __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
            status: AnchorRequestStatusName.PROCESSING,
            streamId: candidate.streamId,
            cid: candidate.cid,
            message,
        });
    }
    set ceramic(ceramic) {
        __classPrivateFieldSet(this, _InMemoryAnchorService_ceramic, ceramic, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_dispatcher, __classPrivateFieldGet(this, _InMemoryAnchorService_ceramic, "f").dispatcher, "f");
    }
    async requestAnchor(carFile, waitForConfirmation) {
        const carFileReader = new AnchorRequestCarFileReader(carFile);
        const candidate = Candidate.fromCarFileReader(carFileReader);
        if (__classPrivateFieldGet(this, _InMemoryAnchorService_anchorOnRequest, "f")) {
            this._process(candidate).catch((error) => {
                __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
                    status: AnchorRequestStatusName.FAILED,
                    streamId: candidate.streamId,
                    cid: candidate.cid,
                    message: error.message,
                });
            });
        }
        else {
            __classPrivateFieldGet(this, _InMemoryAnchorService_queue, "f").push(candidate);
        }
        __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
            status: AnchorRequestStatusName.PENDING,
            streamId: carFileReader.streamId,
            cid: carFileReader.tip,
            message: 'Sending anchoring request',
        });
        return this.pollForAnchorResponse(carFileReader.streamId, carFileReader.tip);
    }
    pollForAnchorResponse(streamId, tip) {
        const anchorResponse = __classPrivateFieldGet(this, _InMemoryAnchorService_anchors, "f").get(tip.toString());
        const feed$ = __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").pipe(filter((asr) => asr.streamId.equals(streamId) && asr.cid.equals(tip)));
        if (anchorResponse) {
            return concat(of(anchorResponse), feed$);
        }
        else {
            return feed$;
        }
    }
    async _publishAnchorCommit(streamId, commit) {
        const anchorCid = await __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").storeCommit(commit);
        await new Promise((resolve) => {
            __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").publishTip(streamId, anchorCid).add(resolve);
        });
        return anchorCid;
    }
    async _buildWitnessCAR(proofCid, anchorCommitCid) {
        const car = carFactory.build();
        car.blocks.put(await __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").getIpfsBlock(proofCid));
        car.blocks.put(await __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").getIpfsBlock(anchorCommitCid));
        car.roots.push(anchorCommitCid);
        return car;
    }
    async _process(leaf) {
        this._startProcessingCandidate(leaf);
        const timestamp = Math.floor(Date.now() / 1000);
        const txHashCid = TestUtils.randomCID();
        const proofData = {
            chainId: CHAIN_ID,
            txHash: txHashCid,
            root: leaf.cid,
            txType: V1_PROOF_TYPE,
        };
        TRANSACTION_CACHE.set(txHashCid.toString(), timestamp);
        const proof = await __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").storeCommit(proofData);
        const commit = { proof, path: '', prev: leaf.cid, id: leaf.streamId.cid };
        const cid = await this._publishAnchorCommit(leaf.streamId, commit);
        const witnessCar = await this._buildWitnessCAR(proof, cid);
        const handle = setTimeout(() => {
            __classPrivateFieldGet(this, _InMemoryAnchorService_events, "f").next({
                status: AnchorRequestStatusName.COMPLETED,
                streamId: leaf.streamId,
                cid: leaf.cid,
                message: 'CID successfully anchored',
                witnessCar: witnessCar,
            });
            clearTimeout(handle);
        }, __classPrivateFieldGet(this, _InMemoryAnchorService_anchorDelay, "f"));
    }
    async close() {
    }
}
_InMemoryAnchorService_ceramic = new WeakMap(), _InMemoryAnchorService_dispatcher = new WeakMap(), _InMemoryAnchorService_anchorDelay = new WeakMap(), _InMemoryAnchorService_anchorOnRequest = new WeakMap(), _InMemoryAnchorService_events = new WeakMap(), _InMemoryAnchorService_anchors = new WeakMap(), _InMemoryAnchorService_queue = new WeakMap();
//# sourceMappingURL=in-memory-anchor-service.js.map