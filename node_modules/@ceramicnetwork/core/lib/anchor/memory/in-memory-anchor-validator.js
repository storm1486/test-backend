import { LRUCache } from 'least-recent';
export const TRANSACTION_CACHE = new LRUCache(100);
class NotAnchoredError extends Error {
    constructor(txHash) {
        super(`Txn ${txHash} was not recently anchored by the InMemoryAnchorService`);
    }
}
export class InMemoryAnchorValidator {
    constructor(chainId) {
        this.ethereumRpcEndpoint = null;
        this.chainId = chainId;
    }
    async init() {
    }
    async validateChainInclusion(anchorProof) {
        const key = anchorProof.txHash.toString();
        const found = TRANSACTION_CACHE.get(key);
        if (!found) {
            throw new NotAnchoredError(anchorProof.txHash);
        }
        return found;
    }
}
//# sourceMappingURL=in-memory-anchor-validator.js.map