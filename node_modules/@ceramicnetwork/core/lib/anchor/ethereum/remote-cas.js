var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RemoteCAS_requestsApiEndpoint, _RemoteCAS_chainIdApiEndpoint, _RemoteCAS_sendRequest, _RemoteCAS_logger, _RemoteCAS_pollInterval, _RemoteCAS_maxPollTime, _RemoteCAS_stopSignal;
import { AnchorRequestStatusName, CASResponseOrError, ErrorResponse, SupportedChainsResponse, } from '@ceramicnetwork/codecs';
import { validate, isValid, decode } from 'codeco';
import { deferAbortable } from '../../ancillary/defer-abortable.js';
import { catchError, firstValueFrom, retry, Subject, takeUntil, timer } from 'rxjs';
function parseResponse(streamId, tip, json) {
    const validation = validate(CASResponseOrError, json);
    if (!isValid(validation)) {
        return {
            status: AnchorRequestStatusName.FAILED,
            streamId: streamId,
            cid: tip,
            message: `Unexpected response from CAS: ${JSON.stringify(json)}`,
        };
    }
    const parsed = validation.right;
    if (ErrorResponse.is(parsed)) {
        return {
            status: AnchorRequestStatusName.FAILED,
            streamId: streamId,
            cid: tip,
            message: parsed.error,
        };
    }
    else {
        if (parsed.status === AnchorRequestStatusName.COMPLETED) {
            return {
                status: parsed.status,
                streamId: parsed.streamId,
                cid: parsed.cid,
                message: parsed.message,
                witnessCar: parsed.witnessCar,
            };
        }
        return {
            status: parsed.status,
            streamId: parsed.streamId,
            cid: parsed.cid,
            message: parsed.message,
        };
    }
}
export class RemoteCAS {
    constructor(anchorServiceUrl, logger, pollInterval, maxPollTime, sendRequest) {
        _RemoteCAS_requestsApiEndpoint.set(this, void 0);
        _RemoteCAS_chainIdApiEndpoint.set(this, void 0);
        _RemoteCAS_sendRequest.set(this, void 0);
        _RemoteCAS_logger.set(this, void 0);
        _RemoteCAS_pollInterval.set(this, void 0);
        _RemoteCAS_maxPollTime.set(this, void 0);
        _RemoteCAS_stopSignal.set(this, void 0);
        __classPrivateFieldSet(this, _RemoteCAS_requestsApiEndpoint, anchorServiceUrl + '/api/v0/requests', "f");
        __classPrivateFieldSet(this, _RemoteCAS_chainIdApiEndpoint, anchorServiceUrl + '/api/v0/service-info/supported_chains', "f");
        __classPrivateFieldSet(this, _RemoteCAS_logger, logger, "f");
        __classPrivateFieldSet(this, _RemoteCAS_pollInterval, pollInterval, "f");
        __classPrivateFieldSet(this, _RemoteCAS_maxPollTime, maxPollTime, "f");
        __classPrivateFieldSet(this, _RemoteCAS_sendRequest, sendRequest, "f");
        __classPrivateFieldSet(this, _RemoteCAS_stopSignal, new Subject(), "f");
    }
    async supportedChains() {
        const response = await __classPrivateFieldGet(this, _RemoteCAS_sendRequest, "f").call(this, __classPrivateFieldGet(this, _RemoteCAS_chainIdApiEndpoint, "f"));
        try {
            const supportedChainsResponse = decode(SupportedChainsResponse, response);
            return supportedChainsResponse.supportedChains;
        }
        catch (error) {
            throw new Error(`SupportedChains response : ${JSON.stringify(response)} does not contain contain the field <supportedChains> or is of size more than 1: ${error}`);
        }
    }
    async create(carFileReader, waitForConfirmation) {
        const response = await firstValueFrom(this.create$(carFileReader, waitForConfirmation));
        return parseResponse(carFileReader.streamId, carFileReader.tip, response);
    }
    create$(carFileReader, shouldRetry) {
        const sendRequest$ = deferAbortable((signal) => __classPrivateFieldGet(this, _RemoteCAS_sendRequest, "f").call(this, __classPrivateFieldGet(this, _RemoteCAS_requestsApiEndpoint, "f"), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/vnd.ipld.car',
            },
            body: carFileReader.carFile.bytes,
            signal: signal,
        }));
        if (shouldRetry) {
            return sendRequest$.pipe(retry({
                delay: (error) => {
                    __classPrivateFieldGet(this, _RemoteCAS_logger, "f").warn(new Error(`Error connecting to CAS while attempting to anchor ${carFileReader.streamId} at commit ${carFileReader.tip}: ${error.message}`));
                    return timer(__classPrivateFieldGet(this, _RemoteCAS_pollInterval, "f"));
                },
            }), takeUntil(__classPrivateFieldGet(this, _RemoteCAS_stopSignal, "f")));
        }
        else {
            return sendRequest$.pipe(catchError((error) => {
                throw new Error(`Error connecting to CAS while attempting to anchor ${carFileReader.streamId} at commit ${carFileReader.tip}: ${error.message}`);
            }), takeUntil(__classPrivateFieldGet(this, _RemoteCAS_stopSignal, "f")));
        }
    }
    async get(streamId, tip) {
        const requestUrl = [__classPrivateFieldGet(this, _RemoteCAS_requestsApiEndpoint, "f"), tip.toString()].join('/');
        const sendRequest$ = deferAbortable((signal) => __classPrivateFieldGet(this, _RemoteCAS_sendRequest, "f").call(this, requestUrl, { timeout: __classPrivateFieldGet(this, _RemoteCAS_pollInterval, "f"), signal: signal }));
        const response = await firstValueFrom(sendRequest$.pipe(takeUntil(__classPrivateFieldGet(this, _RemoteCAS_stopSignal, "f"))));
        return parseResponse(streamId, tip, response);
    }
    async close() {
        __classPrivateFieldGet(this, _RemoteCAS_stopSignal, "f").next();
        __classPrivateFieldGet(this, _RemoteCAS_stopSignal, "f").complete();
    }
}
_RemoteCAS_requestsApiEndpoint = new WeakMap(), _RemoteCAS_chainIdApiEndpoint = new WeakMap(), _RemoteCAS_sendRequest = new WeakMap(), _RemoteCAS_logger = new WeakMap(), _RemoteCAS_pollInterval = new WeakMap(), _RemoteCAS_maxPollTime = new WeakMap(), _RemoteCAS_stopSignal = new WeakMap();
//# sourceMappingURL=remote-cas.js.map