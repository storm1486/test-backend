import { CID } from 'multiformats/cid';
import { CeramicApi, DiagnosticsLogger, FetchRequest, AnchorEvent } from '@ceramicnetwork/common';
import { StreamID } from '@ceramicnetwork/streamid';
import { Observable } from 'rxjs';
import { CAR } from 'cartonne';
import type { AnchorService, AnchorServiceAuth, AnchorValidator, AuthenticatedAnchorService } from '../anchor-service.js';
export declare class EthereumAnchorService implements AnchorService {
    #private;
    readonly anchorServiceUrl: string;
    readonly url: string;
    readonly events: Observable<AnchorEvent>;
    readonly validator: AnchorValidator;
    constructor(anchorServiceUrl: string, ethereumRpcUrl: string | undefined, logger: DiagnosticsLogger, pollInterval?: number, maxPollTime?: number, sendRequest?: FetchRequest);
    set ceramic(ceramic: CeramicApi);
    init(): Promise<void>;
    requestAnchor(carFile: CAR, waitForConfirmation: boolean): Promise<Observable<AnchorEvent>>;
    getSupportedChains(): Promise<Array<string>>;
    private _makeAnchorRequest;
    pollForAnchorResponse(streamId: StreamID, tip: CID): Observable<AnchorEvent>;
    private _parseResponse;
    private _updateEvents;
    close(): Promise<void>;
}
export declare class AuthenticatedEthereumAnchorService extends EthereumAnchorService implements AuthenticatedAnchorService {
    readonly auth: AnchorServiceAuth;
    constructor(auth: AnchorServiceAuth, anchorServiceUrl: string, ethereumRpcUrl: string | undefined, logger: DiagnosticsLogger, pollInterval?: number, maxPollTime?: number);
    set ceramic(ceramic: CeramicApi);
    init(): Promise<void>;
}
//# sourceMappingURL=ethereum-anchor-service.d.ts.map