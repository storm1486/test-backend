var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EthereumAnchorService_logger, _EthereumAnchorService_pollInterval, _EthereumAnchorService_maxPollTime, _EthereumAnchorService_events, _EthereumAnchorService_cas, _EthereumAnchorService_chainId;
import { fetchJson, } from '@ceramicnetwork/common';
import { concat, timer, of, defer, expand, lastValueFrom, Subject, } from 'rxjs';
import { concatMap, catchError, map, retry, tap } from 'rxjs/operators';
import { AnchorRequestCarFileReader } from '../anchor-request-car-file-reader.js';
import { CASResponseOrError, ErrorResponse, AnchorRequestStatusName } from '@ceramicnetwork/codecs';
import { decode } from 'codeco';
import { EthereumAnchorValidator } from './ethereum-anchor-validator.js';
import { CasConnectionError, MaxAnchorPollingError } from '../anchor-service.js';
import { RemoteCAS } from './remote-cas.js';
const DEFAULT_POLL_INTERVAL = 60000;
const MAX_POLL_TIME = 86400000;
function parseResponse(streamId, tip, json) {
    const parsed = decode(CASResponseOrError, json);
    if (ErrorResponse.is(parsed)) {
        return {
            status: AnchorRequestStatusName.FAILED,
            streamId: streamId,
            cid: tip,
            message: parsed.error,
        };
    }
    else {
        if (parsed.status === AnchorRequestStatusName.COMPLETED) {
            return {
                status: parsed.status,
                streamId: parsed.streamId,
                cid: parsed.cid,
                message: parsed.message,
                witnessCar: parsed.witnessCar,
            };
        }
        return {
            status: parsed.status,
            streamId: parsed.streamId,
            cid: parsed.cid,
            message: parsed.message,
        };
    }
}
function announcePending(streamId, tip) {
    return of({
        status: AnchorRequestStatusName.PENDING,
        streamId: streamId,
        cid: tip,
        message: 'Sending anchoring request',
    });
}
export class EthereumAnchorService {
    constructor(anchorServiceUrl, ethereumRpcUrl, logger, pollInterval = DEFAULT_POLL_INTERVAL, maxPollTime = MAX_POLL_TIME, sendRequest = fetchJson) {
        this.anchorServiceUrl = anchorServiceUrl;
        _EthereumAnchorService_logger.set(this, void 0);
        _EthereumAnchorService_pollInterval.set(this, void 0);
        _EthereumAnchorService_maxPollTime.set(this, void 0);
        _EthereumAnchorService_events.set(this, void 0);
        _EthereumAnchorService_cas.set(this, void 0);
        _EthereumAnchorService_chainId.set(this, void 0);
        __classPrivateFieldSet(this, _EthereumAnchorService_logger, logger, "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_pollInterval, pollInterval, "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_maxPollTime, maxPollTime, "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_events, new Subject(), "f");
        this.events = __classPrivateFieldGet(this, _EthereumAnchorService_events, "f");
        this.url = this.anchorServiceUrl;
        this.validator = new EthereumAnchorValidator(ethereumRpcUrl, logger);
        __classPrivateFieldSet(this, _EthereumAnchorService_cas, new RemoteCAS(anchorServiceUrl, logger, pollInterval, maxPollTime, sendRequest), "f");
    }
    set ceramic(ceramic) {
    }
    async init() {
        const supportedChains = await __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").supportedChains();
        __classPrivateFieldSet(this, _EthereumAnchorService_chainId, supportedChains[0], "f");
        await this.validator.init(__classPrivateFieldGet(this, _EthereumAnchorService_chainId, "f"));
    }
    async requestAnchor(carFile, waitForConfirmation) {
        const carFileReader = new AnchorRequestCarFileReader(carFile);
        const streamId = carFileReader.streamId;
        const tip = carFileReader.tip;
        const requestCreated$ = concat(announcePending(streamId, tip), this._makeAnchorRequest(carFileReader, !waitForConfirmation));
        const anchorCompleted$ = this.pollForAnchorResponse(streamId, tip);
        const errHandler = (error) => of({
            status: AnchorRequestStatusName.FAILED,
            streamId: streamId,
            cid: tip,
            message: error.message,
        });
        if (waitForConfirmation) {
            await lastValueFrom(requestCreated$);
            return anchorCompleted$.pipe(catchError(errHandler));
        }
        else {
            return concat(requestCreated$, anchorCompleted$).pipe(catchError(errHandler));
        }
    }
    async getSupportedChains() {
        return [__classPrivateFieldGet(this, _EthereumAnchorService_chainId, "f")];
    }
    _makeAnchorRequest(carFileReader, shouldRetry) {
        const sendRequest$ = __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").create$(carFileReader, shouldRetry);
        return sendRequest$.pipe(this._parseResponse(carFileReader.streamId, carFileReader.tip));
    }
    pollForAnchorResponse(streamId, tip) {
        const started = new Date().getTime();
        const maxTime = started + __classPrivateFieldGet(this, _EthereumAnchorService_maxPollTime, "f");
        const requestWithError = defer(() => __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").get(streamId, tip)).pipe(retry({
            delay: (error) => {
                __classPrivateFieldGet(this, _EthereumAnchorService_logger, "f").warn(new CasConnectionError(streamId, tip, error.message));
                return timer(__classPrivateFieldGet(this, _EthereumAnchorService_pollInterval, "f"));
            },
        }));
        return requestWithError.pipe(expand(() => {
            const now = new Date().getTime();
            if (now > maxTime) {
                throw new MaxAnchorPollingError();
            }
            else {
                return timer(__classPrivateFieldGet(this, _EthereumAnchorService_pollInterval, "f")).pipe(concatMap(() => requestWithError));
            }
        }), this._updateEvents());
    }
    _parseResponse(streamId, tip) {
        return map((response) => parseResponse(streamId, tip, response));
    }
    _updateEvents() {
        return tap((event) => __classPrivateFieldGet(this, _EthereumAnchorService_events, "f").next(event));
    }
    async close() {
        await __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").close();
    }
}
_EthereumAnchorService_logger = new WeakMap(), _EthereumAnchorService_pollInterval = new WeakMap(), _EthereumAnchorService_maxPollTime = new WeakMap(), _EthereumAnchorService_events = new WeakMap(), _EthereumAnchorService_cas = new WeakMap(), _EthereumAnchorService_chainId = new WeakMap();
export class AuthenticatedEthereumAnchorService extends EthereumAnchorService {
    constructor(auth, anchorServiceUrl, ethereumRpcUrl, logger, pollInterval = DEFAULT_POLL_INTERVAL, maxPollTime = MAX_POLL_TIME) {
        super(anchorServiceUrl, ethereumRpcUrl, logger, pollInterval, maxPollTime, auth.sendAuthenticatedRequest.bind(auth));
        this.auth = auth;
    }
    set ceramic(ceramic) {
        this.auth.ceramic = ceramic;
    }
    async init() {
        await this.auth.init();
        await super.init();
    }
}
//# sourceMappingURL=ethereum-anchor-service.js.map