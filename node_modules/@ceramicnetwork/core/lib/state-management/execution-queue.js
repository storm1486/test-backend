import { NamedTaskQueue } from './named-task-queue.js';
import { Semaphore } from 'await-semaphore';
export class ExecutionQueue {
    constructor(name, concurrencyLimit, logger) {
        this.name = name;
        this.concurrencyLimit = concurrencyLimit;
        this.logger = logger;
        this.tasks = new NamedTaskQueue((error) => {
            logger.err(error);
        });
        this.semaphore = new Semaphore(concurrencyLimit);
    }
    forStream(streamId) {
        return {
            add: (task) => {
                return this.tasks.add(streamId.toString(), () => {
                    if (this.semaphore.count == 0) {
                        this.logger.warn(`${this.name} queue is full, over ${this.concurrencyLimit} pending requests found`);
                    }
                    return this.semaphore.use(() => task());
                });
            },
            run: (task) => {
                return this.tasks.run(streamId.toString(), () => {
                    if (this.semaphore.count == 0) {
                        this.logger.warn(`${this.name} queue is full, over ${this.concurrencyLimit} pending requests found`);
                    }
                    return this.semaphore.use(() => task());
                });
            },
        };
    }
    onIdle() {
        return this.tasks.onIdle();
    }
    pause() {
        this.tasks.pause();
    }
    async close() {
        await this.onIdle();
        this.pause();
    }
}
//# sourceMappingURL=execution-queue.js.map