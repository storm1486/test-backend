var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Repository_deps, _Repository_syncedPinnedStreams, _Repository_numPendingAnchorSubscriptions;
import { CommitID, StreamID } from '@ceramicnetwork/streamid';
import { AnchorStatus, CommitType, StreamUtils, SyncOptions, UnreachableCaseError, } from '@ceramicnetwork/common';
import { ExecutionQueue } from './execution-queue.js';
import { RunningState } from './running-state.js';
import { catchError, EMPTY, Observable, Subject, takeUntil, concatMap } from 'rxjs';
import { StateCache } from './state-cache.js';
import { SnapshotState } from './snapshot-state.js';
import { ServiceMetrics as Metrics } from '@ceramicnetwork/observability';
import { OperationType } from './operation-type.js';
import { AnchorRequestStatusName } from '@ceramicnetwork/codecs';
const DEFAULT_LOAD_OPTS = { sync: SyncOptions.PREFER_CACHE, syncTimeoutSeconds: 3 };
const APPLY_ANCHOR_COMMIT_ATTEMPTS = 3;
const CACHE_EVICTED_MEMORY = 'cache_eviction_memory';
const CACHE_HIT_LOCAL = 'cache_hit_local';
const CACHE_HIT_MEMORY = 'cache_hit_memory';
const CACHE_HIT_REMOTE = 'cache_hit_remote';
const STREAM_SYNC = 'stream_sync';
const ANCHOR_POLL_COUNT = 'anchor_poll_count';
function shouldIndex(state$, index) {
    const model = state$.state?.metadata?.model;
    if (!model)
        return false;
    return index.shouldIndexStream(model);
}
function commitAtTime(state, timestamp) {
    let commitCid = state.log[0].cid;
    for (const entry of state.log) {
        if (entry.type === CommitType.ANCHOR) {
            if (entry.timestamp <= timestamp) {
                commitCid = entry.cid;
            }
            else {
                break;
            }
        }
    }
    return CommitID.make(StreamUtils.streamIdFromState(state), commitCid);
}
var SyncStatus;
(function (SyncStatus) {
    SyncStatus[SyncStatus["NOT_SYNCED"] = 0] = "NOT_SYNCED";
    SyncStatus[SyncStatus["ALREADY_SYNCED"] = 1] = "ALREADY_SYNCED";
    SyncStatus[SyncStatus["DID_SYNC"] = 2] = "DID_SYNC";
})(SyncStatus || (SyncStatus = {}));
export class Repository {
    constructor(cacheLimit, concurrencyLimit, logger) {
        this.logger = logger;
        _Repository_deps.set(this, void 0);
        _Repository_syncedPinnedStreams.set(this, new Set());
        _Repository_numPendingAnchorSubscriptions.set(this, 0);
        this.loadingQ = new ExecutionQueue('loading', concurrencyLimit, logger);
        this.executionQ = new ExecutionQueue('execution', concurrencyLimit, logger);
        this.inmemory = new StateCache(cacheLimit, (state$) => {
            if (state$.subscriptionSet.size > 0) {
                logger.debug(`Stream ${state$.id} evicted from cache while having subscriptions`);
            }
            Metrics.count(CACHE_EVICTED_MEMORY, 1);
            state$.complete();
        });
        this.updates$ = this.updates$.bind(this);
    }
    async injectKeyValueStore(stateStore) {
        this.setDeps({
            ...__classPrivateFieldGet(this, _Repository_deps, "f"),
            keyValueStore: stateStore,
        });
    }
    async init() {
        await __classPrivateFieldGet(this, _Repository_deps, "f").keyValueStore.init();
        await this.pinStore.open(__classPrivateFieldGet(this, _Repository_deps, "f").keyValueStore);
        await this.anchorRequestStore.open(__classPrivateFieldGet(this, _Repository_deps, "f").keyValueStore);
        await this.index.init();
    }
    get pinStore() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore;
    }
    get streamLoader() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").streamLoader;
    }
    get streamUpdater() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").streamUpdater;
    }
    get numPendingAnchors() {
        return __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f");
    }
    get anchorService() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").anchorService;
    }
    get dispatcher() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").dispatcher;
    }
    get anchorRequestStore() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").anchorRequestStore;
    }
    get index() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").indexing;
    }
    setDeps(deps) {
        __classPrivateFieldSet(this, _Repository_deps, deps, "f");
    }
    async load(streamId, loadOptions = {}, checkCacaoExpiration = true) {
        const opts = { ...DEFAULT_LOAD_OPTS, ...loadOptions };
        const [state$, syncStatus] = await this.loadingQ.forStream(streamId).run(async () => {
            const [existingState$, alreadySynced] = await this._fromMemoryOrStoreWithSyncStatus(streamId);
            switch (opts.sync) {
                case SyncOptions.PREFER_CACHE:
                case SyncOptions.SYNC_ON_ERROR: {
                    if (!existingState$) {
                        return [
                            await this._loadStreamFromNetwork(streamId, opts.syncTimeoutSeconds),
                            SyncStatus.DID_SYNC,
                        ];
                    }
                    if (alreadySynced == SyncStatus.ALREADY_SYNCED) {
                        return [existingState$, SyncStatus.ALREADY_SYNCED];
                    }
                    else {
                        await this._sync(existingState$, opts.syncTimeoutSeconds);
                        return [existingState$, SyncStatus.DID_SYNC];
                    }
                }
                case SyncOptions.NEVER_SYNC: {
                    if (existingState$) {
                        return [existingState$, alreadySynced];
                    }
                    return [await this._genesisFromNetwork(streamId), SyncStatus.NOT_SYNCED];
                }
                case SyncOptions.SYNC_ALWAYS: {
                    return [
                        await this._resyncStreamFromNetwork(streamId, opts.syncTimeoutSeconds, existingState$),
                        SyncStatus.DID_SYNC,
                    ];
                }
                default:
                    throw new UnreachableCaseError(opts.sync, 'Invalid sync option');
            }
        });
        if (checkCacaoExpiration) {
            StreamUtils.checkForCacaoExpiration(state$.state);
        }
        if (syncStatus != SyncStatus.ALREADY_SYNCED) {
            await this._updateStateIfPinned(state$);
            if (syncStatus == SyncStatus.DID_SYNC && state$.isPinned) {
                this.markPinnedAndSynced(state$.id);
            }
        }
        return state$;
    }
    async _updateStateIfPinned(state$) {
        const isPinned = Boolean(await this.pinStore.stateStore.load(state$.id));
        const shouldIndex = state$.state.metadata.model && this.index.shouldIndexStream(state$.state.metadata.model);
        if (isPinned || shouldIndex) {
            await this.pinStore.add(state$);
        }
        await this._indexStreamIfNeeded(state$);
    }
    _fromMemory(streamId) {
        const state = this.inmemory.get(streamId.toString());
        if (state) {
            Metrics.count(CACHE_HIT_MEMORY, 1);
        }
        return state;
    }
    async _fromStreamStateStore(streamId) {
        const streamState = await this.pinStore.stateStore.load(streamId);
        if (streamState) {
            Metrics.count(CACHE_HIT_LOCAL, 1);
            const runningState = new RunningState(streamState, true);
            this._registerRunningState(runningState);
            const storedRequest = await this.anchorRequestStore.load(streamId);
            if (storedRequest !== null && this.anchorService) {
                await this._confirmAnchorResponse(runningState, storedRequest.cid);
            }
            return runningState;
        }
        else {
            return undefined;
        }
    }
    async _fromMemoryOrStore(streamId) {
        const fromMemory = this._fromMemory(streamId);
        if (fromMemory)
            return fromMemory;
        return this._fromStreamStateStore(streamId);
    }
    async _fromMemoryOrStoreWithSyncStatus(streamId) {
        let stream = this._fromMemory(streamId);
        if (stream) {
            return [stream, SyncStatus.ALREADY_SYNCED];
        }
        stream = await this._fromStreamStateStore(streamId);
        if (stream) {
            return [
                stream,
                this._wasPinnedStreamSynced(streamId) ? SyncStatus.ALREADY_SYNCED : SyncStatus.NOT_SYNCED,
            ];
        }
        return [null, SyncStatus.NOT_SYNCED];
    }
    async _loadStreamFromNetwork(streamId, syncTimeoutSeconds) {
        const state = await this.streamLoader.loadStream(streamId, syncTimeoutSeconds);
        Metrics.count(STREAM_SYNC, 1);
        const newState$ = new RunningState(state, false);
        this._registerRunningState(newState$);
        return newState$;
    }
    async _genesisFromNetwork(streamId) {
        const state = await this.streamLoader.loadGenesisState(streamId);
        Metrics.count(CACHE_HIT_REMOTE, 1);
        const state$ = new RunningState(state, false);
        this._registerRunningState(state$);
        this.logger.verbose(`Genesis commit for stream ${streamId.toString()} successfully loaded`);
        return state$;
    }
    async _sync(state$, syncTimeoutSeconds) {
        const syncedState = await this.streamLoader.syncStream(state$.state, syncTimeoutSeconds);
        state$.next(syncedState);
        Metrics.count(STREAM_SYNC, 1);
    }
    async _resyncStreamFromNetwork(streamId, syncTimeoutSeconds, existingState$) {
        const resyncedState = existingState$
            ? await this.streamLoader.resyncStream(streamId, existingState$.tip, syncTimeoutSeconds)
            : await this.streamLoader.loadStream(streamId, syncTimeoutSeconds);
        Metrics.count(STREAM_SYNC, 1);
        const newState$ = new RunningState(resyncedState, false);
        this._registerRunningState(newState$);
        return newState$;
    }
    async loadAtCommit(commitId, opts) {
        const base$ = await this.load(commitId.baseID, opts, false);
        return this._atCommit(commitId, base$);
    }
    async _atCommit(commitId, existingState$) {
        return this.executionQ.forStream(commitId).run(async () => {
            const stateAtCommit = await this.streamLoader.stateAtCommit(existingState$.state, commitId);
            StreamUtils.checkForCacaoExpiration(stateAtCommit);
            if (StreamUtils.isStateSupersetOf(stateAtCommit, existingState$.value)) {
                existingState$.next(stateAtCommit);
            }
            return new SnapshotState(stateAtCommit);
        });
    }
    async loadAtTime(streamId, opts) {
        const base$ = await this.load(streamId.baseID, opts);
        const commitId = commitAtTime(base$.state, opts.atTime);
        return this._atCommit(commitId, base$);
    }
    async applyCommit(streamId, commit, opts) {
        this.logger.verbose(`Repository apply commit to stream ${streamId.toString()}`);
        const state$ = await this.load(streamId);
        this.logger.verbose(`Repository loaded state for stream ${streamId.toString()}`);
        return this.executionQ.forStream(streamId).run(async () => {
            const originalState = state$.state;
            const updatedState = await this.streamUpdater.applyCommitFromUser(originalState, commit);
            if (StreamUtils.tipFromState(updatedState).equals(StreamUtils.tipFromState(originalState))) {
                return state$;
            }
            state$.next(updatedState);
            await this._updateStateIfPinned(state$);
            await this._applyWriteOpts(state$, opts, OperationType.UPDATE);
            this.logger.verbose(`Stream ${state$.id} successfully updated to tip ${state$.tip}`);
            return state$;
        });
    }
    async handleUpdateFromNetwork(streamId, tip, model) {
        let state$ = await this._fromMemoryOrStore(streamId);
        const shouldIndex = model && this.index.shouldIndexStream(model);
        if (!shouldIndex && !state$) {
            return;
        }
        if (!state$) {
            state$ = await this.load(streamId);
        }
        await this._handleTip(state$, tip);
    }
    async _handleTip(state$, cid) {
        return this.executionQ.forStream(state$.id).run(async () => {
            this.logger.verbose(`Learned of new tip ${cid} for stream ${state$.id}`);
            const next = await this.streamUpdater.applyTipFromNetwork(state$.state, cid);
            if (next) {
                state$.next(next);
                await this._updateStateIfPinned(state$);
                this.logger.verbose(`Stream ${state$.id} successfully updated to tip ${cid}`);
                return true;
            }
            else {
                return false;
            }
        });
    }
    async anchor(state$, opts) {
        if (!this.anchorService) {
            throw new Error(`Anchor requested for stream ${state$.id} but anchoring is disabled`);
        }
        if (state$.value.anchorStatus == AnchorStatus.ANCHORED) {
            return;
        }
        const carFile = await __classPrivateFieldGet(this, _Repository_deps, "f").anchorRequestCarBuilder.build(state$.id, state$.tip);
        const genesisCID = state$.value.log[0].cid;
        const genesisCommit = carFile.get(genesisCID);
        await this.anchorRequestStore.save(state$.id, {
            cid: state$.tip,
            timestamp: Date.now(),
            genesis: genesisCommit,
        });
        const anchorStatus$ = await this.anchorService.requestAnchor(carFile, opts.waitForAnchorConfirmation);
        return this._processAnchorResponse(state$, anchorStatus$);
    }
    async _cleanUpStaleAnchorRequestStore(state$, commit) {
        return this.executionQ.forStream(state$.id).run(async () => {
            const request = await this.anchorRequestStore.load(state$.id);
            if (!request.cid.equals(commit)) {
                return;
            }
            if (state$.state.anchorStatus == AnchorStatus.ANCHORED &&
                StreamUtils.stateContainsCommit(state$.state, commit)) {
                await this.anchorRequestStore.remove(state$.id);
            }
        });
    }
    async _confirmAnchorResponse(state$, cid) {
        if (state$.state.anchorStatus == AnchorStatus.ANCHORED &&
            StreamUtils.stateContainsCommit(state$.state, cid)) {
            await this._cleanUpStaleAnchorRequestStore(state$, cid);
        }
        const anchorStatus$ = this.anchorService.pollForAnchorResponse(state$.id, cid);
        return this._processAnchorResponse(state$, anchorStatus$);
    }
    async _handleAnchorResponse(state$, anchorEvent) {
        const status = anchorEvent.status;
        switch (status) {
            case AnchorRequestStatusName.READY:
            case AnchorRequestStatusName.PENDING: {
                if (!anchorEvent.cid.equals(state$.tip))
                    return;
                const next = {
                    ...state$.value,
                    anchorStatus: AnchorStatus.PENDING,
                };
                state$.next(next);
                await this._updateStateIfPinned(state$);
                return false;
            }
            case AnchorRequestStatusName.PROCESSING: {
                if (!anchorEvent.cid.equals(state$.tip))
                    return;
                state$.next({ ...state$.value, anchorStatus: AnchorStatus.PROCESSING });
                await this._updateStateIfPinned(state$);
                return false;
            }
            case AnchorRequestStatusName.COMPLETED: {
                const anchorCommitCID = anchorEvent.witnessCar.roots[0];
                await this._handleAnchorCommit(state$, anchorEvent.cid, anchorEvent.witnessCar);
                if (state$.tip.equals(anchorCommitCID)) {
                    await this.anchorRequestStore.remove(state$.id);
                }
                return true;
            }
            case AnchorRequestStatusName.FAILED: {
                this.logger.warn(`Anchor failed for commit ${anchorEvent.cid} of stream ${anchorEvent.streamId}: ${anchorEvent.message}`);
                if (anchorEvent.cid.equals(state$.tip)) {
                    state$.next({ ...state$.value, anchorStatus: AnchorStatus.FAILED });
                    await this.anchorRequestStore.remove(state$.id);
                }
                return true;
            }
            case AnchorRequestStatusName.REPLACED: {
                this.logger.verbose(`Anchor request for commit ${anchorEvent.cid} of stream ${anchorEvent.streamId} is replaced`);
                if (anchorEvent.cid.equals(state$.tip)) {
                    await this.anchorRequestStore.remove(state$.id);
                }
                return true;
            }
            default:
                throw new UnreachableCaseError(status, 'Unknown anchoring state');
        }
    }
    _processAnchorResponse(state$, anchorStatus$) {
        var _a;
        const stopSignal = new Subject();
        __classPrivateFieldSet(this, _Repository_numPendingAnchorSubscriptions, (_a = __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"), _a++, _a), "f");
        Metrics.observe(ANCHOR_POLL_COUNT, __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"));
        const subscription = anchorStatus$
            .pipe(takeUntil(stopSignal), concatMap(async (anchorEvent) => {
            const shouldStop = await this._handleAnchorResponse(state$, anchorEvent);
            if (shouldStop)
                stopSignal.next();
        }), catchError((error) => {
            this.logger.warn(`Error while anchoring stream ${state$.id}:${error}`);
            this.logger.warn(error);
            return EMPTY;
        }))
            .subscribe(null, (err) => {
            var _a;
            __classPrivateFieldSet(this, _Repository_numPendingAnchorSubscriptions, (_a = __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"), _a--, _a), "f");
            Metrics.observe(ANCHOR_POLL_COUNT, __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"));
            throw err;
        }, () => {
            var _a;
            __classPrivateFieldSet(this, _Repository_numPendingAnchorSubscriptions, (_a = __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"), _a--, _a), "f");
            Metrics.observe(ANCHOR_POLL_COUNT, __classPrivateFieldGet(this, _Repository_numPendingAnchorSubscriptions, "f"));
        });
        state$.add(subscription);
        return subscription;
    }
    async _handleAnchorCommit(state$, tip, witnessCAR) {
        const streamId = StreamUtils.streamIdFromState(state$.state);
        const anchorCommitCID = witnessCAR.roots[0];
        if (!anchorCommitCID)
            throw new Error(`No anchor commit CID as root`);
        this.logger.verbose(`Handling anchor commit for ${streamId} with CID ${anchorCommitCID}`);
        for (let remainingRetries = APPLY_ANCHOR_COMMIT_ATTEMPTS - 1; remainingRetries >= 0; remainingRetries--) {
            try {
                if (witnessCAR) {
                    await this.dispatcher.importCAR(witnessCAR);
                    this.logger.verbose(`successfully imported CAR file for ${streamId}`);
                }
                const applied = await this._handleTip(state$, anchorCommitCID);
                if (applied) {
                    this._publishTip(state$);
                    if (remainingRetries < APPLY_ANCHOR_COMMIT_ATTEMPTS - 1) {
                        this.logger.imp(`Successfully applied anchor commit ${anchorCommitCID} for stream ${state$.id} after ${APPLY_ANCHOR_COMMIT_ATTEMPTS - remainingRetries} attempts`);
                    }
                    else {
                        this.logger.verbose(`Successfully applied anchor commit ${anchorCommitCID} for stream ${state$.id}`);
                    }
                }
                return;
            }
            catch (error) {
                this.logger.warn(`Error while applying anchor commit ${anchorCommitCID} for stream ${state$.id}, ${remainingRetries} retries remain. ${error}`);
                if (remainingRetries == 0) {
                    this.logger.err(`Anchor failed for commit ${tip} of stream ${state$.id}: ${error}`);
                    if (tip.equals(state$.tip)) {
                        state$.next({ ...state$.value, anchorStatus: AnchorStatus.FAILED });
                    }
                }
            }
        }
    }
    async _applyWriteOpts(state$, opts, opType) {
        const anchor = opts.anchor;
        const publish = opts.publish;
        if (anchor) {
            await this.anchor(state$, opts);
        }
        if (publish && opType !== OperationType.LOAD) {
            this._publishTip(state$);
        }
        await this._handlePinOpts(state$, opts, opType);
    }
    _publishTip(state$) {
        this.dispatcher.publishTip(state$.id, state$.tip, state$.state.metadata.model);
    }
    async _handlePinOpts(state$, opts, opType) {
        if (opts.pin !== undefined && opType !== OperationType.CREATE) {
            const pinStr = opts.pin ? 'pin' : 'unpin';
            const opStr = opType == OperationType.UPDATE ? 'update' : 'load';
            this.logger.warn(`Cannot pin or unpin streams through the CRUD APIs. To change stream pin state use the admin.pin API with an authenticated admin DID. Attempting to ${pinStr} stream ${StreamUtils.streamIdFromState(state$.state).toString()} as part of a ${opStr} operation`);
            return;
        }
        if (opts.pin ||
            (opts.pin === undefined && shouldIndex(state$, this.index)) ||
            (opts.pin === undefined && opType == OperationType.CREATE)) {
            await this.pin(state$);
        }
        else if (opts.pin === false) {
            await this.unpin(state$);
        }
    }
    async applyCreateOpts(streamId, opts) {
        const state = await this.load(streamId, opts);
        const opType = state.state.log.length == 1 ? OperationType.CREATE : OperationType.LOAD;
        await this._applyWriteOpts(state, opts, opType);
        return state;
    }
    async fromMemoryOrStore(streamId) {
        return await this._fromMemoryOrStore(streamId);
    }
    async streamState(streamId) {
        const fromMemory = this.inmemory.get(streamId.toString());
        if (fromMemory) {
            return fromMemory.state;
        }
        else {
            return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.stateStore.load(streamId);
        }
    }
    _registerRunningState(state$) {
        this.inmemory.set(state$.id.toString(), state$);
    }
    pin(state$, force) {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.add(state$, force);
    }
    async unpin(state$, opts) {
        if (shouldIndex(state$, this.index)) {
            throw new Error(`Cannot unpin actively indexed stream (${state$.id.toString()}) with model: ${state$.state.metadata.model}`);
        }
        if (opts?.publish) {
            this._publishTip(state$);
        }
        this.markUnpinned(state$.id);
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.rm(state$);
    }
    async listPinned(streamId) {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.ls(streamId);
    }
    markPinnedAndSynced(streamId) {
        __classPrivateFieldGet(this, _Repository_syncedPinnedStreams, "f").add(streamId.toString());
    }
    markUnpinned(streamId) {
        __classPrivateFieldGet(this, _Repository_syncedPinnedStreams, "f").delete(streamId.toString());
    }
    _wasPinnedStreamSynced(streamId) {
        return __classPrivateFieldGet(this, _Repository_syncedPinnedStreams, "f").has(streamId.toString());
    }
    async randomPinnedStreamState() {
        const res = await __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.stateStore.listStoredStreamIDs(null, 1);
        if (res.length == 0) {
            return null;
        }
        if (res.length > 1) {
            throw new Error(`Expected a single streamID from the state store, but got ${res.length} streamIDs instead`);
        }
        const [streamID] = res;
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.stateStore.load(StreamID.fromString(streamID));
    }
    async _indexStreamIfNeeded(state$) {
        if (!state$.value.metadata.model) {
            return;
        }
        const asDate = (unixTimestamp) => {
            return unixTimestamp ? new Date(unixTimestamp * 1000) : null;
        };
        const lastAnchor = asDate(StreamUtils.anchorTimestampFromState(state$.value));
        const firstAnchor = asDate(state$.value.log.find((log) => log.type == CommitType.ANCHOR)?.timestamp);
        const streamContent = {
            model: state$.value.metadata.model,
            streamID: state$.id,
            controller: state$.value.metadata.controllers[0],
            streamContent: state$.value.content,
            tip: state$.tip,
            lastAnchor: lastAnchor,
            firstAnchor: firstAnchor,
        };
        await this.index.indexStream(streamContent);
    }
    updates$(init) {
        return new Observable((subscriber) => {
            const id = new StreamID(init.type, init.log[0].cid);
            this.fromMemoryOrStore(id).then((found) => {
                const state$ = found || new RunningState(init, false);
                this.inmemory.endure(id.toString(), state$);
                state$.subscribe(subscriber).add(() => {
                    if (state$.observers.length === 0) {
                        this.inmemory.free(id.toString());
                    }
                });
            });
        });
    }
    async close() {
        await this.loadingQ.close();
        await this.executionQ.close();
        Array.from(this.inmemory).forEach(([id, stream]) => {
            this.inmemory.delete(id);
            stream.complete();
        });
        await __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.close();
        await __classPrivateFieldGet(this, _Repository_deps, "f").anchorRequestStore.close();
        await this.index.close();
    }
}
_Repository_deps = new WeakMap(), _Repository_syncedPinnedStreams = new WeakMap(), _Repository_numPendingAnchorSubscriptions = new WeakMap();
//# sourceMappingURL=repository.js.map