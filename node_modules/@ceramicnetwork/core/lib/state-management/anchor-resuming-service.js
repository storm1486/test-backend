var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AnchorResumingService_shouldBeClosed;
import { LogStyle } from '@ceramicnetwork/common';
import { TaskQueue } from '../ancillary/task-queue.js';
const RESUME_QUEUE_CONCURRENCY = 5;
const RESUME_BATCH_SIZE = RESUME_QUEUE_CONCURRENCY * 5;
export class AnchorResumingService {
    constructor(logger) {
        this.logger = logger;
        _AnchorResumingService_shouldBeClosed.set(this, false);
        this.resumeQ = new TaskQueue(RESUME_QUEUE_CONCURRENCY, (error) => {
            if (__classPrivateFieldGet(this, _AnchorResumingService_shouldBeClosed, "f")) {
                logger.log(LogStyle.verbose, `Anchor Resuming Service threw an error after it was closed: ${error.toString()}`);
            }
            else {
                throw error;
            }
        });
    }
    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    getDelay() {
        return Math.floor(Math.random() * 40) + 10;
    }
    async resumeRunningStatesFromAnchorRequestStore(repository) {
        if (__classPrivateFieldGet(this, _AnchorResumingService_shouldBeClosed, "f")) {
            throw Error('This AnchorResumingService is closed, create a new instance to resume');
        }
        this.logger.imp(`Resuming polling for streams with pending anchors`);
        let numRestoredStreams = 0;
        for await (const batch of repository.anchorRequestStore.list(RESUME_BATCH_SIZE)) {
            for (const item of batch) {
                if (__classPrivateFieldGet(this, _AnchorResumingService_shouldBeClosed, "f"))
                    return;
                this.resumeQ.add(async () => {
                    await repository.fromMemoryOrStore(item.key);
                    this.logger.verbose(`Resumed running state for stream id: ${item.key}`);
                    numRestoredStreams++;
                });
                await this.delay(this.getDelay());
            }
            await this.resumeQ.onIdle();
        }
        this.logger.imp(`Finished resuming polling for ${numRestoredStreams} streams which had pending anchors`);
    }
    async close() {
        this.logger.debug('Closing AnchorResumingService');
        __classPrivateFieldSet(this, _AnchorResumingService_shouldBeClosed, true, "f");
        this.resumeQ.clear();
        this.logger.debug('Waiting for remaining AnchorResumingService tasks to stop');
        await this.resumeQ.onIdle();
        this.logger.debug('AnchorResumingService closed');
    }
}
_AnchorResumingService_shouldBeClosed = new WeakMap();
//# sourceMappingURL=anchor-resuming-service.js.map