import { LRUCache } from 'least-recent';
export class StateCache {
    constructor(limit, onEvicted) {
        this.onEvicted = onEvicted;
        this.volatile = new LRUCache(limit);
        if (onEvicted) {
            this.volatile.on('evicted', (_key, value) => {
                if (value)
                    onEvicted(value);
            });
        }
        this.durable = new Map();
    }
    get(key) {
        return this.durable.get(key) || this.volatile.get(key);
    }
    set(key, value) {
        if (this.durable.has(key)) {
            this.durable.set(key, value);
        }
        this.volatile.set(key, value);
    }
    delete(key) {
        this.durable.delete(key);
        this.volatile.delete(key);
    }
    endure(key, value) {
        this.durable.set(key, value);
        this.volatile.delete(key);
    }
    free(key) {
        const entry = this.durable.get(key);
        if (entry) {
            this.volatile.set(key, entry);
            this.durable.delete(key);
        }
    }
    *entries() {
        for (const entry of this.durable.entries()) {
            yield entry;
        }
        for (const entry of this.volatile) {
            yield entry;
        }
    }
    *keys() {
        for (const entry of this.entries()) {
            yield entry[0];
        }
    }
    *values() {
        for (const entry of this.entries()) {
            yield entry[1];
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
//# sourceMappingURL=state-cache.js.map