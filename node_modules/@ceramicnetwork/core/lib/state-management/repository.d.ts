import { CommitID, StreamID } from '@ceramicnetwork/streamid';
import { AnchorOpts, Context, CreateOpts, DiagnosticsLogger, LoadOpts, PublishOpts, StreamState, UpdateOpts } from '@ceramicnetwork/common';
import type { LocalIndexApi } from '@ceramicnetwork/indexing';
import { PinStore } from '../store/pin-store.js';
import { ExecutionQueue } from './execution-queue.js';
import { RunningState } from './running-state.js';
import type { Dispatcher } from '../dispatcher.js';
import type { HandlersMap } from '../handlers-map.js';
import { Observable, Subscription } from 'rxjs';
import { StateCache } from './state-cache.js';
import { SnapshotState } from './snapshot-state.js';
import { IKVStore } from '../store/ikv-store.js';
import { AnchorRequestStore } from '../store/anchor-request-store.js';
import { StreamLoader } from '../stream-loading/stream-loader.js';
import { StreamUpdater } from '../stream-loading/stream-updater.js';
import { CID } from 'multiformats/cid';
import type { AnchorService } from '../anchor/anchor-service.js';
import type { AnchorRequestCarBuilder } from '../anchor/anchor-request-car-builder.js';
export declare type RepositoryDependencies = {
    dispatcher: Dispatcher;
    pinStore: PinStore;
    keyValueStore: IKVStore;
    anchorRequestStore: AnchorRequestStore;
    context: Context;
    handlers: HandlersMap;
    anchorService: AnchorService;
    indexing: LocalIndexApi;
    streamLoader: StreamLoader;
    streamUpdater: StreamUpdater;
    anchorRequestCarBuilder: AnchorRequestCarBuilder;
};
export declare class Repository {
    #private;
    private readonly logger;
    readonly loadingQ: ExecutionQueue;
    readonly executionQ: ExecutionQueue;
    readonly inmemory: StateCache<RunningState>;
    constructor(cacheLimit: number, concurrencyLimit: number, logger: DiagnosticsLogger);
    injectKeyValueStore(stateStore: IKVStore): Promise<void>;
    init(): Promise<void>;
    get pinStore(): PinStore;
    private get streamLoader();
    private get streamUpdater();
    get numPendingAnchors(): number;
    private get anchorService();
    private get dispatcher();
    get anchorRequestStore(): AnchorRequestStore;
    get index(): LocalIndexApi;
    setDeps(deps: RepositoryDependencies): void;
    load(streamId: StreamID, loadOptions?: LoadOpts, checkCacaoExpiration?: boolean): Promise<RunningState>;
    private _updateStateIfPinned;
    private _fromMemory;
    private _fromStreamStateStore;
    private _fromMemoryOrStore;
    private _fromMemoryOrStoreWithSyncStatus;
    private _loadStreamFromNetwork;
    private _genesisFromNetwork;
    private _sync;
    private _resyncStreamFromNetwork;
    loadAtCommit(commitId: CommitID, opts: LoadOpts): Promise<SnapshotState>;
    private _atCommit;
    loadAtTime(streamId: StreamID, opts: LoadOpts): Promise<SnapshotState>;
    applyCommit(streamId: StreamID, commit: any, opts: UpdateOpts): Promise<RunningState>;
    handleUpdateFromNetwork(streamId: StreamID, tip: CID, model?: StreamID): Promise<void>;
    private _handleTip;
    anchor(state$: RunningState, opts: AnchorOpts): Promise<Subscription>;
    private _cleanUpStaleAnchorRequestStore;
    private _confirmAnchorResponse;
    private _handleAnchorResponse;
    private _processAnchorResponse;
    private _handleAnchorCommit;
    private _applyWriteOpts;
    private _publishTip;
    private _handlePinOpts;
    applyCreateOpts(streamId: StreamID, opts: CreateOpts): Promise<RunningState>;
    fromMemoryOrStore(streamId: StreamID): Promise<RunningState | undefined>;
    streamState(streamId: StreamID): Promise<StreamState | undefined>;
    private _registerRunningState;
    pin(state$: RunningState, force?: boolean): Promise<void>;
    unpin(state$: RunningState, opts?: PublishOpts): Promise<void>;
    listPinned(streamId?: StreamID): Promise<string[]>;
    markPinnedAndSynced(streamId: StreamID): void;
    markUnpinned(streamId: StreamID): void;
    private _wasPinnedStreamSynced;
    randomPinnedStreamState(): Promise<StreamState | null>;
    private _indexStreamIfNeeded;
    updates$(init: StreamState): Observable<StreamState>;
    close(): Promise<void>;
}
//# sourceMappingURL=repository.d.ts.map