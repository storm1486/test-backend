import { StreamID } from '@ceramicnetwork/streamid';
import { CID } from 'multiformats/cid';
import * as co from 'codeco';
declare class CIDAsStringMap extends co.Codec<Map<string, CID>, Record<string, string>> {
    constructor();
    is(input: any): input is Map<string, CID>;
    encode(value: Map<string, CID>): Record<string, string>;
    decode(input: unknown, context: co.Context): co.Validation<Map<string, CID>>;
}
export declare enum MsgType {
    UPDATE = 0,
    QUERY = 1,
    RESPONSE = 2,
    KEEPALIVE = 3
}
export declare const UpdateMessage: co.SparseCodec<{
    typ: co.LiteralCodec<MsgType.UPDATE>;
    stream: co.Type<StreamID, string, string>;
    tip: co.Type<CID<unknown, number, number, import("multiformats/cid").Version>, string, string>;
    model: co.OptionalCodec<co.Type<StreamID, string, string>>;
}>;
export declare type UpdateMessage = co.TypeOf<typeof UpdateMessage>;
export declare const QueryMessage: co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.QUERY>;
    id: co.TrivialCodec<string>;
    stream: co.Type<StreamID, string, string>;
}>>;
export declare type QueryMessage = co.TypeOf<typeof QueryMessage>;
export declare const ResponseMessage: co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.RESPONSE>;
    id: co.TrivialCodec<string>;
    tips: CIDAsStringMap;
}>>;
export declare type ResponseMessage = co.TypeOf<typeof ResponseMessage>;
export declare const KeepaliveMessage: co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.KEEPALIVE>;
    ts: co.TrivialCodec<number>;
    ver: co.TrivialCodec<string>;
    ipfsVer: co.TrivialCodec<string>;
}>>;
export declare type KeepaliveMessage = co.TypeOf<typeof KeepaliveMessage>;
export declare const PubsubMessage: co.UnionCodec<[co.SparseCodec<{
    typ: co.LiteralCodec<MsgType.UPDATE>;
    stream: co.Type<StreamID, string, string>;
    tip: co.Type<CID<unknown, number, number, import("multiformats/cid").Version>, string, string>;
    model: co.OptionalCodec<co.Type<StreamID, string, string>>;
}>, co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.QUERY>;
    id: co.TrivialCodec<string>;
    stream: co.Type<StreamID, string, string>;
}>>, co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.RESPONSE>;
    id: co.TrivialCodec<string>;
    tips: CIDAsStringMap;
}>>, co.ExactCodec<co.TypeCodec<{
    typ: co.LiteralCodec<MsgType.KEEPALIVE>;
    ts: co.TrivialCodec<number>;
    ver: co.TrivialCodec<string>;
    ipfsVer: co.TrivialCodec<string>;
}>>]>;
export declare type PubsubMessage = co.TypeOf<typeof PubsubMessage>;
export declare function buildQueryMessage(streamId: StreamID): QueryMessage;
export declare function serialize(message: PubsubMessage): Uint8Array;
export declare function deserialize(message: any): PubsubMessage;
export {};
//# sourceMappingURL=pubsub-message.d.ts.map