var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LevelDBStoreMap_storeRoot, _LevelDBStoreMap_map, _LevelDBStoreMap_fullLocations, _LevelDbStore_storeMap;
import levelTs from 'level-ts';
import path from 'path';
import * as fs from 'fs';
import { Networks } from '@ceramicnetwork/common';
const LevelC = levelTs.default;
const DEFAULT_LEVELDB_STORE_USE_CASE_NAME = 'default';
export const OLD_ELP_DEFAULT_LOCATION = 'elp';
class NotFoundError extends Error {
    constructor() {
        super(...arguments);
        this.notFound = true;
    }
}
class LevelDBStoreMap {
    constructor(storeRoot, networkName, logger) {
        this.logger = logger;
        _LevelDBStoreMap_storeRoot.set(this, void 0);
        _LevelDBStoreMap_map.set(this, void 0);
        _LevelDBStoreMap_fullLocations.set(this, {});
        this.networkName = networkName;
        __classPrivateFieldSet(this, _LevelDBStoreMap_storeRoot, storeRoot, "f");
        __classPrivateFieldSet(this, _LevelDBStoreMap_map, new Map(), "f");
    }
    createStore(fullLocation) {
        const storePath = path.join(__classPrivateFieldGet(this, _LevelDBStoreMap_storeRoot, "f"), fullLocation);
        if (fs) {
            fs.mkdirSync(storePath, { recursive: true });
        }
        const levelDb = new LevelC(storePath);
        levelDb.DB.on('error', (err) => {
            this.logger.warn(`Received error when starting up leveldb at ${storePath} using level-ts: ${err}`);
        });
        __classPrivateFieldGet(this, _LevelDBStoreMap_map, "f").set(fullLocation, levelDb);
        return new Promise((res) => setTimeout(res, 100));
    }
    getStoreLocation(useCaseName, networkName = this.networkName) {
        return useCaseName === DEFAULT_LEVELDB_STORE_USE_CASE_NAME
            ? networkName
            : `${networkName}-${useCaseName}`;
    }
    getFullLocation(useCaseName = DEFAULT_LEVELDB_STORE_USE_CASE_NAME) {
        let fullLocation = __classPrivateFieldGet(this, _LevelDBStoreMap_fullLocations, "f")[useCaseName];
        if (fullLocation != null) {
            return fullLocation;
        }
        if (this.networkName === Networks.MAINNET) {
            const elpLocation = this.getStoreLocation(useCaseName, OLD_ELP_DEFAULT_LOCATION);
            const storePath = path.join(__classPrivateFieldGet(this, _LevelDBStoreMap_storeRoot, "f"), elpLocation);
            if (fs.existsSync(storePath)) {
                this.logger.warn(`LevelDB store ${useCaseName} found with ELP location, using it instead of default mainnet location`);
                fullLocation = elpLocation;
            }
        }
        if (fullLocation == null) {
            fullLocation = this.getStoreLocation(useCaseName);
        }
        __classPrivateFieldGet(this, _LevelDBStoreMap_fullLocations, "f")[useCaseName] = fullLocation;
        return fullLocation;
    }
    async get(useCaseName) {
        const location = this.getFullLocation(useCaseName);
        if (!__classPrivateFieldGet(this, _LevelDBStoreMap_map, "f").get(location)) {
            await this.createStore(location);
        }
        return __classPrivateFieldGet(this, _LevelDBStoreMap_map, "f").get(location);
    }
    values() {
        return __classPrivateFieldGet(this, _LevelDBStoreMap_map, "f").values();
    }
}
_LevelDBStoreMap_storeRoot = new WeakMap(), _LevelDBStoreMap_map = new WeakMap(), _LevelDBStoreMap_fullLocations = new WeakMap();
export class LevelDbStore {
    constructor(logger, storeRoot, networkName) {
        this.logger = logger;
        _LevelDbStore_storeMap.set(this, void 0);
        __classPrivateFieldSet(this, _LevelDbStore_storeMap, new LevelDBStoreMap(storeRoot, networkName, logger), "f");
    }
    get networkName() {
        return __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").networkName;
    }
    async init() {
        return;
    }
    close(useCaseName) {
        return;
    }
    async del(key, useCaseName) {
        const store = await __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").get(useCaseName);
        try {
            return await store.del(key);
        }
        catch (err) {
            const msg = `Error deleting key ${key} from leveldb state store: ${err}`;
            this.logger.warn(msg);
            throw new Error(msg);
        }
    }
    async get(key, useCaseName) {
        const store = await __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").get(useCaseName);
        try {
            return await store.get(key);
        }
        catch (err) {
            const msg = `Error fetching key ${key} from leveldb state store: ${err}`;
            if (err.notFound) {
                throw new NotFoundError(msg);
            }
            else {
                this.logger.warn(msg);
                throw new Error(msg);
            }
        }
    }
    async isEmpty(params) {
        const keys = await this.findKeys(params);
        return keys.length === 0;
    }
    async exists(key, useCaseName) {
        try {
            const val = await this.get(key, useCaseName);
            return typeof val === 'string';
        }
        catch (e) {
            if (/Key not found in database/.test(e.toString())) {
                return false;
            }
            else {
                throw e;
            }
        }
    }
    async find(params) {
        const searchParams = {
            keys: true,
            values: true,
            limit: params?.limit,
        };
        if (params?.gt)
            searchParams.gt = params.gt;
        const store = await __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").get(params?.useCaseName);
        return await store.stream(searchParams);
    }
    async findKeys(params) {
        const searchParams = {
            keys: true,
            values: false,
            limit: params?.limit,
        };
        const store = await __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").get(params?.useCaseName);
        return (await store.stream(searchParams));
    }
    async put(key, value, useCaseName) {
        const store = await __classPrivateFieldGet(this, _LevelDbStore_storeMap, "f").get(useCaseName);
        try {
            await store.put(key, value);
        }
        catch (err) {
            const msg = `Error storing key ${key} to leveldb state store: ${err}`;
            this.logger.warn(msg);
            throw new Error(msg);
        }
    }
}
_LevelDbStore_storeMap = new WeakMap();
//# sourceMappingURL=level-db-store.js.map