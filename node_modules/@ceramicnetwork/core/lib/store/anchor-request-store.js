import { StreamID } from '@ceramicnetwork/streamid';
import { ObjectStore } from './object-store.js';
import { CID } from 'multiformats/cid';
import { StreamUtils } from '@ceramicnetwork/common';
function generateKey(object) {
    return object.toString();
}
export function serializeAnchorRequestData(value) {
    return JSON.stringify({
        cid: value.cid.toString(),
        timestamp: value.timestamp,
        genesis: StreamUtils.serializeCommit(value.genesis),
    });
}
export function deserializeAnchorRequestData(serialized) {
    const parsed = JSON.parse(serialized);
    return {
        cid: CID.parse(parsed.cid),
        timestamp: parsed.timestamp,
        genesis: StreamUtils.deserializeCommit(parsed.genesis),
    };
}
export class AnchorRequestStore extends ObjectStore {
    constructor() {
        super(generateKey, serializeAnchorRequestData, deserializeAnchorRequestData);
        this.useCaseName = 'anchor-requests';
    }
    exists(key) {
        return this.store.exists(generateKey(key), this.useCaseName);
    }
    async *list(batchSize = 1) {
        let gt = undefined;
        do {
            const batch = await this.store.find({
                limit: batchSize,
                useCaseName: this.useCaseName,
                gt: gt ? generateKey(gt) : undefined,
            });
            if (batch.length > 0) {
                gt = StreamID.fromString(batch[batch.length - 1].key);
                yield batch.map((item) => {
                    return {
                        key: StreamID.fromString(item.key),
                        value: deserializeAnchorRequestData(item.value),
                    };
                });
            }
            else {
                return;
            }
        } while (true);
    }
    async close() {
        await this.store.close(this.useCaseName);
    }
}
//# sourceMappingURL=anchor-request-store.js.map