var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _StreamStateStore_logger;
import { StreamUtils, } from '@ceramicnetwork/common';
import { ObjectStore } from './object-store.js';
function generateKey(object) {
    return object.toString();
}
function serialize(value) {
    return StreamUtils.serializeState(value);
}
function deserialize(serialized) {
    return StreamUtils.deserializeState(serialized);
}
export class StreamStateStore extends ObjectStore {
    constructor(logger) {
        super(generateKey, serialize, deserialize);
        _StreamStateStore_logger.set(this, void 0);
        __classPrivateFieldSet(this, _StreamStateStore_logger, logger, "f");
    }
    get networkName() {
        return this.store.networkName;
    }
    async saveFromStreamStateHolder(streamStateHolder) {
        await this.save(streamStateHolder.id, streamStateHolder.state);
    }
    async open(store) {
        return super.open(store);
    }
    async listStoredStreamIDs(streamId, limit) {
        if (streamId == null) {
            return await this.store.findKeys({ limit });
        }
        else {
            const exists = Boolean(await this.load(streamId.baseID));
            return exists ? [streamId.toString()] : [];
        }
    }
}
_StreamStateStore_logger = new WeakMap();
//# sourceMappingURL=stream-state-store.js.map