import { Networks } from '@ceramicnetwork/common';
import { multiaddr } from '@multiformats/multiaddr';
const BOOTSTRAP_LIST = (ceramicNetwork) => {
    switch (ceramicNetwork) {
        case Networks.MAINNET:
            return [
                multiaddr('/dns4/go-ipfs-ceramic-private-mainnet-external.3boxlabs.com/tcp/4011/ws/p2p/QmXALVsXZwPWTUbsT8G6VVzzgTJaAWRUD7FWL5f7d5ubAL'),
                multiaddr('/dns4/go-ipfs-ceramic-private-cas-mainnet-external.3boxlabs.com/tcp/4011/ws/p2p/QmUvEKXuorR7YksrVgA7yKGbfjWHuCRisw2cH9iqRVM9P8'),
            ];
        case Networks.TESTNET_CLAY:
            return [
                multiaddr('/dns4/go-ipfs-ceramic-public-clay-external.3boxlabs.com/tcp/4011/ws/p2p/QmWiY3CbNawZjWnHXx3p3DXsg21pZYTj4CRY1iwMkhP8r3'),
                multiaddr('/dns4/go-ipfs-ceramic-private-clay-external.3boxlabs.com/tcp/4011/ws/p2p/QmQotCKxiMWt935TyCBFTN23jaivxwrZ3uD58wNxeg5npi'),
                multiaddr('/dns4/go-ipfs-ceramic-private-cas-clay-external.3boxlabs.com/tcp/4011/ws/p2p/QmbeBTzSccH8xYottaYeyVX8QsKyox1ExfRx7T1iBqRyCd'),
            ];
        case Networks.DEV_UNSTABLE:
            return [
                multiaddr('/dns4/ipfs-ceramic-public-qa-swarm.3boxlabs.com/tcp/4010/p2p/QmPP3RdaSWDkhcxZReGo591FWanLw9ucvgmUZhtSLt9t6D'),
                multiaddr('/dns4/ipfs-ceramic-private-qa-swarm.3boxlabs.com/tcp/4010/p2p/12D3KooWAQvp6Wnqho9ririWvbmtodnNQX9GECQEps2gb6kwBf2h'),
                multiaddr('/dns4/ipfs-ceramic-private-cas-qa-swarm.3boxlabs.com/tcp/4010/p2p/QmRvJ4HX4N6H26NgtqjoJEUyaDyDRUhGESP1aoyCJE1X1b'),
            ];
        case Networks.LOCAL:
        case Networks.INMEMORY:
            return null;
        default: {
            const preventCompilingUnhandledCase = ceramicNetwork;
            return null;
        }
    }
};
export const DEFAULT_BOOTSTRAP_CONNECTION_PERIOD = 1000 * 60 * 60;
export class IpfsTopology {
    constructor(ipfs, ceramicNetwork, logger, period = DEFAULT_BOOTSTRAP_CONNECTION_PERIOD) {
        this.ipfs = ipfs;
        this.ceramicNetwork = ceramicNetwork;
        this.logger = logger;
        this.period = period;
    }
    async forceConnection() {
        const bootstrapList = BOOTSTRAP_LIST(this.ceramicNetwork) || [];
        await this._forceBootstrapConnection(this.ipfs, bootstrapList);
    }
    async start() {
        this.logger.imp(`Connecting to bootstrap peers for network ${this.ceramicNetwork}`);
        await this.forceConnection();
        const connectedPeers = (await this.ipfs.swarm.peers()).map((peer) => peer.addr.toString());
        this.logger.debug(`Connected to peers: ${connectedPeers.join(',')}`);
        this.intervalId = setInterval(async () => {
            this.logger.debug(`Performing periodic reconnection to bootstrap peers for network ${this.ceramicNetwork}`);
            await this.forceConnection();
        }, this.period);
    }
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    async _forceBootstrapConnection(ipfs, bootstrapList) {
        let myPeerId;
        try {
            myPeerId = (await ipfs.id()).id;
        }
        catch (error) {
            this.logger.warn(`Error loading our PeerID from IPFS: ${error}. Skipping connection to bootstrap peers`);
            return;
        }
        const filteredBootstrapList = bootstrapList.filter((addr) => {
            return !addr.getPeerId()?.endsWith(myPeerId);
        });
        for (const node of filteredBootstrapList) {
            try {
                await ipfs.swarm.connect(node);
            }
            catch (error) {
                this.logger.warn(`Can not connect to ${node}`);
                this.logger.warn(error);
            }
        }
    }
}
//# sourceMappingURL=ipfs-topology.js.map