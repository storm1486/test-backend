import { type TypeOf } from 'codeco';
export declare enum AnchorRequestStatusName {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    COMPLETED = "COMPLETED",
    FAILED = "FAILED",
    READY = "READY",
    REPLACED = "REPLACED"
}
export declare const AnchorCommitPresentation: import("codeco").SparseCodec<{
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, unknown>;
}>;
export declare type AnchorCommitPresentation = TypeOf<typeof AnchorCommitPresentation>;
export declare const NotCompleteStatusName: import("codeco").UnionCodec<[import("codeco").LiteralCodec<AnchorRequestStatusName.PENDING>, import("codeco").LiteralCodec<AnchorRequestStatusName.PROCESSING>, import("codeco").LiteralCodec<AnchorRequestStatusName.FAILED>, import("codeco").LiteralCodec<AnchorRequestStatusName.READY>, import("codeco").LiteralCodec<AnchorRequestStatusName.REPLACED>]>;
export declare type NotCompleteStatusName = TypeOf<typeof NotCompleteStatusName>;
export declare const NotCompleteCASResponse: import("codeco").SparseCodec<{
    id: import("codeco").TrivialCodec<string>;
    status: import("codeco").UnionCodec<[import("codeco").LiteralCodec<AnchorRequestStatusName.PENDING>, import("codeco").LiteralCodec<AnchorRequestStatusName.PROCESSING>, import("codeco").LiteralCodec<AnchorRequestStatusName.FAILED>, import("codeco").LiteralCodec<AnchorRequestStatusName.READY>, import("codeco").LiteralCodec<AnchorRequestStatusName.REPLACED>]>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>;
export declare type NotCompleteCASResponse = TypeOf<typeof NotCompleteCASResponse>;
export declare const CompleteCASResponse: import("codeco").SparseCodec<{
    status: import("codeco").LiteralCodec<AnchorRequestStatusName.COMPLETED>;
    anchorCommit: import("codeco").SparseCodec<{
        cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, unknown>;
    }>;
    witnessCar: import("codeco").OptionalCodec<import("codeco").Type<import("cartonne").CAR, string, string>>;
    id: import("codeco").TrivialCodec<string>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>;
export declare type CompleteCASResponse = TypeOf<typeof CompleteCASResponse>;
export declare const CASResponse: import("codeco").UnionCodec<[import("codeco").SparseCodec<{
    id: import("codeco").TrivialCodec<string>;
    status: import("codeco").UnionCodec<[import("codeco").LiteralCodec<AnchorRequestStatusName.PENDING>, import("codeco").LiteralCodec<AnchorRequestStatusName.PROCESSING>, import("codeco").LiteralCodec<AnchorRequestStatusName.FAILED>, import("codeco").LiteralCodec<AnchorRequestStatusName.READY>, import("codeco").LiteralCodec<AnchorRequestStatusName.REPLACED>]>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>, import("codeco").SparseCodec<{
    status: import("codeco").LiteralCodec<AnchorRequestStatusName.COMPLETED>;
    anchorCommit: import("codeco").SparseCodec<{
        cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, unknown>;
    }>;
    witnessCar: import("codeco").OptionalCodec<import("codeco").Type<import("cartonne").CAR, string, string>>;
    id: import("codeco").TrivialCodec<string>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>]>;
export declare type CASResponse = TypeOf<typeof CASResponse>;
export declare const ErrorResponse: import("codeco").TypeCodec<{
    error: import("codeco").TrivialCodec<string>;
}>;
export declare type ErrorResponse = TypeOf<typeof ErrorResponse>;
export declare const CASResponseOrError: import("codeco").UnionCodec<[import("codeco").UnionCodec<[import("codeco").SparseCodec<{
    id: import("codeco").TrivialCodec<string>;
    status: import("codeco").UnionCodec<[import("codeco").LiteralCodec<AnchorRequestStatusName.PENDING>, import("codeco").LiteralCodec<AnchorRequestStatusName.PROCESSING>, import("codeco").LiteralCodec<AnchorRequestStatusName.FAILED>, import("codeco").LiteralCodec<AnchorRequestStatusName.READY>, import("codeco").LiteralCodec<AnchorRequestStatusName.REPLACED>]>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>, import("codeco").SparseCodec<{
    status: import("codeco").LiteralCodec<AnchorRequestStatusName.COMPLETED>;
    anchorCommit: import("codeco").SparseCodec<{
        cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, unknown>;
    }>;
    witnessCar: import("codeco").OptionalCodec<import("codeco").Type<import("cartonne").CAR, string, string>>;
    id: import("codeco").TrivialCodec<string>;
    streamId: import("codeco").Type<import("streamid/lib/stream-id.js").StreamID, string, string>;
    cid: import("codeco").Type<import("multiformats/dist/types/src").CID<unknown, number, number, import("multiformats/dist/types/src").Version>, string, string>;
    message: import("codeco").TrivialCodec<string>;
    createdAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
    updatedAt: import("codeco").OptionalCodec<import("codeco").Type<Date, number, unknown>>;
}>]>, import("codeco").TypeCodec<{
    error: import("codeco").TrivialCodec<string>;
}>]>;
export declare type CASResponseOrError = TypeOf<typeof CASResponseOrError>;
export declare const SupportedChainsResponse: import("codeco").TypeCodec<{
    supportedChains: import("codeco").RefinementCodec<import("codeco").Codec<string[], string[], unknown> & {
        item: import("codeco").TrivialCodec<string>;
    }, string[]>;
}>;
export declare type SupportedChainsResponse = TypeOf<typeof SupportedChainsResponse>;
//# sourceMappingURL=anchor.d.ts.map