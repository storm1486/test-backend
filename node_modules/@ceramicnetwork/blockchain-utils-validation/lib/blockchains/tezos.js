import { ChainId } from 'caip';
import { verifySignature } from '@taquito/utils';
import { tezos } from '@ceramicnetwork/blockchain-utils-linking';
import * as uint8arrays from 'uint8arrays';
import { normalizeAccountId } from '@ceramicnetwork/common';
export const ADDRESS_NOT_FOUND_ERROR = new Error(`Address not found on the Tezos blockchain`);
export const PUBLIC_KEY_NOT_PUBLISHED_ERROR = new Error(`Public key not published to the Tezos blockchain`);
const { TEZOS_NAMESPACE, TEZOS_CHAIN_REF } = tezos;
function encodeMessage(text) {
    const michelinePrefix = '05';
    const stringPrefix = '01';
    const len = ('0000000' + text.length.toString(16)).slice(-8);
    text = uint8arrays.toString(uint8arrays.fromString(text, 'utf-8'), 'hex');
    return michelinePrefix + stringPrefix + len + text;
}
async function findPublicKey(address) {
    const response = await fetch(`https://api.tzstats.com/explorer/account/${address}`).catch(() => {
        throw ADDRESS_NOT_FOUND_ERROR;
    });
    const json = await response.json();
    const result = json?.pubkey;
    if (result) {
        return result;
    }
    else {
        throw PUBLIC_KEY_NOT_PUBLISHED_ERROR;
    }
}
export async function validateLink(proof) {
    const account = normalizeAccountId(proof.account);
    const chainId = new ChainId(account.chainId);
    if (chainId.reference !== TEZOS_CHAIN_REF) {
        return null;
    }
    const msg = encodeMessage(proof.message);
    try {
        const pk = await findPublicKey(account.address);
        const is_sig_valid = await verifySignature(msg, pk, proof.signature);
        return is_sig_valid ? proof : null;
    }
    catch (ignored) {
        return null;
    }
}
export const handler = {
    namespace: TEZOS_NAMESPACE,
    validateLink,
};
//# sourceMappingURL=tezos.js.map