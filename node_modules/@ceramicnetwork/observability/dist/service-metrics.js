/* Service metrics need to push to a collector rather than expose
   metrics on an exporter */ function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { MeterProvider, PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import exporterMetricsOtlpHttp from '@opentelemetry/exporter-metrics-otlp-http';
const { OTLPMetricExporter } = exporterMetricsOtlpHttp;
import exporterTraceOtlpHttp from '@opentelemetry/exporter-trace-otlp-http';
const { OTLPTraceExporter } = exporterTraceOtlpHttp;
import exporterPrometheus from '@opentelemetry/exporter-prometheus';
const { PrometheusExporter } = exporterPrometheus;
import sdkTraceBase from '@opentelemetry/sdk-trace-base';
const { BasicTracerProvider, TraceIdRatioBasedSampler, ParentBasedSampler, BatchSpanProcessor } = sdkTraceBase;
import semanticConventions from '@opentelemetry/semantic-conventions';
const { SemanticResourceAttributes } = semanticConventions;
import resources from '@opentelemetry/resources';
const { Resource } = resources;
import { trace } from '@opentelemetry/api';
import { Utils } from './utils.js';
export const UNKNOWN_CALLER = 'Unknown';
export const CONCURRENCY_LIMIT = 1;
export const TRACE_CONCURRENCY_LIMIT = 1;
export const DEFAULT_TRACE_SAMPLE_RATIO = 0.1;
export const DEFAULT_EXPORT_INTERVAL_MS = 60000 // one minute, is otlp default
;
export const DEFAULT_EXPORT_TIMEOUT_MS = 30000 // 30 sec timeout, the otlp default
;
class NullSpan {
    // if we start using other span methods, add null methods here
    // Returns the flag whether this span will be recorded.
    // @ts-ignore
    end(endTime) {
        return false;
    }
}
export var SinceField;
(function(SinceField) {
    SinceField[SinceField["CREATED_AT"] = 0] = "CREATED_AT";
    SinceField[SinceField["UPDATED_AT"] = 1] = "UPDATED_AT";
})(SinceField || (SinceField = {}));
export class TimeableMetric {
    recordAll(requests) {
        for (const req of requests){
            this.record(req);
        }
    }
    record(request) {
        this.cnt += 1;
        let timeElapsed = 0;
        if (this.since === SinceField.CREATED_AT) {
            timeElapsed = Date.now() - request.createdAt.getTime();
        } else {
            timeElapsed = Date.now() - request.updatedAt.getTime();
        }
        this.totTime += timeElapsed;
        if (timeElapsed > this.maxTime) {
            this.maxTime = timeElapsed;
        }
    }
    getMeanTime() {
        return this.totTime / this.cnt;
    }
    publishStats(name) {
        ServiceMetrics.count(name + '_total', this.cnt);
        ServiceMetrics.record(name + '_mean', this.getMeanTime());
        ServiceMetrics.record(name + '_max', this.maxTime);
    }
    constructor(since){
        _define_property(this, "cnt", void 0);
        _define_property(this, "totTime", void 0);
        _define_property(this, "maxTime", void 0);
        _define_property(this, "since", void 0);
        this.cnt = 0;
        this.totTime = 0;
        this.maxTime = 0;
        this.since = since;
    }
}
class _ServiceMetrics {
    static getInstance() {
        if (!_ServiceMetrics.instance) {
            _ServiceMetrics.instance = new _ServiceMetrics();
        }
        return _ServiceMetrics.instance;
    }
    /* Set up the exporter at run time, after we have read the configuration */ start(collectorHost = '', caller = UNKNOWN_CALLER, sample_ratio = DEFAULT_TRACE_SAMPLE_RATIO, logger = null, append_total_to_counters = true, prometheusExportPort = 0, exportIntervalMillis = DEFAULT_EXPORT_INTERVAL_MS, exportTimeoutMillis = DEFAULT_EXPORT_TIMEOUT_MS) {
        this.caller = caller;
        const meterProvider = new MeterProvider({
            resource: new Resource({
                [SemanticResourceAttributes.SERVICE_NAME]: caller
            })
        });
        if (!collectorHost && prometheusExportPort <= 0) {
            // If no collector URL  or prometheusExportPort then the functions will be no-ops
            return;
        }
        if (prometheusExportPort > 0) {
            const promExporter = new PrometheusExporter({
                port: prometheusExportPort
            });
            meterProvider.addMetricReader(promExporter);
        }
        if (collectorHost) {
            const collectorURL = `http://${collectorHost}:4318/v1/metrics`;
            const traceCollectorURL = `http://${collectorHost}:4318/v1/traces`;
            const metricExporter = new OTLPMetricExporter({
                url: collectorURL,
                concurrencyLimit: CONCURRENCY_LIMIT
            });
            meterProvider.addMetricReader(new PeriodicExportingMetricReader({
                exporter: metricExporter,
                exportIntervalMillis: exportIntervalMillis,
                exportTimeoutMillis: exportTimeoutMillis
            }));
            // now set up trace exporter
            const traceExporter = new OTLPTraceExporter({
                url: traceCollectorURL,
                concurrencyLimit: TRACE_CONCURRENCY_LIMIT
            });
            //reference: https://github.com/open-telemetry/opentelemetry-js/tree/main/packages/opentelemetry-sdk-trace-base
            const traceProvider = new BasicTracerProvider({
                sampler: new ParentBasedSampler({
                    // sample_ratio represents the percentage of traces which should
                    // be sampled.
                    root: new TraceIdRatioBasedSampler(sample_ratio)
                })
            });
            traceProvider.addSpanProcessor(new BatchSpanProcessor(traceExporter));
            traceProvider.register();
            // set up a tracer for the caller
            this.tracer = trace.getTracer(caller);
        }
        // Meter for calling application
        this.meter = meterProvider.getMeter(caller);
        // accept a logger from the caller
        this.logger = logger;
        // behavior about counter naming to be backward-compatible
        this.append_total_to_counters = append_total_to_counters;
    }
    // could have subclasses or specific functions with set params, but we want to
    // easily and quickly change what is recorded, there are no code dependencies on it
    startSpan(name, params) {
        if (!this.tracer) {
            return new NullSpan();
        }
        try {
            const span = this.tracer.startSpan(name);
            for(const key in params){
                span.setAttribute(key, params[key]);
            }
            return span;
        } catch (e) {
            this.logger.warn(`Error starting span ${name}: ${e}`);
            return new NullSpan();
        }
    }
    count(name, value, params) {
        // If not initialized, just return
        if (!this.meter) {
            return;
        }
        // Create this counter if we have not already
        if (!(name in this.counters)) {
            const full_name = this.append_total_to_counters ? `${this.caller}_${name}_total` : `${this.caller}_${name}`;
            this.counters[name] = this.meter.createCounter(full_name);
        }
        // Add to the count
        if (params) {
            this.counters[name].add(value, params);
        } else {
            this.counters[name].add(value);
        }
    }
    observe(name, value, params) {
        // If not initialized, just return
        if (!this.meter) {
            return;
        }
        // Create this ObservableGauge if we have not already
        if (!(name in this.gauges)) {
            this.gauges[name] = this.meter.createObservableGauge(`${this.caller}:${name}`);
            this.observations[name] = [];
            this.gauges[name].addCallback((observableResult)=>{
                for (const [value, params] of this.observations[name]){
                    observableResult.observe(value, params);
                }
                this.observations[name] = [];
            });
        }
        // Record the observed value; it will be set in the callback when metrics are recorded
        this.observations[name].push([
            value,
            params
        ]);
    }
    record(name, value, params) {
        // If not initialized, just return
        if (!this.meter) {
            return;
        }
        // Create this Histogram if we have not already
        if (!(name in this.histograms)) {
            this.histograms[name] = this.meter.createHistogram(`${this.caller}:${name}`);
        }
        // Record the observed value
        if (params) {
            this.histograms[name].record(value, params);
        } else {
            this.histograms[name].record(value);
        }
    }
    recordAverage(name, arr) {
        // if array is empty, just return
        if (arr.length <= 0) {
            return;
        }
        this.record(name, Utils.averageArray(arr));
    }
    recordObjectFields(prefix, obj) {
        Object.entries(obj).forEach(([key, value])=>{
            if (typeof value === "number") {
                this.record(prefix + '_' + String(key), value);
            }
        });
    }
    recordRatio(name, numer, denom, digits = 2) {
        if (denom == 0) {
            this.log_warn(`Attempt to record ratio w zero denominator: ${name}`);
            return;
        }
        this.record(name, numer / denom);
    }
    log_info(message) {
        if (!this.logger) {
            return;
        }
        try {
            this.logger.info(message);
        } catch  {}
    }
    log_warn(message) {
        if (!this.logger) {
            return;
        }
        try {
            this.logger.warn(message);
        } catch  {}
    }
    log_err(message) {
        if (!this.logger) {
            return;
        }
        try {
            this.logger.err(message);
        } catch  {}
    }
    constructor(){
        _define_property(this, "caller", void 0);
        _define_property(this, "counters", void 0);
        _define_property(this, "gauges", void 0);
        _define_property(this, "histograms", void 0);
        _define_property(this, "observations", void 0);
        _define_property(this, "meter", void 0);
        _define_property(this, "tracer", void 0);
        _define_property(this, "logger", void 0);
        _define_property(this, "append_total_to_counters", void 0);
        this.caller = '';
        this.counters = {};
        this.gauges = {};
        this.observations = {};
        this.histograms = {};
        this.meter = null;
        this.tracer = null;
        this.logger = null;
        this.append_total_to_counters = true;
    }
}
_define_property(_ServiceMetrics, "instance", void 0);
export const ServiceMetrics = _ServiceMetrics.getInstance();
