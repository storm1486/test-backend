import { Multiaddr } from '@multiformats/multiaddr';
import { ExecaChildProcess } from 'execa';
import type { Controller, ControllerOptions, InitOptions, IPFSAPI, PeerData } from './index.js';
/**
 * Controller for daemon nodes
 */
declare class Daemon implements Controller {
    path: string;
    api: IPFSAPI;
    subprocess?: ExecaChildProcess;
    opts: ControllerOptions;
    initialized: boolean;
    started: boolean;
    clean: boolean;
    apiAddr: Multiaddr;
    private gatewayAddr?;
    private grpcAddr?;
    private readonly exec?;
    private readonly env;
    private readonly disposable;
    private _peerId;
    constructor(opts: ControllerOptions);
    get peer(): PeerData;
    private _setApi;
    private _setGrpc;
    private _setGateway;
    _createApi(): void;
    init(initOptions?: InitOptions): Promise<Controller>;
    /**
     * Delete the repo that was being used. If the node was marked as disposable this will be called automatically when the process is exited.
     *
     * @returns {Promise<Daemon>}
     */
    cleanup(): Promise<this>;
    /**
     * Start the daemon.
     *
     * @returns {Promise<Daemon>}
     */
    start(): Promise<this>;
    stop(options?: {
        timeout?: number;
    }): Promise<Controller>;
    /**
     * Get the pid of the `ipfs daemon` process.
     *
     * @returns {Promise<number>}
     */
    pid(): Promise<number>;
    /**
     * Call `ipfs config`
     *
     * If no `key` is passed, the whole config is returned as an object.
     *
     * @private
     * @param {string} [key] - A specific config to retrieve.
     * @returns {Promise<object | string>}
     */
    _getConfig(key?: string): Promise<any>;
    /**
     * Replace the current config with the provided one
     */
    private _replaceConfig;
    version(): Promise<string>;
}
export default Daemon;
//# sourceMappingURL=ipfsd-daemon.d.ts.map