import { isLeft, left, right } from "./either.js";
export class StringTape {
    input;
    position = 0;
    constructor(input) {
        this.input = input;
    }
    get isEOF() {
        return this.position >= this.input.length;
    }
}
/**
 * Reset position to `prev` and `fail`
 */
export function failure(error, prev, tape) {
    tape.position = prev;
    return fail(error);
}
/**
 * Just return Left<Error>
 */
export function fail(error) {
    return left(error);
}
// --- Combinators below ---
export function literal(value) {
    return function (tape) {
        const probe = tape.input.slice(tape.position, tape.position + value.length);
        if (probe === value) {
            tape.position += value.length;
            return right(value);
        }
        else {
            return fail(new Error(`Can not match literal "${value}"`));
        }
    };
}
export function foldMap(combinator, fn) {
    return function map(tape) {
        const prev = tape.position;
        const parsed = combinator(tape);
        if (isLeft(parsed)) {
            tape.position = prev;
            return parsed;
        }
        const mapped = fn(parsed.right);
        if (isLeft(mapped))
            return failure(mapped.left, prev, tape);
        return mapped;
    };
}
export function map(combinator, fn) {
    return function (tape) {
        const prev = tape.position;
        const parsed = combinator(tape);
        if (isLeft(parsed)) {
            tape.position = prev;
            return parsed;
        }
        return right(fn(parsed.right));
    };
}
export function match(pattern) {
    return function (tape) {
        const probe = tape.input.slice(tape.position).match(pattern);
        if (!probe)
            return fail(new Error(`Can not match ${pattern}`));
        tape.position += probe[0].length;
        return right(probe[0]);
    };
}
export function joinSeq(...combinators) {
    return join(seqA(combinators));
}
export function join(input, separator = "") {
    return function (tape) {
        const prev = tape.position;
        const results = input(tape);
        if (isLeft(results)) {
            tape.position = prev;
            return results;
        }
        return right(results.right.join(separator));
    };
}
export function seq(...combinators) {
    return seqA(combinators);
}
export function seqA(combinators) {
    return function (tape) {
        const prev = tape.position;
        const results = [];
        for (const combinator of combinators) {
            const r = combinator(tape);
            if (isLeft(r)) {
                return failure(r.left, prev, tape);
            }
            results.push(r.right);
        }
        return right(results);
    };
}
// If the production method fails, don't fail, just return otherwise.
export function option(combinator, otherwise) {
    return function option(tape) {
        const result = combinator(tape);
        if (isLeft(result)) {
            return right(otherwise);
        }
        else {
            return result;
        }
    };
}
export function choice(...combinators) {
    return function choice(tape) {
        for (const combinator of combinators) {
            const prev = tape.position;
            const result = combinator(tape);
            if (isLeft(result)) {
                tape.position = prev;
            }
            else {
                return result;
            }
        }
        return fail(new Error(`Can not find any of ${combinators.map((m) => m.name).join(", ")}`));
    };
}
// Return the array of values produced by method with sep between each
// value: "A", "A sep A", "A sep A sep A"
export function sepBy(element, separator, min = 1, max = Infinity) {
    return function (tape) {
        const prev = tape.position;
        const results = [];
        const first = element(tape);
        if (isLeft(first))
            return failure(first.left, prev, tape);
        results.push(first.right);
        let returnPosition = tape.position;
        const handleLeft = (miss) => {
            if (results.length < min) {
                return failure(miss.left, returnPosition, tape);
            }
            else {
                tape.position = returnPosition;
                return right(results);
            }
        };
        while (!tape.isEOF && results.length < max) {
            returnPosition = tape.position;
            const sepE = separator(tape);
            if (isLeft(sepE))
                return handleLeft(sepE);
            const seqE = element(tape);
            if (isLeft(seqE))
                return handleLeft(seqE);
            results.push(seqE.right);
        }
        if (results.length < min) {
            return failure(new Error(`Got ${results}/${min} instances of ${element.name}`), prev, tape);
        }
        return right(results);
    };
}
export function many(element, min = 1, max = Infinity) {
    return function many(tape) {
        const prev = tape.position;
        const result = [];
        while (!tape.isEOF && result.length < max) {
            const entry = element(tape);
            if (isLeft(entry)) {
                if (result.length < min) {
                    return failure(entry.left, prev, tape);
                }
                else {
                    return right(result);
                }
            }
            else {
                result.push(entry.right);
            }
        }
        return right(result);
    };
}
/**
 * Consume all the input.
 */
export function parseAll(combinator) {
    return function parseAll(tape) {
        const prev = tape.position;
        const result = combinator(tape);
        if (isLeft(result))
            return result;
        // Check if input is consumed
        if (!tape.isEOF) {
            return failure(new Error(`Consumed only ${tape.position} of ${tape.input.length} input length`), prev, tape);
        }
        return result;
    };
}
