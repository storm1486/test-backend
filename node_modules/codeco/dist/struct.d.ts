import { type Either } from "./either.js";
import type { NonEmptyArray } from "ts-essentials";
import type { HKT, Intersection, MapOver } from "./hkt.js";
export declare function isNonEmpty<T>(array: Array<T>): array is NonEmptyArray<T>;
export type Refinement<A, B extends A> = (a: A) => a is B;
export type Predicate<A> = (a: A) => boolean;
export type Errors = Array<ValidationError>;
export interface TrailEntry {
    readonly key: string;
    readonly type: Decoder<any, any>;
    readonly actual: unknown;
}
export type Validation<A> = Either<Errors, A>;
export type Is<A> = Refinement<unknown, A>;
export type Encode<A, O> = (a: A) => O;
export type Decode<I, A> = (input: I, context: Context) => Validation<A>;
export interface Decoder<I, A> {
    readonly name: string;
    decode: Decode<I, A>;
}
export type Trail = ReadonlyArray<TrailEntry>;
export interface Context {
    trail: Trail;
    success<TValue>(value: TValue): Validation<TValue>;
    failures<TValue>(errors: Errors): Validation<TValue>;
    failure<TValue>(message?: string): Validation<TValue>;
    child<TCodec extends ANY>(key: string, codec: TCodec, input: unknown): Context;
}
export type IContext = Context;
export declare class ValidationError extends Error {
    readonly trail: Trail;
    constructor(trail: Trail, message?: string);
    get value(): unknown;
}
export type ANY = Codec<any, any, any>;
export type MIXED<T = any> = Codec<T, any, unknown>;
export type TypeOf<T extends ANY> = T["_A"];
export type InputOf<T extends ANY> = T["_I"];
export type OutputOf<T extends ANY> = T["_O"];
export type TypeOf$<T> = T extends ANY ? T["_A"] : never;
export type InputOf$<T> = T extends ANY ? T["_I"] : never;
export type OutputOf$<T> = T extends ANY ? T["_O"] : never;
interface $TypeOf extends HKT {
    readonly type: TypeOf$<this["_A"]>;
}
interface $OutputOf extends HKT {
    readonly type: OutputOf$<this["_A"]>;
}
interface $InputOf extends HKT {
    readonly type: InputOf$<this["_A"]>;
}
interface $PropsOf extends HKT {
    readonly type: PropsOf<this["_A"]>;
}
export type Props = {
    [K in string]: ANY;
};
type WithProps = {
    props: Props;
} | {
    codec: WithProps;
};
type PropsOf<TCodec> = TCodec extends {
    props: infer P extends Props;
} ? P : TCodec extends {
    codec: infer P;
} ? PropsOf<P> : {};
export declare abstract class Codec<A, O = A, I = unknown> implements Decoder<I, A> {
    readonly _A: A;
    readonly _I: I;
    readonly _O: O;
    readonly name: string;
    protected constructor(name: string);
    abstract is(input: unknown): input is A;
    abstract encode(value: A): O;
    abstract decode(input: I, context: Context): Validation<A>;
    pipe<B, IB, A extends IB, OB extends A>(this: Type<A, O, I>, ab: Type<B, OB, IB>, name?: string): Type<B, O, I>;
}
export declare class PipeCodec<O, I, B, IB, A extends IB, OB extends A> extends Codec<B, O, I> {
    #private;
    constructor(a: Codec<A, O, I>, b: Codec<B, OB, IB>, name?: string);
    decode(input: A extends ANY ? A["_I"] : never, context: Context): Validation<B>;
    encode(value: B): O;
    is(input: unknown): input is B;
}
export declare function identity<T>(value: T): T;
export declare class TrivialCodec<T> extends Codec<T> {
    readonly is: Is<T>;
    constructor(name: string, is: Is<T>);
    encode: typeof identity;
    decode(input: unknown, context: Context): Validation<T>;
}
export declare const nullCodec: TrivialCodec<null>;
export declare const undefinedCodec: TrivialCodec<undefined>;
export declare const voidCodec: TrivialCodec<void>;
export declare const string: TrivialCodec<string>;
export declare const number: TrivialCodec<number>;
export declare const boolean: TrivialCodec<boolean>;
export declare const bigint: TrivialCodec<bigint>;
export declare const unknown: TrivialCodec<unknown>;
export declare const object: TrivialCodec<object>;
export declare class LiteralCodec<TValue extends string | number | boolean> extends TrivialCodec<TValue> {
    private readonly value;
    readonly keys: TValue[];
    constructor(value: TValue, name?: string);
}
export declare function literal<TValue extends string | number | boolean>(value: TValue, name?: string): LiteralCodec<TValue>;
export declare const unknownArray: TrivialCodec<unknown[]>;
export declare const unknownRecord: TrivialCodec<Record<string, unknown>>;
export declare class ArrayCodec<TCodec extends MIXED> extends Codec<Array<TypeOf<TCodec>>, Array<OutputOf<TCodec>>> {
    readonly item: TCodec;
    constructor(item: TCodec, name: string);
    decode(input: Array<InputOf<TCodec>>, context: Context): Validation<Array<TypeOf<TCodec>>>;
    encode(value: Array<TypeOf<TCodec>>): Array<OutputOf<TCodec>>;
    is(input: unknown): input is Array<TypeOf<TCodec>>;
}
export declare function array<TCodec extends MIXED>(item: TCodec, name?: string): Codec<Array<TypeOf<TCodec>>, Array<OutputOf<TCodec>>> & {
    item: TCodec;
};
export declare const any: TrivialCodec<any>;
export declare const never: TrivialCodec<never>;
export declare function getInterfaceTypeName(props: Props): string;
export declare function getNameFromProps(props: Props): string;
export declare class TypeCodec<P extends Props> extends Codec<MapOver<P, $TypeOf>, MapOver<P, $OutputOf>> {
    readonly props: P;
    constructor(props: P, name?: string);
    decode(input: unknown, context: Context): Either<Errors, MapOver<P, $TypeOf>>;
    encode(value: MapOver<P, $TypeOf>): MapOver<P, $OutputOf>;
    is(input: unknown): input is MapOver<P, $TypeOf>;
}
export declare function type<P extends Props>(props: P, name?: string): TypeCodec<P>;
export declare class UnionCodec<TCodecs extends [MIXED, MIXED, ...Array<MIXED>]> extends Codec<TypeOf<TCodecs[number]>, OutputOf<TCodecs[number]>> {
    readonly codecs: TCodecs;
    constructor(codecs: TCodecs, name?: string);
    decode(input: unknown, context: Context): Validation<TypeOf<TCodecs[number]>>;
    encode(value: TypeOf<TCodecs[number]>): OutputOf<TCodecs[number]>;
    is(input: unknown): input is TypeOf<TCodecs[number]>;
}
export declare function union<TCodecs extends [MIXED, MIXED, ...Array<MIXED>]>(codecs: TCodecs, name?: string): UnionCodec<TCodecs>;
export declare function getFunctionName(f: Function): string;
export declare class RefinementCodec<TCodec extends ANY, B extends TypeOf<TCodec> = TypeOf<TCodec>> extends Codec<B, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec;
    readonly predicate: Predicate<TypeOf<TCodec>>;
    constructor(codec: TCodec, predicate: Predicate<TypeOf<TCodec>>, name?: string);
    decode(input: InputOf<TCodec>, context: Context): Validation<B>;
    encode(value: B): OutputOf<TCodec>;
    is(input: unknown): input is B;
}
export declare function refinement<TCodec extends ANY, B extends TypeOf<TCodec>>(codec: TCodec, predicate: Refinement<TypeOf<TCodec>, B>, name?: string): RefinementCodec<TCodec, B>;
export declare function refinement<TCodec extends ANY, B extends TypeOf<TCodec>>(codec: TCodec, predicate: Predicate<TypeOf<TCodec>>, name?: string): RefinementCodec<TCodec, TypeOf<TCodec>>;
export declare class DefaultsCodec<TCodec extends ANY> extends Codec<TypeOf<TCodec>, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec;
    readonly replacement: TypeOf<TCodec>;
    readonly is: Is<TypeOf<TCodec>>;
    readonly encode: Encode<TypeOf<TCodec>, OutputOf<TCodec>>;
    constructor(codec: TCodec, replacement: TypeOf<TCodec>, name?: string);
    decode(input: InputOf<TCodec>, context: Context): Validation<TypeOf<TCodec>>;
}
export declare function defaults<TCodec extends ANY>(codec: TCodec, replacement: TypeOf<TCodec>, name?: string): DefaultsCodec<TCodec>;
export declare class ReplacementCodec<TCodec extends ANY> extends Codec<TypeOf<TCodec>, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec;
    readonly replacement: InputOf<TCodec>;
    readonly is: Is<TypeOf<TCodec>>;
    readonly encode: Encode<TypeOf<TCodec>, OutputOf<TCodec>>;
    constructor(codec: TCodec, replacement: InputOf<TCodec>, name?: string);
    decode(input: InputOf<TCodec>, context: Context): Validation<TypeOf<TCodec>>;
}
export declare function replacement<TCodec extends ANY>(codec: TCodec, replacement: InputOf<TCodec>, name?: string): ReplacementCodec<TCodec>;
export declare class PostprocessDecodeCodec<TCodec extends ANY> extends Codec<TypeOf<TCodec>, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec;
    readonly onDecode: (input: TypeOf<TCodec>) => TypeOf<TCodec>;
    readonly is: Is<TypeOf<TCodec>>;
    readonly encode: Encode<TypeOf<TCodec>, OutputOf<TCodec>>;
    constructor(codec: TCodec, onDecode: (input: TypeOf<TCodec>) => TypeOf<TCodec>, name?: string);
    decode(input: InputOf<TCodec>, context: Context): Validation<TypeOf<TCodec>>;
}
/**
 * Replace input in runtime for `codec`. For example, change `${CWD}` in the input to a current working dir.
 */
export declare function postprocessDecode<TCodec extends ANY>(codec: TCodec, replacementFn: PostprocessDecodeCodec<TCodec>["onDecode"], name?: string): PostprocessDecodeCodec<TCodec>;
export declare class TupleCodec<TCodecs extends [MIXED, ...Array<MIXED>]> extends Codec<MapOver<TCodecs, $TypeOf>, MapOver<TCodecs, $OutputOf>> {
    readonly codecs: TCodecs;
    readonly name: string;
    constructor(codecs: TCodecs, name?: string);
    decode(input: MapOver<TCodecs, $InputOf>, context: Context): Validation<MapOver<TCodecs, $TypeOf>>;
    encode(value: MapOver<TCodecs, $TypeOf>): MapOver<TCodecs, $OutputOf>;
    is(input: unknown): input is MapOver<TCodecs, $TypeOf>;
}
export declare function tuple<TCodecs extends NonEmptyArray<MIXED>>(codecs: TCodecs, name?: string): TupleCodec<TCodecs>;
export declare class ExactCodec<TCodec extends ANY> extends Codec<TypeOf<TCodec>, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec & WithProps;
    readonly props: PropsOf<TCodec>;
    constructor(codec: TCodec & WithProps, name?: string);
    is(input: unknown): input is InputOf<TCodec>;
    decode(input: InputOf<TCodec>, context: Context): Validation<TypeOf<TCodec>>;
    encode(value: TypeOf<TCodec>): OutputOf<TCodec>;
}
export declare function exact<TCodec extends ANY & WithProps>(codec: TCodec, name?: string): ExactCodec<TCodec>;
export declare function strict<P extends Props>(props: P, name?: string): ExactCodec<TypeCodec<P>>;
export declare class ReadonlyCodec<TCodec extends ANY> extends Codec<Readonly<TypeOf<TCodec>>, OutputOf<TCodec>, InputOf<TCodec>> {
    readonly codec: TCodec;
    readonly name: string;
    constructor(codec: TCodec, name?: string);
    is: (input: unknown) => input is any;
    encode: (value: any) => any;
    decode: (input: any, context: Context) => Validation<any>;
}
export declare function readonly<TCodec extends ANY>(codec: TCodec, name?: string): ReadonlyCodec<TCodec>;
export declare class PartialCodec<P extends Props> extends Codec<Partial<MapOver<P, $TypeOf>>, Partial<MapOver<P, $OutputOf>>> {
    readonly props: P;
    constructor(props: P, name?: string);
    encode(value: Partial<MapOver<P, $TypeOf>>): Partial<MapOver<P, $OutputOf>>;
    is(input: unknown): input is Partial<MapOver<P, $TypeOf>>;
    decode(input: unknown, context: Context): Validation<Partial<MapOver<P, $TypeOf>>>;
}
export declare function partial<P extends Props>(props: P, name?: string): PartialCodec<P>;
export declare function mergeAll(base: any, us: Array<any>): any;
export declare class IntersectionCodec<TCodecs extends Readonly<Array<ANY>>> extends Codec<Intersection<MapOver<TCodecs, $TypeOf>>, Intersection<MapOver<TCodecs, $OutputOf>>, Intersection<MapOver<TCodecs, $InputOf>>> {
    readonly codecs: TCodecs;
    readonly props: Intersection<MapOver<TCodecs, $PropsOf>>;
    constructor(codecs: TCodecs, name?: string);
    encode(value: Intersection<MapOver<TCodecs, $TypeOf>>): Intersection<MapOver<TCodecs, $OutputOf>>;
    is(input: unknown): input is Intersection<MapOver<TCodecs, $TypeOf>>;
    decode(input: unknown, context: Context): Validation<Intersection<MapOver<TCodecs, $TypeOf>>>;
}
export declare function intersection<TCodecs extends readonly ANY[]>(codecs: TCodecs, name?: string): IntersectionCodec<TCodecs>;
export declare class KeyOfCodec<D extends Record<string, unknown>> extends TrivialCodec<keyof D> {
    readonly keys: string[];
    constructor(keys: Array<string>, name: string, is: Is<keyof D>);
}
export declare function keyof<D extends Record<string, unknown>>(keys: D, name?: string): KeyOfCodec<D>;
/**
 * Codec for `Record<string, codec>` where `string` could be replaced by a string-like non-enumerable codec.
 * @see EnumerableRecordCodec
 */
export declare class NonEnumerableRecordCodec<D extends MIXED, C extends MIXED> extends Codec<{
    [K in TypeOf<D>]: TypeOf<C>;
}, {
    [K in OutputOf<D>]: OutputOf<C>;
}> {
    readonly domain: D;
    readonly codomain: C;
    constructor(domain: D, codomain: C, name?: string);
    decode(input: unknown, context: Context): Validation<{
        [K in TypeOf<D>]: TypeOf<C>;
    }>;
    encode(value: {
        [K in TypeOf<D>]: TypeOf<C>;
    }): {
        [K in OutputOf<D>]: OutputOf<C>;
    };
    is(input: unknown): input is {
        [K in TypeOf<D>]: TypeOf<C>;
    };
}
export declare class EnumerableRecordCodec<D extends MIXED & EnumerableRecordDomain, C extends MIXED> extends Codec<{
    [K in TypeOf<D>]: TypeOf<C>;
}, {
    [K in OutputOf<D>]: OutputOf<C>;
}> {
    readonly domain: D;
    readonly codomain: C;
    readonly keys: string[];
    constructor(domain: D, codomain: C, name?: string);
    decode(input: unknown, context: Context): Validation<{
        [K in TypeOf<D>]: TypeOf<C>;
    }>;
    encode(value: {
        [K in TypeOf<D>]: TypeOf<C>;
    }): {
        [K in OutputOf<D>]: OutputOf<C>;
    };
    is(input: unknown): input is {
        [K in TypeOf<D>]: TypeOf<C>;
    };
}
export interface EnumerableRecordDomain {
    keys: string[];
}
export declare function record<D extends MIXED<string>, C extends MIXED>(domain: D, codomain: C, name?: string): NonEnumerableRecordCodec<D, C>;
export declare function record<D extends MIXED<string>, C extends MIXED>(domain: D & EnumerableRecordDomain, codomain: C, name?: string): EnumerableRecordCodec<D & EnumerableRecordDomain, C>;
/**
 * Slight compatibility layer with io-ts codecs
 */
export declare class Type<A, O = A, I = unknown> extends Codec<A, O, I> {
    /** a unique name for this codec */
    readonly name: string;
    /** a custom type guard */
    readonly is: Is<A>;
    /** succeeds if a value of type I can be decoded to a value of type A */
    readonly decode: Decode<I, A>;
    /** converts a value of type A to a value of type O */
    readonly encode: Encode<A, O>;
    constructor(
    /** a unique name for this codec */
    name: string, 
    /** a custom type guard */
    is: Is<A>, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode: Decode<I, A>, 
    /** converts a value of type A to a value of type O */
    encode: Encode<A, O>);
}
export declare class RecursiveCodec<C extends ANY, A, O = A, I = unknown> extends Codec<A, O, I> {
    /** a unique name for this codec */
    readonly name: string;
    /** a custom type guard */
    readonly is: Is<A>;
    /** succeeds if a value of type I can be decoded to a value of type A */
    readonly decode: Decode<I, A>;
    /** converts a value of type A to a value of type O */
    readonly encode: Encode<A, O>;
    private readonly runDefinition;
    constructor(
    /** a unique name for this codec */
    name: string, 
    /** a custom type guard */
    is: Is<A>, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode: Decode<I, A>, 
    /** converts a value of type A to a value of type O */
    encode: Encode<A, O>, runDefinition: () => C);
    get codec(): C;
}
export declare function recursive<A, O = A, I = unknown, C extends Codec<A, O, I> = Codec<A, O, I>>(name: string, definition: (self: C) => C): RecursiveCodec<C, A, O, I>;
type OptionalFlag = {
    optional: true;
};
export declare function optional<C extends ANY>(codec: C, name?: string): OptionalCodec<C>;
export declare class OptionalCodec<C extends ANY> extends Codec<TypeOf<C> | undefined, OutputOf<C> | undefined, InputOf<C> | undefined> {
    #private;
    readonly name: string;
    readonly optional: true;
    constructor(codec: C, name?: string);
    decode(input: InputOf<C> | undefined, context: Context): Validation<TypeOf<C> | undefined>;
    encode(value: TypeOf<C> | undefined): OutputOf<C> | undefined;
    is(input: unknown): input is TypeOf<C> | undefined;
}
export declare function isOptionalCodec<C extends ANY>(codec: C | OptionalCodec<C>): codec is OptionalCodec<C>;
type RequiredPropsKeys<P extends Props> = {
    [K in keyof P]: P[K] extends OptionalFlag ? never : K;
}[keyof P];
type RequiredProps<P extends Props> = {
    [K in RequiredPropsKeys<P>]: P[K];
};
type OptionalProps<P extends Props> = {
    [K in Exclude<keyof P, RequiredPropsKeys<P>>]?: P[K];
};
export declare class SparseCodec<P extends Props> extends Codec<MapOver<RequiredProps<P>, $TypeOf> & MapOver<OptionalProps<P>, $TypeOf>, MapOver<RequiredProps<P>, $OutputOf> & MapOver<OptionalProps<P>, $OutputOf>> {
    #private;
    readonly props: P;
    constructor(props: P, name?: string);
    decode(input: unknown, context: Context): Either<Errors, MapOver<P, $TypeOf>>;
    encode(value: MapOver<RequiredProps<P>, $TypeOf> & MapOver<OptionalProps<P>, $TypeOf>): MapOver<P, $OutputOf>;
    is(input: unknown): input is MapOver<RequiredProps<P>, $TypeOf> & MapOver<OptionalProps<P>, $TypeOf>;
}
export declare function sparseType<P extends Props>(props: P, name?: string): SparseCodec<P>;
export declare const sparse: typeof sparseType;
export { nullCodec as null, undefinedCodec as undefined, voidCodec as void };
