import { isLeft, right } from "./either.js";
import { LazyContext } from "./decoder.js";
export function isNonEmpty(array) {
    return array.length > 0;
}
function getContextPath(trail) {
    return `/` + trail.map(({ key, type }) => `${key}(${type.name})`).join("/");
}
function stringify(v) {
    if (typeof v === "function") {
        return getFunctionName(v);
    }
    if (typeof v === "number" && !isFinite(v)) {
        if (isNaN(v)) {
            return "NaN";
        }
        return v > 0 ? "Infinity" : "-Infinity";
    }
    return JSON.stringify(v);
}
export class ValidationError extends Error {
    trail;
    constructor(trail, message = `Invalid value ${stringify(trail[trail.length - 1].actual)} supplied to ${getContextPath(trail)}`) {
        super(message);
        this.trail = trail;
    }
    get value() {
        return this.trail[this.trail.length - 1].actual;
    }
}
export class Codec {
    _A;
    _I;
    _O;
    name;
    constructor(name) {
        this.name = name;
    }
    pipe(ab, name = `${this.name}→${ab.name}`) {
        return new Type(name, ab.is, (i, c) => {
            const e = this.decode(i, c);
            if (isLeft(e)) {
                return e;
            }
            return ab.decode(e.right, c);
        }, this.encode === identity && ab.encode === identity ? identity : (b) => this.encode(ab.encode(b)));
    }
}
export class PipeCodec extends Codec {
    #a;
    #b;
    constructor(a, b, name = `${a.name}→${b.name}`) {
        super(name);
        this.#a = a;
        this.#b = b;
    }
    decode(input, context) {
        const aE = this.#a.decode(input, context);
        if (isLeft(aE))
            return aE;
        const a = aE.right;
        return this.#b.decode(a, context);
    }
    encode(value) {
        return this.#a.encode(this.#b.encode(value));
    }
    is(input) {
        return this.#b.is(input);
    }
}
export function identity(value) {
    return value;
}
export class TrivialCodec extends Codec {
    is;
    constructor(name, is) {
        super(name);
        this.is = is;
    }
    encode = identity;
    decode(input, context) {
        if (this.is(input)) {
            return context.success(input);
        }
        else {
            return context.failure();
        }
    }
}
export const nullCodec = new TrivialCodec("null", (input) => input === null);
export const undefinedCodec = new TrivialCodec("undefined", (input) => input === undefined);
export const voidCodec = new TrivialCodec("void", (input) => input === undefined);
export const string = new TrivialCodec("string", (input) => typeof input === "string");
export const number = new TrivialCodec("number", (input) => typeof input === "number");
export const boolean = new TrivialCodec("boolean", (input) => typeof input === "boolean");
export const bigint = new TrivialCodec("bigint", (input) => typeof input === "bigint");
export const unknown = new TrivialCodec("unknown", (input) => true);
export const object = new TrivialCodec("object", (input) => Boolean(input) && typeof input === "object");
export class LiteralCodec extends TrivialCodec {
    value;
    keys;
    constructor(value, name = JSON.stringify(value)) {
        super(name, (input) => input === value);
        this.value = value;
        this.keys = [value];
    }
}
export function literal(value, name) {
    return new LiteralCodec(value, name);
}
export const unknownArray = new TrivialCodec("UnknownArray", (input) => Array.isArray(input));
export const unknownRecord = new TrivialCodec("UnknownDictionary", (input) => {
    const isObjectLike = Boolean(input) && typeof input === "object";
    if (!isObjectLike)
        return false;
    const isArrayLike = Array.isArray(input);
    if (isArrayLike)
        return false;
    const proto = Object.getPrototypeOf(input);
    if (!proto)
        return true;
    const Ctor = Object.hasOwn(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Ctor.toString() == Object.toString();
});
export class ArrayCodec extends Codec {
    item;
    constructor(item, name) {
        super(name);
        this.item = item;
    }
    decode(input, context) {
        const decodedArrayE = unknownArray.decode(input, context);
        if (isLeft(decodedArrayE))
            return decodedArrayE;
        const decodedArray = decodedArrayE.right;
        const errors = [];
        const result = new Array(decodedArray.length);
        decodedArray.forEach((item, index) => {
            const decoded = this.item.decode(item, context.child(String(index), this.item, item));
            if (isLeft(decoded)) {
                decoded.left.forEach((e) => errors.push(e));
            }
            else {
                result[index] = decoded.right;
            }
        });
        if (isNonEmpty(errors)) {
            return context.failures(errors);
        }
        else {
            return context.success(result);
        }
    }
    encode(value) {
        if (this.item.encode === identity) {
            return value;
        }
        else {
            return value.map(this.item.encode);
        }
    }
    is(input) {
        return unknownArray.is(input) && input.every((item) => this.item.is(item));
    }
}
export function array(item, name = `${item.name}[]`) {
    return new ArrayCodec(item, name);
}
export const any = new TrivialCodec("any", (input) => true);
export const never = new TrivialCodec("never", (input) => false);
export function getInterfaceTypeName(props) {
    return `{${getNameFromProps(props)}}`;
}
export function getNameFromProps(props) {
    return Object.keys(props)
        .map((k) => `${k}:${props[k].name}`)
        .join(",");
}
export class TypeCodec extends Codec {
    props;
    constructor(props, name = getInterfaceTypeName(props)) {
        super(name);
        this.props = props;
    }
    decode(input, context) {
        const inputE = object.decode(input, context);
        if (isLeft(inputE))
            return inputE;
        const inputObject = inputE.right;
        const output = { ...inputObject };
        const errors = [];
        Object.entries(this.props).forEach(([propName, propCodec]) => {
            const inputProperty = inputObject[propName];
            const result = propCodec.decode(inputProperty, context.child(propName, propCodec, inputProperty));
            if (isLeft(result)) {
                result.left.forEach((e) => errors.push(e));
            }
            else {
                output[propName] = result.right;
            }
        });
        return isNonEmpty(errors) ? context.failures(errors) : context.success(output);
    }
    encode(value) {
        const s = { ...value };
        Object.entries(this.props).forEach(([propName, propCodec]) => {
            s[propName] = propCodec.encode(s[propName]);
        });
        return s;
    }
    is(input) {
        if (!object.is(input))
            return false;
        const inputObject = input;
        return Object.entries(this.props).every(([propName, propCodec]) => {
            const inputEntry = inputObject[propName];
            if (inputEntry) {
                return propCodec.is(inputEntry);
            }
            else {
                return Object.hasOwn(input, propName) && propCodec.is(inputEntry);
            }
        });
    }
}
export function type(props, name) {
    return new TypeCodec(props, name);
}
function getUnionName(codecs) {
    return codecs.map((type) => type.name).join("|");
}
export class UnionCodec extends Codec {
    codecs;
    constructor(codecs, name = getUnionName(codecs)) {
        super(name);
        this.codecs = codecs;
    }
    decode(input, context) {
        const errors = [];
        for (const [index, codec] of this.codecs.entries()) {
            try {
                const result = codec.decode(input, context.child(String(index), codec, input));
                if (isLeft(result)) {
                    result.left.forEach((e) => errors.push(e));
                }
                else {
                    return context.success(result.right);
                }
            }
            catch (e) {
                errors.push(e);
            }
        }
        return context.failures(errors);
    }
    encode(value) {
        for (const codec of this.codecs) {
            if (codec.is(value)) {
                return codec.encode(value);
            }
        }
        throw new Error(`no codec found to encode value in union type ${this.name}`);
    }
    is(input) {
        return this.codecs.some((c) => c.is(input));
    }
}
export function union(codecs, name) {
    return new UnionCodec(codecs, name);
}
export function getFunctionName(f) {
    return f.displayName || f.name || `<function${f.length}>`;
}
export class RefinementCodec extends Codec {
    codec;
    predicate;
    constructor(codec, predicate, name = `${codec.name}≍${getFunctionName(predicate)}`) {
        super(name);
        this.codec = codec;
        this.predicate = predicate;
    }
    decode(input, context) {
        const decodedE = this.codec.decode(input, context);
        if (isLeft(decodedE))
            return decodedE;
        if (this.predicate(decodedE.right)) {
            return decodedE;
        }
        else {
            return context.failure();
        }
    }
    encode(value) {
        return this.codec.encode(value);
    }
    is(input) {
        return this.codec.is(input) && this.predicate(input);
    }
}
export function refinement(codec, predicate, name) {
    return new RefinementCodec(codec, predicate, name);
}
export class DefaultsCodec extends Codec {
    codec;
    replacement;
    is;
    encode;
    constructor(codec, replacement, name = `(${codec.name} ❮ ${replacement})`) {
        super(name);
        this.codec = codec;
        this.replacement = replacement;
        this.is = this.codec.is.bind(this.codec);
        this.encode = this.codec.encode.bind(this.codec);
    }
    decode(input, context) {
        const decodedE = this.codec.decode(input, new LazyContext(context.trail));
        if (isLeft(decodedE)) {
            return context.success(this.replacement);
        }
        else {
            return decodedE;
        }
    }
}
export function defaults(codec, replacement, name) {
    return new DefaultsCodec(codec, replacement, name);
}
export class ReplacementCodec extends Codec {
    codec;
    replacement;
    is;
    encode;
    constructor(codec, replacement, name = `(${codec.name} ❮❮ ${replacement})`) {
        super(name);
        this.codec = codec;
        this.replacement = replacement;
        this.is = this.codec.is.bind(this.codec);
        this.encode = this.codec.encode.bind(this.codec);
    }
    decode(input, context) {
        const decodedE = this.codec.decode(input, new LazyContext(context.trail));
        if (isLeft(decodedE)) {
            return this.codec.decode(this.replacement, context);
        }
        else {
            return decodedE;
        }
    }
}
export function replacement(codec, replacement, name) {
    return new ReplacementCodec(codec, replacement, name);
}
export class PostprocessDecodeCodec extends Codec {
    codec;
    onDecode;
    is;
    encode;
    constructor(codec, onDecode, name = `(${codec.name} ❮❮ ??})`) {
        super(name);
        this.codec = codec;
        this.onDecode = onDecode;
        this.is = this.codec.is.bind(this.codec);
        this.encode = this.codec.encode.bind(this.codec);
    }
    decode(input, context) {
        const decodedE = this.codec.decode(input, new LazyContext(context.trail));
        if (isLeft(decodedE)) {
            return decodedE;
        }
        else {
            return right(this.onDecode(decodedE.right));
        }
    }
}
/**
 * Replace input in runtime for `codec`. For example, change `${CWD}` in the input to a current working dir.
 */
export function postprocessDecode(codec, replacementFn, name) {
    return new PostprocessDecodeCodec(codec, replacementFn, name);
}
export class TupleCodec extends Codec {
    codecs;
    name;
    constructor(codecs, name = `[${codecs.map((type) => type.name).join(",")}]`) {
        super(name);
        this.codecs = codecs;
        this.name = name;
    }
    decode(input, context) {
        const arrayE = unknownArray.decode(input, context);
        if (isLeft(arrayE))
            return arrayE;
        const array = arrayE.right;
        // strip additional components
        let result = array.length > this.codecs.length ? array.slice(0, this.codecs.length) : array;
        const errors = [];
        for (const [index, codec] of this.codecs.entries()) {
            const decodedE = codec.decode(array[index], context.child(String(index), codec, array[index]));
            if (isLeft(decodedE)) {
                decodedE.left.forEach((e) => errors.push(e));
            }
            else {
                result[index] = decodedE.right;
            }
        }
        return isNonEmpty(errors) ? context.failures(errors) : context.success(result);
    }
    encode(value) {
        return this.codecs.map((type, i) => type.encode(value[i]));
    }
    is(input) {
        return (unknownArray.is(input) && input.length === this.codecs.length && this.codecs.every((type, i) => type.is(input[i])));
    }
}
export function tuple(codecs, name) {
    return new TupleCodec(codecs, name);
}
function stripKeys(o, props) {
    const keys = Object.getOwnPropertyNames(o);
    let shouldStrip = false;
    const r = {};
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!Object.hasOwn(props, key)) {
            shouldStrip = true;
        }
        else {
            r[key] = o[key];
        }
    }
    return shouldStrip ? r : o;
}
export class ExactCodec extends Codec {
    codec;
    props;
    constructor(codec, name = `Exact<${codec.name}>`) {
        super(name);
        this.codec = codec;
        this.props = getProps(codec);
    }
    is(input) {
        return this.codec.is(input);
    }
    decode(input, context) {
        const dictionaryE = object.decode(input, context);
        if (isLeft(dictionaryE))
            return dictionaryE;
        const dictionaryDecoded = dictionaryE.right;
        return this.codec.decode(stripKeys(dictionaryDecoded, this.props), context);
    }
    encode(value) {
        return this.codec.encode(stripKeys(value, this.props));
    }
}
export function exact(codec, name) {
    return new ExactCodec(codec, name);
}
function hasOwnProps(codec) {
    return "props" in codec;
}
function hasOwnCodec(codec) {
    return "codec" in codec;
}
function hasOwnCodecs(codec) {
    return "codecs" in codec;
}
function getProps(codec) {
    if (hasOwnProps(codec))
        return codec.props;
    if (hasOwnCodec(codec))
        return getProps(codec.codec);
    if (hasOwnCodecs(codec))
        return Object.assign({}, ...codec.codecs.map((c) => getProps(c)));
    return {};
}
export function strict(props, name) {
    return exact(type(props), name);
}
export class ReadonlyCodec extends Codec {
    codec;
    name;
    constructor(codec, name = `Readonly<${codec.name}>`) {
        super(name);
        this.codec = codec;
        this.name = name;
    }
    is = this.codec.is.bind(this.codec);
    encode = this.codec.encode.bind(this.codec);
    decode = this.codec.decode.bind(this.codec);
}
export function readonly(codec, name) {
    return new ReadonlyCodec(codec, name);
}
export class PartialCodec extends Codec {
    props;
    constructor(props, name = `Partial<${getInterfaceTypeName(props)}>`) {
        super(name);
        this.props = props;
    }
    encode(value) {
        const s = { ...value };
        Object.entries(this.props).forEach(([propName, propCodec]) => {
            const inputEntry = value[propName];
            if (inputEntry) {
                s[propName] = propCodec.encode(inputEntry);
            }
        });
        return s;
    }
    is(input) {
        if (!unknownRecord.is(input))
            return false;
        return Object.entries(this.props).every(([propName, propCodec]) => {
            const inputEntry = input[propName];
            if (inputEntry) {
                return propCodec.is(inputEntry);
            }
            else {
                return true;
            }
        });
    }
    decode(input, context) {
        const dictionaryE = unknownRecord.decode(input, context);
        if (isLeft(dictionaryE))
            return dictionaryE;
        const dictionary = dictionaryE.right;
        const errors = [];
        const result = { ...dictionary };
        for (const [propName, propCodec] of Object.entries(this.props)) {
            const inputEntry = dictionary[propName];
            const decodedE = propCodec.decode(inputEntry, context.child(propName, propCodec, inputEntry));
            if (isLeft(decodedE)) {
                if (inputEntry)
                    decodedE.left.forEach((e) => errors.push(e));
            }
            else {
                result[propName] = decodedE.right;
            }
        }
        return isNonEmpty(errors) ? context.failures(errors) : context.success(result);
    }
}
export function partial(props, name) {
    return new PartialCodec(props, name);
}
// FIXME Replace with Object.assign
// It is shallow anyway
export function mergeAll(base, us) {
    let equal = true;
    let primitive = true;
    const baseIsNotADictionary = !unknownRecord.is(base);
    for (const u of us) {
        if (u !== base) {
            equal = false;
        }
        if (unknownRecord.is(u)) {
            primitive = false;
        }
    }
    if (equal) {
        return base;
    }
    else if (primitive) {
        return us[us.length - 1];
    }
    const r = {};
    for (const u of us) {
        for (const k in u) {
            if (!Object.hasOwn(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
                r[k] = u[k];
            }
        }
    }
    return r;
}
export class IntersectionCodec extends Codec {
    codecs;
    props;
    constructor(codecs, name = `${codecs.map((c) => c.name).join("&")}`) {
        super(name);
        this.codecs = codecs;
        this.props = Object.assign({}, ...codecs.map((c) => getProps(c)));
    }
    encode(value) {
        return mergeAll(value, this.codecs.map((codec) => codec.encode(value)));
    }
    is(input) {
        return this.codecs.every((codec) => codec.is(input));
    }
    decode(input, context) {
        const us = [];
        const errors = [];
        for (const [index, codec] of this.codecs.entries()) {
            const result = codec.decode(input, context.child(String(index), codec, input));
            if (isLeft(result)) {
                result.left.forEach((e) => errors.push(e));
            }
            else {
                us.push(result.right);
            }
        }
        if (isNonEmpty(errors)) {
            return context.failures(errors);
        }
        else {
            return context.success(mergeAll(input, us));
        }
    }
}
export function intersection(codecs, name) {
    return new IntersectionCodec(codecs, name);
}
export class KeyOfCodec extends TrivialCodec {
    keys;
    constructor(keys, name, is) {
        super(name, is);
        this.keys = keys;
    }
}
export function keyof(keys, name = Object.keys(keys)
    .map((k) => JSON.stringify(k))
    .join("|")) {
    return new KeyOfCodec(Object.keys(keys), name, (input) => string.is(input) && Object.hasOwn(keys, input));
}
/**
 * Codec for `Record<string, codec>` where `string` could be replaced by a string-like non-enumerable codec.
 * @see EnumerableRecordCodec
 */
export class NonEnumerableRecordCodec extends Codec {
    domain;
    codomain;
    constructor(domain, codomain, name = `{[${domain.name}]:${codomain.name}}`) {
        super(name);
        this.domain = domain;
        this.codomain = codomain;
    }
    decode(input, context) {
        const dictionaryE = unknownRecord.decode(input, context);
        if (isLeft(dictionaryE))
            return dictionaryE;
        const dictionary = dictionaryE.right;
        const result = {};
        const errors = [];
        for (const [name, prop] of Object.entries(dictionary)) {
            const domainResult = this.domain.decode(name, context.child(name, this.domain, name));
            if (isLeft(domainResult)) {
                domainResult.left.forEach((e) => errors.push(e));
            }
            else {
                const codomainResult = this.codomain.decode(prop, context.child(name, this.codomain, prop));
                if (isLeft(codomainResult)) {
                    codomainResult.left.forEach((e) => errors.push(e));
                }
                else {
                    result[domainResult.right] = codomainResult.right;
                }
            }
        }
        if (isNonEmpty(errors)) {
            return context.failures(errors);
        }
        else {
            return context.success(result);
        }
    }
    encode(value) {
        const result = {};
        for (const [name, valueItem] of Object.entries(value)) {
            result[String(this.domain.encode(name))] = this.codomain.encode(valueItem);
        }
        return result;
    }
    is(input) {
        if (!unknownRecord.is(input))
            return false;
        const entries = Object.entries(input);
        if (entries.length == 0)
            return true;
        return entries.some(([key, value]) => this.domain.is(key) && this.codomain.is(value));
    }
}
export class EnumerableRecordCodec extends Codec {
    domain;
    codomain;
    keys;
    constructor(domain, codomain, name = `{[${domain.name}]:${codomain.name}}`) {
        super(name);
        this.domain = domain;
        this.codomain = codomain;
        this.keys = domain.keys;
    }
    decode(input, context) {
        const recordE = unknownRecord.decode(input, context);
        if (isLeft(recordE))
            return recordE;
        const inputRecord = recordE.right;
        const result = {};
        const errors = [];
        for (const k of this.keys) {
            const inputElement = inputRecord[k];
            const codomainResult = this.codomain.decode(inputElement, context.child(k, this.codomain, inputElement));
            if (isLeft(codomainResult)) {
                codomainResult.left.forEach((e) => errors.push(e));
            }
            else {
                result[k] = codomainResult.right;
            }
        }
        if (isNonEmpty(errors)) {
            return context.failures(errors);
        }
        else {
            return context.success(result);
        }
    }
    encode(value) {
        const s = {};
        for (const k of this.keys) {
            s[k] = this.codomain.encode(value[k]);
        }
        return s;
    }
    is(input) {
        return unknownRecord.is(input) && this.keys.every((k) => this.codomain.is(input[k]));
    }
}
export function record(domain, codomain, name) {
    if ("keys" in domain) {
        return new EnumerableRecordCodec(domain, codomain, name);
    }
    else {
        return new NonEnumerableRecordCodec(domain, codomain, name);
    }
}
/**
 * Slight compatibility layer with io-ts codecs
 */
export class Type extends Codec {
    name;
    is;
    decode;
    encode;
    constructor(
    /** a unique name for this codec */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode, 
    /** converts a value of type A to a value of type O */
    encode) {
        super(name);
        this.name = name;
        this.is = is;
        this.decode = decode;
        this.encode = encode;
    }
}
export class RecursiveCodec extends Codec {
    name;
    is;
    decode;
    encode;
    runDefinition;
    constructor(
    /** a unique name for this codec */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode, 
    /** converts a value of type A to a value of type O */
    encode, runDefinition) {
        super(name);
        this.name = name;
        this.is = is;
        this.decode = decode;
        this.encode = encode;
        this.runDefinition = runDefinition;
    }
    get codec() {
        return this.runDefinition();
    }
}
export function recursive(name, definition) {
    let cache;
    let Self;
    const runDefinition = () => {
        if (!cache) {
            cache = definition(Self);
            cache.name = name;
        }
        return cache;
    };
    Self = new RecursiveCodec(name, (input) => runDefinition().is(input), (input, context) => runDefinition().decode(input, context), (value) => runDefinition().encode(value), runDefinition);
    return Self;
}
export function optional(codec, name) {
    return new OptionalCodec(codec, name);
}
export class OptionalCodec extends Codec {
    name;
    optional = true;
    #codec;
    constructor(codec, name = `${codec.name}?`) {
        super(name);
        this.name = name;
        this.#codec = union([codec, undefinedCodec]);
    }
    decode(input, context) {
        return this.#codec.decode(input, context);
    }
    encode(value) {
        return this.#codec.encode(value);
    }
    is(input) {
        return this.#codec.is(input);
    }
}
export function isOptionalCodec(codec) {
    return "optional" in codec && codec.optional;
}
export class SparseCodec extends Codec {
    props;
    #codec;
    constructor(props, name = getInterfaceTypeName(props)) {
        super(name);
        this.props = props;
        this.#codec = new TypeCodec(props);
    }
    #cleanup(output) {
        Object.entries(this.props).forEach(([propName, propCodec]) => {
            if (isOptionalCodec(propCodec) && !output[propName]) {
                delete output[propName];
            }
        });
        return output;
    }
    decode(input, context) {
        const outputE = this.#codec.decode(input, context);
        if (isLeft(outputE))
            return outputE;
        return context.success(this.#cleanup(outputE.right));
    }
    encode(value) {
        const output = this.#codec.encode(value);
        return this.#cleanup(output);
    }
    is(input) {
        const effectiveInput = { ...input };
        Object.entries(this.props).forEach(([propName, propCodec]) => {
            if (isOptionalCodec(propCodec) && !effectiveInput[propName]) {
                effectiveInput[propName] = undefined;
            }
        });
        return this.#codec.is(effectiveInput);
    }
}
export function sparseType(props, name) {
    const optionalProps = {};
    const requiredProps = {};
    for (const [key, value] of Object.entries(props)) {
        if (isOptionalCodec(value)) {
            optionalProps[key] = value;
        }
        else {
            requiredProps[key] = value;
        }
    }
    return new SparseCodec(props, name);
}
export const sparse = sparseType;
export { nullCodec as null, undefinedCodec as undefined, voidCodec as void };
