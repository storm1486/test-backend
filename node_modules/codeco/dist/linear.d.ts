import { type Maybe } from "./either.js";
export type Combinator<T, P extends string | Uint8Array> = {
    (t: Tape<P>): Maybe<T>;
    name?: string;
};
type TapeSubstrate = string | Uint8Array;
export interface Tape<P extends TapeSubstrate> {
    readonly input: P;
    position: number;
    readonly isEOF: boolean;
}
export declare class StringTape implements Tape<string> {
    readonly input: string;
    position: number;
    constructor(input: string);
    get isEOF(): boolean;
}
/**
 * Reset position to `prev` and `fail`
 */
export declare function failure<P extends TapeSubstrate>(error: Error, prev: number, tape: Tape<P>): Maybe<never>;
/**
 * Just return Left<Error>
 */
export declare function fail(error: Error): Maybe<never>;
export declare function literal<P extends string>(value: string): Combinator<string, P>;
export declare function foldMap<A, B, P extends TapeSubstrate>(combinator: Combinator<A, P>, fn: (a: A) => Maybe<B>): Combinator<B, P>;
export declare function map<A, B, P extends TapeSubstrate>(combinator: Combinator<A, P>, fn: (a: A) => B): Combinator<B, P>;
export declare function match<P extends string>(pattern: RegExp | string): Combinator<string, P>;
export declare function joinSeq<P extends TapeSubstrate>(...combinators: Array<Combinator<string, P>>): Combinator<string, P>;
export declare function join<P extends TapeSubstrate>(input: Combinator<Array<string>, P>, separator?: string): Combinator<string, P>;
export declare function seq<A, B, C, D, E, F, G, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, e: Combinator<E, P>, f: Combinator<F, P>, g: Combinator<G, P>): Combinator<[A, B, C, D, E, F, G], P>;
export declare function seq<A, B, C, D, E, F, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, e: Combinator<E, P>, f: Combinator<F, P>): Combinator<[A, B, C, D, E, F], P>;
export declare function seq<A, B, C, D, E, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, e: Combinator<E, P>): Combinator<[A, B, C, D, E], P>;
export declare function seq<A, B, C, D, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>): Combinator<[A, B, C, D], P>;
export declare function seq<A, B, C, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>): Combinator<[A, B, C], P>;
export declare function seq<A, B, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>): Combinator<[A, B], P>;
export declare function seqA<T, P extends TapeSubstrate>(combinators: Array<Combinator<T, P>>): Combinator<Array<T>, P>;
export declare function option<T, P extends TapeSubstrate>(combinator: Combinator<T, P>, otherwise: T): Combinator<T, P>;
export declare function choice<A, B, C, D, G, F, H, I, J, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, g: Combinator<G, P>, f: Combinator<F, P>, h: Combinator<H, P>, i: Combinator<I, P>, j: Combinator<J, P>): Combinator<A | B | C | D | G | F | H | I | J, P>;
export declare function choice<A, B, C, D, G, F, H, I, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, g: Combinator<G, P>, f: Combinator<F, P>, h: Combinator<H, P>, i: Combinator<I, P>): Combinator<A | B | C | D | G | F | H | I, P>;
export declare function choice<A, B, C, D, G, F, H, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, g: Combinator<G, P>, f: Combinator<F, P>, h: Combinator<H, P>): Combinator<A | B | C | D | G | F | H, P>;
export declare function choice<A, B, C, D, G, F, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, g: Combinator<G, P>, f: Combinator<F, P>): Combinator<A | B | C | D | G | F, P>;
export declare function choice<A, B, C, D, G, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>, g: Combinator<G, P>): Combinator<A | B | C | D | G, P>;
export declare function choice<A, B, C, D, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>, d: Combinator<D, P>): Combinator<A | B | C | D, P>;
export declare function choice<A, B, C, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>, c: Combinator<C, P>): Combinator<A | B | C, P>;
export declare function choice<A, B, P extends TapeSubstrate>(a: Combinator<A, P>, b: Combinator<B, P>): Combinator<A | B, P>;
export declare function choice<A, P extends TapeSubstrate>(a: Combinator<A, P>): Combinator<A, P>;
export declare function sepBy<T, TSep, P extends TapeSubstrate>(element: Combinator<T, P>, separator: Combinator<TSep, P>, min?: number, max?: number): Combinator<Array<T>, P>;
export declare function many<T, P extends TapeSubstrate>(element: Combinator<T, P>, min?: number, max?: number): Combinator<Array<T>, P>;
/**
 * Consume all the input.
 */
export declare function parseAll<T, P extends TapeSubstrate>(combinator: Combinator<T, P>): Combinator<T, P>;
export {};
