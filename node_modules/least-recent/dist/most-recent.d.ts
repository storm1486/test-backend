/**
 * LRUCache
 * ===================
 *
 * JavaScript implementation of the LRU Cache data structure. To save up
 * memory and allocations this implementation represents its underlying
 * doubly-linked list as static arrays and pointers. Thus, memory is allocated
 * only once at instantiation and JS objects are never created to serve as
 * pointers. This also means this implementation does not trigger too many
 * garbage collections.
 *
 * Note that to save up memory, a LRU Cache can be implemented using a singly
 * linked list by storing predecessors' pointers as hashmap values.
 * However, this means more hashmap lookups and would probably slow the whole
 * thing down. What's more, pointers are not the things taking most space in
 * memory.
 */
import { type Unsubscribe } from "nanoevents";
declare function from<TKey extends string | number, TValue>(iterable: Iterable<[TKey, TValue]> & Partial<{
    size: number;
    length: number;
}>, capacity?: number): LRUCache<string | number, any>;
export interface Events<TKey extends string | number, TValue> {
    evicted: (key: TKey, value: TValue) => void;
}
export interface Emitting<TEvents> {
    on<K extends keyof TEvents>(this: this, event: K, cb: TEvents[K]): Unsubscribe;
}
/**
 * LRUCache.
 *
 * @constructor
 * @param {function} Keys     - Array class for storing keys.
 * @param {function} Values   - Array class for storing values.
 * @param {number}   capacity - Desired capacity.
 */
export declare class LRUCache<TKey extends string | number = string | number, TValue = any> implements Iterable<[TKey, TValue]>, Emitting<Events<TKey, TValue>> {
    readonly capacity: number;
    private readonly forward;
    private readonly backward;
    private readonly K;
    private readonly V;
    private readonly events;
    private readonly deleted;
    _size: number;
    private head;
    private tail;
    private items;
    private deletedSize;
    /**
     * Take an arbitrary iterable and convert it into a structure.
     */
    static from: typeof from;
    constructor(capacity: number);
    on<K extends keyof Events<TKey, TValue>>(event: K, cb: Events<TKey, TValue>[K]): Unsubscribe;
    get size(): number;
    /**
     * Clear the structure.
     */
    clear(): void;
    /**
     * Splay a value on top.
     * @param pointer Pointer of the value to splay on top.
     */
    splayOnTop(pointer: number): void;
    /**
     * Set the value for the given key in the cache.
     */
    set(key: TKey, value: TValue): void;
    /**
     * Set the value for the given key in the cache
     * @param key
     * @param value
     * @return {{evicted: boolean, key: any, value: any}} An object containing the
     * key and value of an item that was overwritten or evicted in the set
     * operation, as well as a boolean indicating whether it was evicted due to
     * limited capacity. Return value is null if nothing was evicted or overwritten
     * during the set operation.
     */
    setpop(key: TKey, value: TValue): null | {
        value: TValue;
        key: TKey;
        evicted: boolean;
    };
    /**
     * Delete the entry for the given key in the cache.
     * Return `true` if the item was present.
     */
    delete(key: TKey): boolean;
    /**
     * Check whether the key exists in the cache.
     */
    has(key: TKey): boolean;
    /**
     * Get the value attached to the given key. Will move the
     * related key to the front of the underlying linked list.
     */
    get(key: TKey): TValue | undefined;
    /**
     * Method used to get the value attached to the given key. Does not modify
     * the ordering of the underlying linked list.
     */
    peek(key: TKey): TValue | undefined;
    /**
     * Create an iterator over the cache's keys from most
     * recently used to least recently used.
     */
    keys(): Iterator<TKey> & Iterable<TKey>;
    /**
     * Create an iterator over the cache's values from most
     * recently used to least recently used.
     */
    values(): Iterator<TValue> & Iterable<TValue>;
    /**
     * Create an iterator over the cache's entries from most
     * recently used to least recently used.
     */
    entries(): Iterator<[TKey, TValue]> & Iterable<[TKey, TValue]>;
    inspect(): Map<TKey, TValue>;
    private storeKeyValue;
    [Symbol.iterator](): Iterator<[TKey, TValue], any, undefined> & Iterable<[TKey, TValue]>;
}
export {};
