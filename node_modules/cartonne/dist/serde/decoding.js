import { decode as decodeVarint } from "varintes/decode";
import { CID } from "multiformats/cid";
import * as Digest from "multiformats/hashes/digest";
import { decode as decodeDagCbor } from "@ipld/dag-cbor";
import { EOF_MARK, isEOF } from "./eof-mark.js";
import { InvalidSectionError } from "./invalid-section.error.js";
import { InvalidHeaderError } from "./invalid-header.error.js";
import { CarVersion } from "../car-version.js";
import { UnknownVersionError } from "./unknown-version.error.js";
import { InvalidBlockError } from "../invalid-block.error.js";
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70,
};
export function readVarint(bytesSource) {
    const bytes = bytesSource.upTo(8);
    const [i, bytesRead] = decodeVarint(bytes);
    bytesSource.move(-(bytes.length - bytesRead));
    return i;
}
export function readVarintSafe(bytesSource) {
    const bytes = bytesSource.upTo(8);
    if (bytes.length === 0)
        return EOF_MARK;
    const [i, bytesRead] = decodeVarint(bytes);
    bytesSource.move(-(bytes.length - bytesRead));
    return i;
}
function isCID(input) {
    return Boolean(CID.asCID(input));
}
export function readMultihash(bytesSource) {
    const code = readVarint(bytesSource);
    const size = readVarint(bytesSource);
    const digest = bytesSource.exactly(size);
    return Digest.create(code, digest);
}
export function readCID(bytesSource) {
    const first = bytesSource.exactly(2);
    bytesSource.move(-2);
    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
        const bytes = bytesSource.exactly(34);
        const multihash = Digest.decode(bytes);
        return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);
    }
    const version = readVarint(bytesSource);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = readVarint(bytesSource);
    const multihash = readMultihash(bytesSource);
    return CID.create(version, codec, multihash);
}
function validateHeaderV1(input) {
    return (typeof input === "object" &&
        input.version === CarVersion.ONE &&
        Array.isArray(input.roots) &&
        input.roots.every((r) => isCID(r)));
}
export function readHeader(bytesSource, expectedVersion) {
    const length = readVarint(bytesSource);
    const bytes = bytesSource.exactly(length);
    const decoded = decodeDagCbor(bytes);
    const decodedVersion = decoded?.version;
    if (expectedVersion && expectedVersion !== decodedVersion) {
        throw new InvalidHeaderError(`Expected version ${expectedVersion}`);
    }
    switch (decodedVersion) {
        case CarVersion.ONE:
            if (validateHeaderV1(decoded)) {
                return decoded;
            }
            else {
                throw new InvalidHeaderError(`Invalid CARv1 Header`);
            }
        case CarVersion.TWO:
            const bytes = bytesSource.exactly(40);
            const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
            const headerV2pre = {
                version: CarVersion.TWO,
                characteristics: [dataView.getBigUint64(0, true), dataView.getBigUint64(8, true)],
                dataOffset: Number(dataView.getBigUint64(16, true)),
                dataSize: Number(dataView.getBigUint64(24, true)),
                indexOffset: Number(dataView.getBigUint64(32, true)),
            };
            bytesSource.exactly(headerV2pre.dataOffset - bytesSource.position);
            const v1 = readHeader(bytesSource, 1);
            return Object.assign(headerV2pre, { roots: v1.roots });
        default:
            throw new UnknownVersionError(decodedVersion);
    }
}
export function readBlockHeader(bytesSource) {
    const start = bytesSource.position;
    const length = readVarintSafe(bytesSource);
    if (isEOF(length))
        return EOF_MARK;
    if (length === 0) {
        throw new InvalidSectionError("zero length");
    }
    const reportedLength = length + bytesSource.position - start;
    const cid = readCID(bytesSource);
    const bytesLength = reportedLength - (bytesSource.position - start);
    return {
        cid: cid,
        encodedLength: reportedLength,
        payloadLength: bytesLength,
    };
}
function verifyBlock(hashers, cid, bytes) {
    const hasherCode = cid.multihash.code;
    const hasher = hashers.get(hasherCode);
    const digestCalculated = hasher.digest(bytes).digest;
    const digestFromCID = cid.multihash.digest;
    if (digestCalculated.byteLength !== digestFromCID.byteLength) {
        throw new InvalidBlockError(cid);
    }
    for (let x = 0; x <= digestCalculated.byteLength; x++) {
        if (digestCalculated[x] !== digestFromCID[x]) {
            throw new InvalidBlockError(cid);
        }
    }
}
export function readBlock(bytesSource, hashers, verify = false) {
    const header = readBlockHeader(bytesSource);
    if (isEOF(header))
        return EOF_MARK;
    const cid = header.cid;
    const bytes = bytesSource.exactly(header.payloadLength);
    if (verify) {
        verifyBlock(hashers, cid, bytes);
    }
    return {
        payload: bytes,
        cid: cid,
        encodedLength: header.encodedLength,
    };
}
export function* readBlocks(bytesSource, hashers, verify = false) {
    while (true) {
        const block = readBlock(bytesSource, hashers, verify);
        if (isEOF(block))
            return;
        yield block;
    }
}
