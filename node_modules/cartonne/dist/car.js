import { CarVersion } from "./car-version.js";
import { CID } from "multiformats/cid";
import { CarBlock } from "./block.js";
import { bases } from "multiformats/basics";
import { BlockStorage } from "./block-storage.js";
import { writerV2, writerV1, asAsyncGenerator } from "./serde/writer.js";
import { UnknownVersionError } from "./serde/unknown-version.error.js";
import { concatIterable } from "./ancillary/concat-its.js";
import * as dagCbor from "@ipld/dag-cbor";
import { sha256 } from "multihashes-sync/sha2";
const DEFAULT_PUT_OPTIONS = {
    codec: dagCbor,
    hasher: sha256,
    isRoot: false,
};
export class CAR {
    version;
    roots;
    blocks;
    codecs;
    hashers;
    constructor(version, roots, blocks, codecs, hashers) {
        this.version = version;
        this.roots = roots;
        this.blocks = new BlockStorage();
        for (const block of blocks) {
            this.blocks.put(block);
        }
        this.codecs = codecs;
        this.hashers = hashers;
    }
    put(value, options = {}) {
        const effectiveOptions = Object.assign({}, DEFAULT_PUT_OPTIONS, options);
        const codec = this.codecs.get(effectiveOptions.codec);
        const bytes = codec.encode(value);
        const hasher = this.hashers.get(effectiveOptions.hasher);
        const digest = hasher.digest(bytes);
        const cid = CID.createV1(codec.code, digest);
        this.blocks.put(new CarBlock(cid, bytes));
        if (options.isRoot) {
            this.roots.push(cid);
        }
        return cid;
    }
    delete(key) {
        this.blocks.delete(key);
    }
    get(key) {
        const codecCode = key.code;
        const codec = this.codecs.get(codecCode);
        const block = this.blocks.get(key);
        if (!block)
            return undefined;
        return codec.decode(block.payload);
    }
    asV1() {
        return new CAR(CarVersion.ONE, this.roots, this.blocks, this.codecs, this.hashers);
    }
    asV2() {
        return new CAR(CarVersion.TWO, this.roots, this.blocks, this.codecs, this.hashers);
    }
    get bytes() {
        return concatIterable(this);
    }
    toString(base = "base64url") {
        return bases[base].encode(this.bytes);
    }
    [Symbol.iterator]() {
        switch (this.version) {
            case CarVersion.ONE:
                return writerV1(this.roots, this.blocks);
            case CarVersion.TWO:
                return writerV2(this.roots, this.blocks);
            default:
                throw new UnknownVersionError(this.version);
        }
    }
    [Symbol.asyncIterator]() {
        return asAsyncGenerator(this);
    }
}
