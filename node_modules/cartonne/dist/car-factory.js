import * as dagCbor from "@ipld/dag-cbor";
import { CAR } from "./car.js";
import { concatAsyncIterable, concatIterable } from "./ancillary/concat-its.js";
import { CodenameContainer } from "./codename-container.js";
import { sha256, sha512 } from "multihashes-sync/sha2";
import { CarVersion } from "./car-version.js";
import { BytesSource } from "./serde/bytes-source.js";
import { readBlocks, readHeader } from "./serde/decoding.js";
import { identity } from "multiformats/hashes/identity";
export class CARFactory {
    #codecs;
    #hashers;
    constructor() {
        this.#codecs = new CodenameContainer("codecs");
        this.#codecs.add(dagCbor);
        this.#hashers = new CodenameContainer("hashers");
        this.#hashers.add(sha256);
        this.#hashers.add(sha512);
        this.#hashers.add(identity);
    }
    get codecs() {
        return this.#codecs;
    }
    get hashers() {
        return this.#hashers;
    }
    build(version = CarVersion.ONE) {
        return new CAR(version, [], [], this.#codecs, this.#hashers);
    }
    fromBytes(bytes, opts = {}) {
        let bytesSource = new BytesSource(bytes);
        const header = readHeader(bytesSource);
        if (header.version === CarVersion.TWO) {
            bytesSource = new BytesSource(bytes.subarray(bytesSource.position, header.dataSize + header.dataOffset));
        }
        return new CAR(header.version, header.roots, readBlocks(bytesSource, this.#hashers, opts.verify), this.#codecs, this.#hashers);
    }
    fromIterable(iter, opts = {}) {
        return this.fromBytes(concatIterable(iter), opts);
    }
    async fromAsyncIterable(iter, opts = {}) {
        const bytes = await concatAsyncIterable(iter);
        return this.fromBytes(bytes, opts);
    }
}
